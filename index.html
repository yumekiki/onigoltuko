<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤åŸºç›¤ - å®Œå…¨ç‰ˆï¼ˆè¿·è·¯ãƒ»å®‰å®šåŒ–ãƒ»Carryæ”¹å–„ãƒ»BGMï¼‰</title>
<style>
  :root{ --bg:#0d0f12; --panel:#111317; --muted:#9aa3ad; }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui, "Hiragino Kaku Gothic ProN","ãƒ¡ã‚¤ãƒªã‚ª",sans-serif;background:var(--bg);color:#e6eef6}
  #app{display:flex;gap:12px;padding:12px;height:100vh}
  #left{flex:1;display:flex;flex-direction:column;gap:12px;align-items:center}
  #right{width:380px;background:linear-gradient(180deg,#0b0d10,#0f1113);padding:14px;border-radius:10px;display:flex;flex-direction:column;gap:12px}
  canvas{border-radius:8px;background:#081018;display:block}
  .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:8px;width:100%}
  .center{text-align:center}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 12px;border-radius:8px;cursor:pointer}
  .big{font-size:1.05rem;padding:10px 14px}
  .small{font-size:0.85rem;color:var(--muted)}
  .scoreBox{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px}
  #log{flex:1;overflow:auto;padding:8px}
  .logItem{margin-bottom:6px;font-size:0.95rem;padding:6px 8px;border-radius:8px}
  .log-info{background:rgba(255,255,255,0.02);color:#dbe9ff}
  .log-event{background:rgba(255,215,170,0.06);color:#fff0df}
  .log-error{background:rgba(255,80,80,0.06);color:#ffd3d3}
  #adminSmall{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:6px;font-size:.85rem;cursor:pointer;z-index:999}
  .hidden{display:none}
  .nameInput{padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;width:220px}
  #playerList{max-height:220px;overflow:auto;padding:6px;display:flex;flex-direction:column;gap:6px}
  .playerRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:6px;background:rgba(255,255,255,0.02)}
  .minimap{width:100%;height:140px;border-radius:6px;background:#041218;display:block}
  #loadingOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:9999;color:#fff;font-size:1.1rem}
  #boostStatus{margin-top:8px;font-weight:700;color:#bfffbf;text-align:center;min-height:22px}
  #dashStatus{font-weight:700;color:#ffd;margin-left:10px}
</style>
</head>
<body>
<div id="adminSmall">ç®¡ç†</div>

<div id="app">
  <div id="left">
    <div id="screen-waiting" class="panel">
      <div class="center">
        <h2>å¾…æ©Ÿ / ãƒ«ãƒ¼ãƒ«</h2>
        <p class="small">å‚åŠ ã™ã‚‹ã‚’æŠ¼ã™ã¨ãƒãƒ¼ãƒ é¸æŠã¸ã€‚BGMã¯å‚åŠ æ“ä½œå¾Œã«å†ç”Ÿã€‚</p>
        <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
          <button id="toTeamBtn" class="big">å‚åŠ ã™ã‚‹</button>
          <button id="homeResetBtn" class="big">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
      </div>
      <div style="margin-top:12px"><div class="small">ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ãƒ©ãƒ³ãƒ€ãƒ è¿·è·¯ï¼ˆé€šè·¯å¹…ã¯ååˆ†ï¼‰ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ãƒªã‚¹ãƒãƒ¼ãƒ³ã‚„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å£ã¨é‡ãªã‚‰ãªã„ã‚ˆã†é…ç½®ã—ã¾ã™ã€‚</div></div>
      <div style="margin-top:8px" class="small center">ãƒãƒ¼ãƒ äººæ•° â€” é¬¼: <span id="waitOniCount">0</span> / é€ƒã’: <span id="waitRunnerCount">0</span></div>
    </div>

    <div id="screen-team" class="panel hidden">
      <h2 class="center">ãƒãƒ¼ãƒ é¸æŠ</h2>
      <div style="display:flex;gap:12px;margin-top:12px">
        <button id="chooseOni" style="flex:1;background:linear-gradient(90deg,#ffecb3,#ffd54d);border-radius:10px">ğŸ‘¹ é¬¼<br><span id="oniCount" class="small">äººæ•°:0</span></button>
        <button id="chooseRunner" style="flex:1;background:linear-gradient(90deg,#bfe8ff,#4db8ff);border-radius:10px">ğŸƒ é€ƒã’<br><span id="runnerCount" class="small">äººæ•°:0</span></button>
      </div>
      <div style="margin-top:12px" class="center"><button id="backFromTeam">æˆ»ã‚‹</button></div>
    </div>

    <div id="screen-join" class="panel hidden">
      <h2 class="center">åå‰ã‚’å…¥åŠ›ã—ã¦å‚åŠ </h2>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:8px">
        <input id="inputName" class="nameInput" placeholder="åå‰ã‚’å…¥åŠ›" maxlength="16" />
        <button id="joinNow">å‚åŠ </button>
      </div>
      <div style="margin-top:8px;text-align:center"><button id="backFromJoin">æˆ»ã‚‹</button></div>
    </div>

    <div id="screen-game" class="panel hidden" style="width:100%">
      <div style="display:flex;align-items:center;gap:12px">
        <div class="scoreBox" style="background:linear-gradient(90deg,#ffefd5,#fff1cc);color:#1a1200">ğŸ‘¹ é¬¼: <span id="topOni">0</span></div>
        <div class="scoreBox" style="background:linear-gradient(90deg,#dff4ff,#d6f0ff);color:#022033">ğŸƒ é€ƒã’ æ®‹ã‚Š: <span id="topRunnerRem">4</span></div>
        <div style="margin-left:auto;display:flex;align-items:center;gap:8px">
          <div id="dashStatus">ãƒ€ãƒƒã‚·ãƒ¥: -</div>
          <button id="leaveBtn">é›¢è„±</button>
        </div>
      </div>

      <div style="margin-top:12px;width:100%">
        <canvas id="gameCanvas" width="1200" height="640"></canvas>
        <div id="boostStatus" class="panel" style="margin-top:8px;background:linear-gradient(180deg,#06281f,#0b3940)"></div>
      </div>
    </div>
  </div>

  <div id="right">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div id="playerInfoName" style="font-weight:700">æœªå‚åŠ </div>
          <div id="playerInfoTeam" class="small">ãƒãƒ¼ãƒ : -</div>
        </div>
        <div><div class="small">æ”¾ç½®: <span id="idleCount">0</span>s</div></div>
      </div>
    </div>

    <div class="panel" style="display:flex;flex-direction:column;gap:8px;height:40vh">
      <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</div><div class="small">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ </div></div>
      <div id="playerList"></div>
      <div class="small">ï¼ˆç®¡ç†è€…ã¯åº§æ¨™ãƒ»é€€å‡ºãƒœã‚¿ãƒ³ã‚’æ“ä½œå¯ï¼‰</div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°</div><div class="small">10ç§’ã§æ¶ˆãˆã¾ã™</div>
      </div>
      <div id="log" class="muted"></div>
      <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
        <button id="adminReset" class="hidden">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button>
        <div class="small" id="statusSmall">çŠ¶æ…‹: åˆæœŸ</div>
      </div>
      <div style="margin-top:8px">
        <canvas id="miniMap" class="minimap"></canvas>
        <div class="small">map.png ã‚’ç½®ãã¨èƒŒæ™¯ã«åæ˜ ã•ã‚Œã¾ã™ã€‚</div>
      </div>
    </div>
  </div>
</div>

<div id="loadingOverlay">å‡¦ç†ä¸­... å°‘ã—ãŠå¾…ã¡ãã ã•ã„</div>

<!-- assets -->
<audio id="bgm" src="bgm.mp3" preload="auto" loop></audio>
<audio id="asioto" src="asioto.mp3" preload="auto"></audio>
<audio id="explosion" src="explosion.mp3" preload="auto"></audio>

<script type="module">
/*
  å®Œå…¨ç‰ˆ single-file
  - ç›®çš„: å®‰å®šæ€§æœ€å„ªå…ˆã€‚è¿·è·¯ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã‚’ç”Ÿæˆã—ã€å£ã¨é‡ãªã‚‰ãªã„ã‚ˆã†ã«é…ç½®ã€‚
  - SHIFTã§ç¢ºå®Ÿã«æ‹¾ãˆã‚‹ã‚ˆã†ã«ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ï¼‹ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½ç½®ä¿®æ­£ã‚’å°å…¥ã€‚
  - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•ã¯å£ã‚»ãƒ«åˆ¤å®šã§è¡çªå›é¿ï¼ˆã‚¹ãƒ©ã‚¤ãƒ‰/ç¸®å°è©¦è¡Œï¼‰ã—ã¦è©°ã¾ã‚‰ãªã„ã‚ˆã†ã«ã€‚
  - Firestore v12.7.0 ã‚’åˆ©ç”¨ã€‚firebaseConfig ã¯åŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã¾ã™ï¼ˆprovided earlierï¼‰ã€‚
  - é‡è¦: ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãã®ã¾ã¾ä¿å­˜ã—ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦ãã ã•ã„ã€‚map.png ç­‰ã‚¢ã‚»ãƒƒãƒˆã‚’åŒãƒ•ã‚©ãƒ«ãƒ€ã«é…ç½®ã—ï¿½ï¿½ãã ã•ã„ã€‚
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js";
import {
  getFirestore, collection, doc, addDoc, setDoc, updateDoc, deleteDoc, getDoc,
  onSnapshot, getDocs, runTransaction, writeBatch, serverTimestamp, Timestamp
} from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

/* ========== Firebase config (user) ========== */
const firebaseConfig = {
  apiKey: "AIzaSyBmgtx4FW_3_0zy1MvAvZLPHmE_CE1txuE",
  authDomain: "zzke-ki1.firebaseapp.com",
  databaseURL: "https://zzke-ki1-default-rtdb.firebaseio.com",
  projectId: "zzke-ki1",
  storageBucket: "zzke-ki1.firebasestorage.app",
  messagingSenderId: "260981230516",
  appId: "1:260981230516:web:146a29f15b2716a9af80e1",
  measurementId: "G-GF5G1D4E10"
};

const app = initializeApp(firebaseConfig);
try { getAnalytics(app); } catch(e){ /* ignore */ }
const db = getFirestore(app);

/* ========== Constants & Tunables ========== */
const GAME_COLLECTION = "games";
const GAME_DOC_ID = "current_round";
const PLAYERS_COL = "players";
const STRAWBERRIES_COL = "strawberries";
const DELIVERIES_COL = "deliveries";
const WALLS_COL = "walls";

const MAP_SIZE = 2000;
const PLAYER_RADIUS = 14; // used for collision checks
const PICKUP_RADIUS = 80;
const CAPTURE_RADIUS = 36;
const POSITION_THROTTLE_MS = 180;
const WIN_SCORE = 50;

/* Speed multipliers (user requested all speeds *1.5 earlier; apply now via base speeds) */
const GLOBAL_SPEED_MULT = 1.5;
const BASE_RUNNER_SPEED = 2.6;
const BASE_ONI_SPEED = 2.4;
let RUNNER_SPEED = BASE_RUNNER_SPEED * GLOBAL_SPEED_MULT;
let ONI_SPEED = BASE_ONI_SPEED * GLOBAL_SPEED_MULT;

/* Dash: requested to be further multiplied by 3 -> set DASH_MULT accordingly (tuneable) */
let DASH_MULT = 9.0; // tune if too big
const DASH_DUR_MS = 3000;
const DASH_CT_MS = 10000;

/* Carry */
const CARRY_SPEED_MULT = 0.4;

/* Coop boost */
const COOP_BOOST_DIST = 120;
const COOP_SPEED_MULT = 1.3;

/* Footstep audible range multiplier (make configurable as user requested) */
let FOOTSTEP_RANGE_MULT = 5;

/* Maze generation parameters */
const MAZE_COLS = 25; // grid for maze carving
const MAZE_ROWS = 25;
const CELL_SIZE = Math.floor(MAP_SIZE / MAZE_COLS); // passage width roughly CELL_SIZE
// Ensure CELL_SIZE >= player size; with 25 cols on 2000 map: ~80, OK

/* Asset filenames (place in same folder) */
const ASSETS = {
  map: "map.png",
  runner: "runner.png",
  oni: "oni.png",
  delivery: "delivery.png",
  strawberry: "strawberry.png"
};

/* Admin password */
const ADMIN_PASS = "1122";

/* ========== State ========== */
let sessionId = null;
let localPlayer = null;
let allPlayers = [];
let strawberries = [];
let deliveries = [];
let walls = []; // local cache of wall cells (objects with col,row)
let wallsRectangles = []; // precomputed rectangles for collision/visuals
let gameDoc = null;
let lastPosSend = 0;
let joinedTeamChoice = null;
let adminMode = false;
let isBgmPlaying = false;

/* UI refs */
const screens = {
  waiting: document.getElementById("screen-waiting"),
  team: document.getElementById("screen-team"),
  join: document.getElementById("screen-join"),
  game: document.getElementById("screen-game")
};
const loadingOverlay = document.getElementById("loadingOverlay");
const gameCanvas = document.getElementById("gameCanvas");
const gctx = gameCanvas.getContext("2d");
const miniMap = document.getElementById("miniMap");
const miniCtx = miniMap.getContext("2d");
const boostStatusEl = document.getElementById("boostStatus");
const bgmAudio = document.getElementById("bgm");

const toTeamBtn = document.getElementById("toTeamBtn");
const chooseOni = document.getElementById("chooseOni");
const chooseRunner = document.getElementById("chooseRunner");
const backFromTeam = document.getElementById("backFromTeam");
const backFromJoin = document.getElementById("backFromJoin");
const joinNow = document.getElementById("joinNow");
const inputName = document.getElementById("inputName");
const leaveBtn = document.getElementById("leaveBtn");
const playerInfoName = document.getElementById("playerInfoName");
const playerInfoTeam = document.getElementById("playerInfoTeam");
const topOni = document.getElementById("topOni");
const topRunnerRem = document.getElementById("topRunnerRem");
const oniCountEl = document.getElementById("oniCount");
const runnerCountEl = document.getElementById("runnerCount");
const logEl = document.getElementById("log");
const adminSmall = document.getElementById("adminSmall");
const adminResetBtn = document.getElementById("adminReset");
const statusSmall = document.getElementById("statusSmall");
const playerListEl = document.getElementById("playerList");
const homeResetBtn = document.getElementById("homeResetBtn");
const dashStatusEl = document.getElementById("dashStatus");
const waitOniCount = document.getElementById("waitOniCount");
const waitRunnerCount = document.getElementById("waitRunnerCount");
const asiotoAudio = document.getElementById("asioto");
const explosionAudio = document.getElementById("explosion");

/* unsub handles */
let unsubGame = null, unsubPlayers = null, unsubStraw = null, unsubDeliveries = null, unsubWalls = null;

/* map & sprites */
const mapImage = new Image(); let mapImageLoaded = false;
const spriteRunner = new Image(); let spriteRunnerLoaded = false;
const spriteOni = new Image(); let spriteOniLoaded = false;
const spriteDelivery = new Image(); let spriteDeliveryLoaded = false;
const spriteStraw = new Image(); let spriteStrawLoaded = false;

mapImage.src = ASSETS.map; mapImage.onload = () => mapImageLoaded = true;
spriteRunner.src = ASSETS.runner; spriteRunner.onload = () => spriteRunnerLoaded = true;
spriteOni.src = ASSETS.oni; spriteOni.onload = () => spriteOniLoaded = true;
spriteDelivery.src = ASSETS.delivery; spriteDelivery.onload = () => spriteDeliveryLoaded = true;
spriteStraw.src = ASSETS.strawberry; spriteStraw.onload = () => spriteStrawLoaded = true;

/* camera smoothing */
const camera = { x: MAP_SIZE/2, y: MAP_SIZE/2, lerp: 0.18 };

/* Utilities --------------------------------------------------------------- */
function showScreen(name){ for(const k in screens) screens[k].classList.add("hidden"); screens[name].classList.remove("hidden"); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function nowMillis(){ return Date.now(); }
function showLoading(on){ loadingOverlay.style.display = on ? "flex" : "none"; }
function updateStatus(s){ statusSmall.textContent = "çŠ¶æ…‹: " + s; }
function log(text, type="info"){ const el=document.createElement("div"); el.className="logItem "+(type==="event"?"log-event":(type==="error"?"log-error":"log-info")); el.textContent=`[${new Date().toLocaleTimeString()}] ${text}`; logEl.prepend(el); setTimeout(()=>{ try{el.remove()}catch(e){} },10000); while(logEl.children.length>200) logEl.removeChild(logEl.lastChild); }

/* Maze generation (grid-based recursive backtracker) --------------------------------
   - carve passages on grid MAZE_COLS x MAZE_ROWS
   - passableCells[r][c] = true for corridor cells
   - walls are cells not carved
   - corridor cell size is CELL_SIZE
   - We save walls to Firestore once per round in collection WALLS_COL as list of wall cells {r,c}
   - spawn objects only in passable cells
*/
function generateMazeGrid(){
  // iterative stack to avoid recursion depth issues
  const cols = MAZE_COLS, rows = MAZE_ROWS;
  const visited = Array.from({length:rows},()=>Array(cols).fill(false));
  const passable = Array.from({length:rows},()=>Array(cols).fill(false));
  const stack = [];
  const sx = Math.floor(Math.random()*cols), sy = Math.floor(Math.random()*rows);
  stack.push({x:sx,y:sy});
  visited[sy][sx]=true;
  passable[sy][sx]=true;
  const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
  while(stack.length){
    const cur = stack[stack.length-1];
    const neighbors = [];
    for(const d of dirs){
      const nx = cur.x + d.dx*2;
      const ny = cur.y + d.dy*2;
      if (nx>=0 && nx<cols && ny>=0 && ny<rows && !visited[ny][nx]){
        neighbors.push(d);
      }
    }
    if (neighbors.length){
      const d = neighbors[Math.floor(Math.random()*neighbors.length)];
      const betweenX = cur.x + d.dx;
      const betweenY = cur.y + d.dy;
      const nx = cur.x + d.dx*2;
      const ny = cur.y + d.dy*2;
      visited[betweenY][betweenX]=true;
      visited[ny][nx]=true;
      passable[betweenY][betweenX]=true;
      passable[ny][nx]=true;
      passable[cur.y][cur.x]=true;
      stack.push({x:nx,y:ny});
    } else {
      stack.pop();
    }
  }
  return passable;
}

/* Convert passable grid to wall rectangles/list for collision checks:
   - wallsCells = all (r,c) where passable[r][c] === false
   - wallsRectangles: each rect {x,y,w,h} in world coords (0..MAP_SIZE)
*/
function buildWallRectanglesFromGrid(passable){
  const rows = passable.length, cols = passable[0].length;
  const rects = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if (!passable[r][c]){
        const x = c*CELL_SIZE, y = r*CELL_SIZE;
        rects.push({x,y,w:CELL_SIZE,h:CELL_SIZE});
      }
    }
  }
  return rects;
}

/* Save walls to Firestore (one document storing passable array would be large).
   Simpler: store a single canvas-like encoding: list of wall cell indices; to keep small, store as array of "r_c" strings.
*/
async function writeWallsToFirestore(passable){
  try {
    const wallIds = [];
    for(let r=0;r<MAZE_ROWS;r++){
      for(let c=0;c<MAZE_COLS;c++){
        if (!passable[r][c]) wallIds.push(`${r}_${c}`);
      }
    }
    // store as single doc in games/current_round/walls
    await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID + "_meta"), { walls: wallIds, mazeCols: MAZE_COLS, mazeRows: MAZE_ROWS, cellSize: CELL_SIZE, createdAt: serverTimestamp() });
  } catch(e){
    console.error("writeWallsToFirestore err", e);
  }
}

/* getWallsFromFirestore fallback */
async function readWallsFromFirestore(){
  try {
    const metaRef = doc(db, GAME_COLLECTION, GAME_DOC_ID + "_meta");
    const snap = await getDoc(metaRef);
    if (!snap.exists()) return null;
    const data = snap.data();
    const wallIds = data.walls || [];
    const rects = [];
    for (const key of wallIds){
      const [r,c] = key.split("_").map(x=>parseInt(x));
      if (!Number.isFinite(r) || !Number.isFinite(c)) continue;
      rects.push({x:c*CELL_SIZE,y:r*CELL_SIZE,w:CELL_SIZE,h:CELL_SIZE});
    }
    return rects;
  } catch(e){ return null; }
}

/* Collision helpers ----------------------------------------------------- */
/* Rectangle-circle collision: circle at (cx,cy) radius r vs rect {x,y,w,h} */
function circleRectOverlap(cx,cy,r,rect){
  const rx = Math.max(rect.x, Math.min(cx, rect.x+rect.w));
  const ry = Math.max(rect.y, Math.min(cy, rect.y+rect.h));
  const dx = cx - rx, dy = cy - ry;
  return (dx*dx + dy*dy) <= (r*r);
}

/* Test whether point inside any wall */
function pointInsideWall(x,y){
  for (const rect of wallsRectangles){
    if (x >= rect.x && x <= rect.x+rect.w && y >= rect.y && y <= rect.y+rect.h) return true;
  }
  return false;
}

/* Find nearest free position (center of a passable cell) to given x,y using spiral search on grid
   Ensures returned position is not inside a wall and not overlapping other objects.
*/
function findNearestFreePos(x,y){
  // map to cell indices
  const c0 = clamp(Math.floor(x / CELL_SIZE), 0, MAZE_COLS-1);
  const r0 = clamp(Math.floor(y / CELL_SIZE), 0, MAZE_ROWS-1);
  const visited = Array.from({length:MAZE_ROWS},()=>Array(MAZE_COLS).fill(false));
  const q = [{r:r0,c:c0}];
  visited[r0][c0]=true;
  while(q.length){
    const cur = q.shift();
    const cx = cur.c*CELL_SIZE + CELL_SIZE/2;
    const cy = cur.r*CELL_SIZE + CELL_SIZE/2;
    // check rect at center not overlapping walls
    const overlapping = wallsRectangles.some(rect => circleRectOverlap(cx,cy, PLAYER_RADIUS+2, rect));
    if (!overlapping) return {x: cx, y: cy};
    const neighbors = [{dr:1,dc:0},{dr:-1,dc:0},{dr:0,dc:1},{dr:0,dc:-1}];
    for (const n of neighbors){
      const nr = cur.r + n.dr, nc = cur.c + n.dc;
      if (nr>=0 && nr<MAZE_ROWS && nc>=0 && nc<MAZE_COLS && !visited[nr][nc]){
        visited[nr][nc]=true; q.push({r:nr,c:nc});
      }
    }
  }
  // fallback: random safe pos
  for (let i=0;i<200;i++){
    const px = Math.random()*MAP_SIZE, py = Math.random()*MAP_SIZE;
    if (!pointInsideWall(px,py)) return {x:px,y:py};
  }
  // ultimate fallback: center
  return {x:MAP_SIZE/2,y:MAP_SIZE/2};
}

/* Ensure object pos not inside wall; if so move to nearest free pos */
async function ensureNotInWallAndSave(ref, x, y, extraFields={}){
  try {
    if (!pointInsideWall(x,y)) {
      // save as-is
      await updateDoc(ref, {...extraFields});
      return;
    }
  } catch(e){}
  // find nearest free
  const pos = findNearestFreePos(x,y);
  try { await updateDoc(ref, {...extraFields, x: pos.x, y: pos.y}); } catch(e){}
}

/* Spawn helpers that avoid walls and other objects */
function randomPassablePos(){
  // choose random passable cell (cells that are not walls)
  // simple approach: sample random cells until find one not wall
  for (let i=0;i<200;i++){
    const c = Math.floor(Math.random()*MAZE_COLS), r = Math.floor(Math.random()*MAZE_ROWS);
    const rect = {x:c*CELL_SIZE,y:r*CELL_SIZE,w:CELL_SIZE,h:CELL_SIZE};
    // if rect intersects wallsRectangles? wallsRectangles represent wall cells, so check if this rect itself is a wall cell
    const isWall = wallsRectangles.some(wr => wr.x === rect.x && wr.y === rect.y);
    if (!isWall){
      // return random offset within cell with margin
      const margin = Math.max(PLAYER_RADIUS+4, 8);
      const px = clamp(rect.x + margin + Math.random()*(rect.w - margin*2), rect.x+margin, rect.x+rect.w-margin);
      const py = clamp(rect.y + margin + Math.random()*(rect.h - margin*2), rect.y+margin, rect.y+rect.h-margin);
      if (!pointInsideWall(px,py)) return {x:px,y:py};
    }
  }
  // fallback spiral search
  return findNearestFreePos(MAP_SIZE/2, MAP_SIZE/2);
}

/* Create maze walls and write to Firestore meta doc (ensures all clients have same walls) */
async function createAndStoreMazeIfNeeded(){
  try {
    // check if meta exists
    const metaRef = doc(db, GAME_COLLECTION, GAME_DOC_ID + "_meta");
    const metaSnap = await getDoc(metaRef);
    if (metaSnap.exists()){
      // read wallsRectangles
      const data = metaSnap.data();
      const wallIds = data.walls || [];
      wallsRectangles = [];
      for (const key of wallIds){
        const [r,c] = key.split("_").map(x=>parseInt(x));
        if (!Number.isFinite(r) || !Number.isFinite(c)) continue;
        wallsRectangles.push({x:c*CELL_SIZE, y:r*CELL_SIZE, w:CELL_SIZE, h:CELL_SIZE});
      }
      return;
    }
    // generate maze
    const passable = generateMazeGrid();
    // build wall ids
    const wallIds = [];
    for (let r=0;r<MAZE_ROWS;r++){
      for (let c=0;c<MAZE_COLS;c++){
        if (!passable[r][c]) wallIds.push(`${r}_${c}`);
      }
    }
    // store meta
    await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID + "_meta"), { walls: wallIds, mazeCols: MAZE_COLS, mazeRows: MAZE_ROWS, cellSize: CELL_SIZE, createdAt: serverTimestamp() });
    // set local wallsRectangles
    wallsRectangles = buildWallRectanglesFromGrid(passable);
  } catch(e){
    console.error("createAndStoreMazeIfNeeded err", e);
  }
}

/* Firestore helpers for seed: deliveries & strawberries; ensure they are in passable positions */
async function seedObjectsSafely(){
  try {
    // deliveries corners
    const dSnap = await getDocs(collection(db, DELIVERIES_COL));
    if (dSnap.size === 0){
      const pts = [
        { x: 80, y: 80, occupied:false, strawberryId:null },
        { x: MAP_SIZE-80, y: 80, occupied:false, strawberryId:null },
        { x: 80, y: MAP_SIZE-80, occupied:false, strawberryId:null },
        { x: MAP_SIZE-80, y: MAP_SIZE-80, occupied:false, strawberryId:null }
      ];
      for (const p of pts){
        const safe = findNearestFreePos(p.x,p.y);
        await addDoc(collection(db, DELIVERIES_COL), { x:safe.x, y:safe.y, occupied:false, strawberryId:null });
      }
    }
    // strawberries: ensure exactly 4 central-biased
    const sSnap = await getDocs(collection(db, STRAWBERRIES_COL));
    if (sSnap.size < 4){
      const toAdd = 4 - sSnap.size;
      for (let i=0;i<toAdd;i++){
        const pos = randomPassablePos();
        await addDoc(collection(db, STRAWBERRIES_COL), { x: pos.x, y: pos.y, available:true, ownerId:null, placedAtDelivery:null });
      }
    } else if (sSnap.size > 4){
      // optionally trim extras? keep as-is
    } else {
      // ensure none overlap walls; reposition if necessary
      for (const d of sSnap.docs){
        const data = d.data();
        if (pointInsideWall(data.x, data.y)){
          const safe = randomPassablePos();
          try { await updateDoc(doc(db, STRAWBERRIES_COL, d.id), { x: safe.x, y: safe.y, available:true, ownerId:null, placedAtDelivery:null }); } catch(e){}
        }
      }
    }
  } catch(e){
    console.error("seedObjectsSafely err", e);
  }
}

/* ========== Stable join flow (prevents first-join bug) ========== */
async function joinAs(name, team){
  showLoading(true);
  await ensureGame();
  try {
    // delete same-name previous
    try {
      const snaps = await getDocs(collection(db, PLAYERS_COL));
      for (const d of snaps.docs){
        const data = d.data();
        if (data && data.name === name){
          try { await deleteDoc(d.ref); log(`å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³(${name})ã‚’å‰Šé™¤`, "info"); } catch(e){}
        }
      }
    } catch(e){}
    // create player doc in safe passable pos
    const pos = randomPassablePos();
    const pRef = await addDoc(collection(db, PLAYERS_COL), {
      name: name || "Player", team, x: pos.x, y: pos.y, possession: 0, lastAction: serverTimestamp(), dashReadyAt: 0, carryingStraw: null
    });
    sessionId = pRef.id;
    setupListeners();
    // wait for snapshot reflect
    const start = Date.now(); let ok=false;
    while(Date.now()-start < 5000){
      if (allPlayers.find(p => p._id === sessionId)){ ok=true; break; }
      await new Promise(r => setTimeout(r,150));
    }
    if (!ok) log("å‚åŠ ã®åæ˜ ã«é…å»¶ãŒã‚ã‚Šã¾ã™ãŒç¶šè¡Œã—ã¾ã™", "error");
    // set playing if waiting
    try {
      await runTransaction(db, async (t) => {
        const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
        const s = await t.get(gRef);
        if (!s.exists()) throw new Error("game missing");
        const g = s.data();
        if (g.state === "waiting") t.update(gRef, { state: "playing" });
      });
    } catch(e){}
    // play bgm (user interaction ensures browser allows)
    try { bgmAudio.currentTime = 0; bgmAudio.play().catch(()=>{}); isBgmPlaying=true; } catch(e){}
    showLoading(false);
    showScreen("game");
    updateStatus("å‚åŠ ä¸­: " + name + " (" + team + ")");
    log(`${name} ãŒå‚åŠ ã—ã¾ã—ãŸ (ãƒãƒ¼ãƒ : ${team})`, "event");
  } catch(e){
    showLoading(false);
    log("å‚åŠ å¤±æ•—: "+(e.message||e), "error");
    alert("å‚åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
  }
}

/* ========== Listeners (players, strawberries, deliveries, walls meta) ========== */
function setupListeners(){
  const metaRef = doc(db, GAME_COLLECTION, GAME_DOC_ID + "_meta");
  // walls meta
  metaRef && onSnapshot(metaRef, (snap)=>{
    if (!snap.exists()) return;
    const data = snap.data();
    const wallIds = data.walls || [];
    wallsRectangles = [];
    for (const key of wallIds){
      const [r,c] = key.split("_").map(x=>parseInt(x));
      if (!Number.isFinite(r) || !Number.isFinite(c)) continue;
      wallsRectangles.push({x:c*CELL_SIZE, y:r*CELL_SIZE, w:CELL_SIZE, h:CELL_SIZE});
    }
  });

  if (unsubGame) unsubGame();
  unsubGame = onSnapshot(doc(db, GAME_COLLECTION, GAME_DOC_ID), (snap) => {
    if (!snap.exists()) return;
    gameDoc = snap.data();
    topOni.textContent = gameDoc.scores?.oni || 0;
    if (gameDoc.state === "waiting") { log("ãƒ©ã‚¦ãƒ³ãƒ‰å¾…æ©Ÿã«æˆ»ã‚Šã¾ã—ãŸ", "info"); showScreen("team"); }
  });

  if (unsubPlayers) unsubPlayers();
  unsubPlayers = onSnapshot(collection(db, PLAYERS_COL), (snap) => {
    const arr=[]; snap.forEach(d=>{const data=d.data(); data._id=d.id; arr.push(data);});
    allPlayers=arr;
    localPlayer = allPlayers.find(p=>p._id===sessionId) || localPlayer;
    const oniCount = allPlayers.filter(p=>p.team==="oni").length;
    const runnerCount = allPlayers.filter(p=>p.team==="runner").length;
    oniCountEl.textContent = "äººæ•°: " + oniCount;
    runnerCountEl.textContent = "äººæ•°: " + runnerCount;
    waitOniCount.textContent = oniCount;
    waitRunnerCount.textContent = runnerCount;
    if (localPlayer){ playerInfoName.textContent = localPlayer.name; playerInfoTeam.textContent = "ãƒãƒ¼ãƒ : " + localPlayer.team; } else { playerInfoName.textContent = "æœªå‚åŠ "; playerInfoTeam.textContent = "ãƒãƒ¼ãƒ : -"; }
    renderPlayerList();
    // ensure no player inside wall: respawn if inside
    for (const p of allPlayers){
      if (p.x===undefined||p.y===undefined) continue;
      if (pointInsideWall(p.x,p.y)){
        const safe = findNearestFreePos(p.x,p.y);
        try{ updateDoc(doc(db, PLAYERS_COL, p._id), { x: safe.x, y: safe.y, lastAction: serverTimestamp() }); } catch(e){}
      }
    }
  });

  if (unsubStraw) unsubStraw();
  unsubStraw = onSnapshot(collection(db, STRAWBERRIES_COL), (snap) => {
    const arr=[]; snap.forEach(d=>{const data=d.data(); data._id=d.id; arr.push(data);});
    strawberries = arr;
  });

  if (unsubDeliveries) unsubDeliveries();
  unsubDeliveries = onSnapshot(collection(db, DELIVERIES_COL), (snap) => {
    const arr=[]; snap.forEach(d=>{const data=d.data(); data._id=d.id; arr.push(data);});
    deliveries = arr;
    const occupied = deliveries.filter(d=>d.occupied).length;
    topRunnerRem.textContent = Math.max(0, 4 - occupied);
    if (deliveries.length >=4 && occupied>=4){
      log("é€ƒã’ãƒãƒ¼ãƒ ãŒå…¨ç´å“æ‰€ã‚’åŸ‹ã‚ã¾ã—ãŸï¼é€ƒã’å‹åˆ©ï¼", "event");
      (async ()=>{ const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID); const gSnap = await getDoc(gRef); const g = gSnap.exists()?gSnap.data():{scores:{oni:0,runner:0}}; await setDoc(gRef, {...g, state:"ended"}); await finalizeAndResetRound(); })();
    }
  });
}

/* Tear down listeners */
function tearDownListeners(){
  if (unsubGame) unsubGame(); unsubGame=null;
  if (unsubPlayers) unsubPlayers(); unsubPlayers=null;
  if (unsubStraw) unsubStraw(); unsubStraw=null;
  if (unsubDeliveries) unsubDeliveries(); unsubDeliveries=null;
  allPlayers=[]; strawberries=[]; deliveries=[]; wallsRectangles=[]; gameDoc=null;
  renderPlayerList();
}

/* ========== Finalize & Reset ========== */
async function finalizeAndResetRound(){
  try {
    async function delAll(col){
      const snaps = await getDocs(collection(db, col));
      const batch = writeBatch(db);
      for (const d of snaps.docs) batch.delete(d.ref);
      if (snaps.size) await batch.commit();
    }
    await delAll(PLAYERS_COL);
    await delAll(STRAWBERRIES_COL);
    await delAll(DELIVERIES_COL);
    // delete meta doc
    try { await deleteDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID + "_meta")); } catch(e){}
    await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { state:"waiting", scores:{oni:0, runner:0}, mapSize:MAP_SIZE, runnerRemaining:4, createdAt: serverTimestamp() });
    log("å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ï¼šãƒ©ã‚¦ãƒ³ãƒ‰ãƒªã‚»ãƒƒãƒˆ", "event");
    // regenerate maze & seed objects
    await createAndStoreMazeIfNeeded();
    await seedMapOnce(); // write walls & objects properly
  } catch(e){ console.error("finalize err", e); }
}

/* ========== Seed map once: create maze, store walls, create deliveries & strawberries safely ========== */
async function seedMapOnce(){
  try {
    // create maze meta if not exist
    await createAndStoreMazeIfNeeded();
    // ensure deliveries and strawberries properly placed without overlapping walls
    await seedObjectsSafely();
  } catch(e){ console.error("seedMapOnce err", e); }
}

/* ========== Carry mechanics (robust pickup & placement) ========== */
/* Attempt pickup by transaction that force-claims nearest strawberry within radius.
   This function ensures even if strawberry data is weird (available false but ownerId null or placed), the player can pick it by relocating it to player's pos and setting ownerId.
*/
async function pickupNearestStrawbyForce(playerId, playerX, playerY){
  try {
    // find nearest strawberry within PICKUP_RADIUS (local cache)
    let nearest = null; let nd = Infinity;
    for (const s of strawberries){
      if (s.placedAtDelivery) continue; // placed on delivery can't be picked
      const d = Math.hypot(s.x - playerX, s.y - playerY);
      if (d <= PICKUP_RADIUS && d < nd){ nd = d; nearest = s; }
    }
    if (!nearest){
      // no nearby strawberry; try expand radius up to CELL_SIZE
      for (const s of strawberries){
        if (s.placedAtDelivery) continue;
        const d = Math.hypot(s.x - playerX, s.y - playerY);
        if (d <= CELL_SIZE && d < nd){ nd = d; nearest = s; }
      }
    }
    if (!nearest) return false;
    // transactionally claim or force-claim
    const sRef = doc(db, STRAWBERRIES_COL, nearest._id);
    await runTransaction(db, async (t) => {
      const snap = await t.get(sRef);
      if (!snap.exists()) throw new Error("straw missing");
      const s = snap.data();
      // if it's already owned by someone else, abort
      if (s.ownerId && s.ownerId !== playerId) throw new Error("owned by another");
      // allow pickup even if available=false but ownerId=null (force)
      t.update(sRef, { ownerId: playerId, available: false, x: playerX, y: playerY, placedAtDelivery: null });
      // set player.carryingStraw
      const pRef = doc(db, PLAYERS_COL, playerId);
      t.update(pRef, { carryingStraw: nearest._id, lastAction: serverTimestamp() });
    });
    return true;
  } catch(e){
    // fallback: try to directly set owner if possible
    try {
      const s = nearest;
      if (!s) return false;
      await updateDoc(doc(db, STRAWBERRIES_COL, s._id), { ownerId: playerId, available: false, x: playerX, y: playerY, placedAtDelivery: null });
      try { await updateDoc(doc(db, PLAYERS_COL, playerId), { carryingStraw: s._id, lastAction: serverTimestamp() }); } catch(e){}
      return true;
    } catch(ex){
      return false;
    }
  }
}

/* Release carry (place at current position): allow re-pickup afterwards (ownerId cleared) */
async function placeCarriedStraw(playerId){
  try {
    const pSnap = await getDoc(doc(db, PLAYERS_COL, playerId));
    if (!pSnap.exists()) return;
    const p = pSnap.data();
    const strawId = p.carryingStraw;
    if (!strawId) return;
    const sRef = doc(db, STRAWBERRIES_COL, strawId);
    const sSnap = await getDoc(sRef);
    if (!sSnap.exists()) return;
    const s = sSnap.data();
    // ensure position not inside wall: if inside, move to nearest free
    let sx = s.x, sy = s.y;
    if (pointInsideWall(sx,sy)){
      const safe = findNearestFreePos(sx,sy);
      sx = safe.x; sy = safe.y;
    }
    await runTransaction(db, async (t) => {
      t.update(sRef, { ownerId: null, available: true, x: sx, y: sy, placedAtDelivery: null });
      t.update(doc(db, PLAYERS_COL, playerId), { carryingStraw: null, lastAction: serverTimestamp() });
    });
    log("ã‚¤ãƒã‚´ã‚’ãã®å ´ã«è¨­ç½®ã—ã¾ã—ãŸ", "event");
  } catch(e){ console.error("placeCarriedStraw err", e); }
}

/* checkPlacedOnDelivery for a strawberry (called when strawberry has ownerId null and is at a delivery pos or when carrier moves) */
async function checkPlacedOnDelivery(straw){
  try {
    if (!straw || straw.placedAtDelivery) return;
    for (const d of deliveries){
      const dist = Math.hypot(straw.x - d.x, straw.y - d.y);
      if (dist <= PICKUP_RADIUS && !d.occupied){
        await runTransaction(db, async (t) => {
          const dRef = doc(db, DELIVERIES_COL, d._id);
          const dSnap = await t.get(dRef);
          if (!dSnap.exists()) return;
          if (dSnap.data().occupied) return;
          t.update(dRef, { occupied: true, strawberryId: straw._id });
          const sRef = doc(db, STRAWBERRIES_COL, straw._id);
          t.update(sRef, { ownerId: null, available: false, placedAtDelivery: d._id });
          const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
          const gSnap = await t.get(gRef);
          if (gSnap.exists()){
            const g = gSnap.data();
            const remaining = Math.max(0, (g.runnerRemaining || 4) - 1);
            t.update(gRef, { runnerRemaining: remaining });
          }
        });
        log("ã‚¤ãƒã‚´ãŒç´å“æ‰€ã«è¨­ç½®ã•ã‚Œã¾ã—ãŸ", "event");
        return;
      }
    }
  } catch(e){ console.error("checkPlacedOnDelivery err", e); }
}

/* attemptCollectStraw: keep original cooperative auto-collection behavior but robust */
async function attemptCollectStraw(straw){
  try {
    if (!straw || !straw.available || straw.ownerId) return;
    const nearby = allPlayers.filter(p => p.team === "runner" && Math.hypot(p.x - straw.x, p.y - straw.y) <= PICKUP_RADIUS);
    if (nearby.length >= 2){
      await runTransaction(db, async (t) => {
        const sRef = doc(db, STRAWBERRIES_COL, straw._id);
        const sSnap = await t.get(sRef);
        if (!sSnap.exists()) throw new Error("straw missing");
        const sData = sSnap.data();
        if (!sData.available || sData.ownerId) throw new Error("already taken");
        t.update(sRef, { available: false });
        for (const p of nearby){
          const pRef = doc(db, PLAYERS_COL, p._id);
          const pSnap = await t.get(pRef);
          if (!pSnap.exists()) continue;
          const cur = pSnap.data().possession || 0;
          t.update(pRef, { possession: cur + 1, lastAction: serverTimestamp() });
        }
      });
      log(`ã‚¤ãƒã‚´è‡ªå‹•å›å: ${nearby.map(n=>n.name).join(", ")}`, "event");
      if (STRAW_RESPAWN_IMMEDIATE){
        const newPos = randomPassablePos();
        try { await updateDoc(doc(db, STRAWBERRIES_COL, straw._id), { x: newPos.x, y: newPos.y, available: true, ownerId: null, placedAtDelivery: null }); } catch(e){}
      }
    }
  } catch(e){ /* ignore race errors */ }
}

/* ========== Movement collision avoidance (prevents getting stuck) ===========
   - before applying new position, test if new pos circle collides with any wall rect
   - if collides try sliding along x or y, else reduce step in half iteratively up to N times
*/
function isCollidingWithWalls(x, y, radius=PLAYER_RADIUS){
  for (const rect of wallsRectangles){
    if (circleRectOverlap(x,y,radius,rect)) return true;
  }
  return false;
}

function resolveMovement(currX, currY, desiredX, desiredY){
  // if desired not colliding, return it
  if (!isCollidingWithWalls(desiredX, desiredY)) return {x:desiredX,y:desiredY};
  // try sliding on X only
  if (!isCollidingWithWalls(desiredX, currY)) return {x:desiredX,y:currY};
  // try sliding on Y only
  if (!isCollidingWithWalls(currX, desiredY)) return {x:currX,y:desiredY};
  // try shrinking movement: binary search steps
  let low = 0.0, high = 1.0, best = {x:currX,y:currY};
  for (let i=0;i<6;i++){
    const mid = (low+high)/2;
    const nx = currX + (desiredX-currX)*mid;
    const ny = currY + (desiredY-currY)*mid;
    if (!isCollidingWithWalls(nx,ny)){ best={x:nx,y:ny}; low = mid; } else { high = mid; }
  }
  return best;
}

/* ========== Player actions: pickup (Shift press) & place (Shift release) ==========
   - pickupNearestStrawbyForce ensures consistent pickup even if prior inconsistent states
   - placeCarriedStraw relocates to nearest free pos if needed and clears ownerId, allowing re-pickup
*/
async function pickupNearestStrawbyForceLocal(){
  if (!localPlayer) return;
  const ok = await pickupNearestStrawbyForce(sessionId, localPlayer.x, localPlayer.y);
  if (ok) {
    // update local state will come from snapshot; log done
  } else {
    // as fallback, try scan all strawberries and move the nearest one to player & claim
    let nearest = null, nd=Infinity;
    for (const s of strawberries){ const d = Math.hypot(s.x-localPlayer.x,s.y-localPlayer.y); if (d<nd){ nd=d; nearest=s; } }
    if (nearest && nd <= CELL_SIZE){
      try {
        await updateDoc(doc(db, STRAWBERRIES_COL, nearest._id), { ownerId: sessionId, available: false, x: localPlayer.x, y: localPlayer.y, placedAtDelivery: null });
        await updateDoc(doc(db, PLAYERS_COL, sessionId), { carryingStraw: nearest._id, lastAction: serverTimestamp() });
      } catch(e){ /* ignore */ }
    }
  }
}

async function pickupNearestStrawbyForce(playerId, playerX, playerY){
  // implemented above earlier in code area; reusing.
  try {
    let nearest=null, nd=Infinity;
    for (const s of strawberries){
      if (s.placedAtDelivery) continue;
      const d = Math.hypot(s.x-playerX, s.y-playerY);
      if (d <= Math.max(PICKUP_RADIUS, CELL_SIZE) && d < nd){ nd=d; nearest=s; }
    }
    if (!nearest) return false;
    const sRef = doc(db, STRAWBERRIES_COL, nearest._id);
    await runTransaction(db, async (t) => {
      const snap = await t.get(sRef);
      if (!snap.exists()) throw new Error("straw missing");
      const s = snap.data();
      if (s.ownerId && s.ownerId !== playerId) throw new Error("owned");
      t.update(sRef, { ownerId: playerId, available: false, x: playerX, y: playerY, placedAtDelivery: null });
      t.update(doc(db, PLAYERS_COL, playerId), { carryingStraw: nearest._id, lastAction: serverTimestamp() });
    });
    return true;
  } catch(e){
    // fallback direct write attempt
    try {
      if (!nearest) return false;
      await updateDoc(doc(db, STRAWBERRIES_COL, nearest._id), { ownerId: playerId, available: false, x: playerX, y: playerY, placedAtDelivery: null });
      try { await updateDoc(doc(db, PLAYERS_COL, playerId), { carryingStraw: nearest._id, lastAction: serverTimestamp() }); } catch(e){}
      return true;
    } catch(ex){ return false; }
  }
}

/* placeCarriedStraw implemented earlier as releaseCarriedStraw, reuse name */
async function releaseCarryByIdLocal(strawId){
  if (!strawId) return;
  try {
    const sRef = doc(db, STRAWBERRIES_COL, strawId);
    const sSnap = await getDoc(sRef);
    if (!sSnap.exists()) return;
    const s = sSnap.data();
    let sx = s.x, sy = s.y;
    if (pointInsideWall(sx,sy)){
      const safe = findNearestFreePos(sx,sy);
      sx = safe.x; sy = safe.y;
    }
    await runTransaction(db, async (t) => {
      t.update(sRef, { ownerId: null, available: true, x: sx, y: sy, placedAtDelivery: null });
      const pRef = doc(db, PLAYERS_COL, sessionId);
      t.update(pRef, { carryingStraw: null, lastAction: serverTimestamp() });
    });
    log("ã‚¤ãƒã‚´ã‚’è¨­ç½®ã—ã¾ã—ãŸ", "info");
  } catch(e){ console.error("releaseCarryByIdLocal err", e); }
}

/* ========== Movement loop (collision-aware) ========== */
const pressed = new Set();
let lastKeyEventTime = Date.now();
window.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){
    e.preventDefault(); lastKeyEventTime = Date.now(); pressed.add(k);
    if (k === "shift" && localPlayer && localPlayer.team === "runner"){
      // toggle pickup/place: if not carrying try pickup, if carrying place
      if (!localPlayer.carryingStraw) pickupNearestStrawbyForceLocal();
      else releaseCarryByIdLocal(localPlayer.carryingStraw);
    }
  }
});
window.addEventListener('keyup', (e)=>{ const k = e.key.toLowerCase(); if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){ e.preventDefault(); lastKeyEventTime = Date.now(); pressed.delete(k); }});
window.addEventListener('blur', ()=> pressed.clear());
setInterval(()=>{ if (Date.now() - lastKeyEventTime > 1000) pressed.clear(); }, 1200);

setInterval(async ()=>{
  if (!localPlayer || !sessionId) return;
  let sp = localPlayer.team === "oni" ? ONI_SPEED : RUNNER_SPEED;
  if (localPlayer.team === "oni" && (pressed.has("shift")) && canDash(localPlayer)) await startDash();
  if (localPlayer._isDashingUntil && Date.now() < localPlayer._isDashingUntil) sp *= DASH_MULT;
  if (localPlayer.carryingStraw) sp *= CARRY_SPEED_MULT;
  if (localPlayer.team === "runner"){
    const nearby = allPlayers.filter(p => p._id !== localPlayer._id && p.team === "runner" && Math.hypot(p.x-localPlayer.x,p.y-localPlayer.y) <= COOP_BOOST_DIST);
    if (nearby.length >= 1) sp *= COOP_SPEED_MULT;
  }

  let dx=0, dy=0;
  if (pressed.has("a") || pressed.has("arrowleft")) dx -= 1;
  if (pressed.has("d") || pressed.has("arrowright")) dx += 1;
  if (pressed.has("w") || pressed.has("arrowup")) dy -= 1;
  if (pressed.has("s") || pressed.has("arrowdown")) dy += 1;
  if (dx===0 && dy===0){
    // if carrying, ensure strawberry follows (throttled)
    if (localPlayer.carryingStraw){
      try { await updateDoc(doc(db, STRAWBERRIES_COL, localPlayer.carryingStraw), { x: localPlayer.x, y: localPlayer.y, ownerId: sessionId }); } catch(e){}
    }
    return;
  }
  const mag = Math.hypot(dx,dy) || 1;
  dx = dx/mag * sp; dy = dy/mag * sp;
  const desiredX = clamp(localPlayer.x + dx, 0, MAP_SIZE);
  const desiredY = clamp(localPlayer.y + dy, 0, MAP_SIZE);
  const resolved = resolveMovement(localPlayer.x, localPlayer.y, desiredX, desiredY);
  // apply
  localPlayer.x = resolved.x; localPlayer.y = resolved.y;
  await sendPositionIfNeeded(resolved.x, resolved.y);
  // if carrying, update strawberry pos and check delivery placement and auto-drop if oni near
  if (localPlayer.carryingStraw){
    try { await updateDoc(doc(db, STRAWBERRIES_COL, localPlayer.carryingStraw), { x: resolved.x, y: resolved.y, ownerId: sessionId }); } catch(e){}
    const straw = strawberries.find(s=>s._id===localPlayer.carryingStraw);
    if (straw) await checkPlacedOnDelivery(straw);
    // auto-drop when any oni is close
    const onis = allPlayers.filter(p=>p.team==="oni");
    for (const o of onis){
      const d = Math.hypot(o.x - localPlayer.x, o.y - localPlayer.y);
      if (d <= CAPTURE_RADIUS * 1.2){
        await releaseCarryByIdLocal(localPlayer.carryingStraw);
        log("è¿‘ãã«é¬¼ãŒæ¥ãŸãŸã‚ã‚¤ãƒã‚´ã‚’å¼·åˆ¶è¨­ç½®ã—ã¾ã—ãŸ", "event");
        break;
      }
    }
  } else {
    // if not carrying and shift down, try pickup force (redundant)
    if (pressed.has("shift")) await pickupNearestStrawbyForceLocal();
  }
  await tryDeliver(localPlayer);
  for (const s of strawberries) attemptCollectStraw(s);
  await checkCapturesAndHandle();
}, 100);

/* Footstep sound: runners hear if oni within VISIBILITY_RADIUS * FOOTSTEP_RANGE_MULT */
setInterval(()=>{
  if (!localPlayer) return;
  if (localPlayer.team === "runner"){
    const onis = allPlayers.filter(p=>p.team==="oni");
    for(const o of onis){
      const d = Math.hypot(o.x - localPlayer.x, o.y - localPlayer.y);
      if (d <= VISIBILITY_RADIUS * FOOTSTEP_RANGE_MULT){
        asiotoAudio.currentTime = 0; asiotoAudio.play().catch(()=>{});
        break;
      }
    }
  }
}, 900);

/* ========== Delivery & Capture logic (same as before but safe) ========== */
async function tryDeliver(player){
  if (!player || player.team !== "runner") return;
  for (const d of deliveries){
    const dist = Math.hypot(player.x - d.x, player.y - d.y);
    if (dist <= PICKUP_RADIUS){
      // if player's carryingStraw, and that straw placed by checkPlacedOnDelivery will mark delivery. But implement fallback:
      if (player.carryingStraw){
        // place carried to this delivery
        try {
          await runTransaction(db, async (t) => {
            const dRef = doc(db, DELIVERIES_COL, d._id);
            const dSnap = await t.get(dRef);
            if (!dSnap.exists()) return;
            if (dSnap.data().occupied) return;
            t.update(dRef, { occupied: true, strawberryId: player.carryingStraw });
            t.update(doc(db, STRAWBERRIES_COL, player.carryingStraw), { ownerId: null, available: false, placedAtDelivery: d._id });
            t.update(doc(db, PLAYERS_COL, player._id), { carryingStraw: null, lastAction: serverTimestamp() });
            const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
            const gSnap = await t.get(gRef);
            if (gSnap.exists()){
              const g = gSnap.data();
              const remaining = Math.max(0, (g.runnerRemaining || 4)-1);
              t.update(gRef, { runnerRemaining: remaining });
            }
          });
          log(`${player.name} ãŒç´å“æ‰€ã«ã‚¤ãƒã‚´ã‚’è¨­ç½®ã—ã¾ã—ãŸ`, "event");
        } catch(e){}
      } else {
        // deliver by possession method (possession based)
        const amount = player.possession || 0;
        if (amount <= 0) return;
        try {
          await runTransaction(db, async (t) => {
            const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
            const gSnap = await t.get(gRef);
            if (!gSnap.exists()) throw new Error("game missing");
            const g = gSnap.data();
            const scores = g.scores || { oni:0, runner:0 };
            scores.runner = (scores.runner || 0) + amount;
            t.update(gRef, { scores, lastUpdated: serverTimestamp() });
            t.update(doc(db, PLAYERS_COL, player._id), { possession: 0, lastAction: serverTimestamp() });
          });
          log(`${player.name} ãŒç´å“ï¼ +${amount}`, "event");
          const gSnap2 = await getDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID));
          if (gSnap2.exists()){
            const g2 = gSnap2.data();
            if ((g2.scores?.runner || 0) >= WIN_SCORE){
              log("é€ƒã’ãƒãƒ¼ãƒ ãŒå‹åˆ©ï¼ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†ã—ã¾ã™", "event");
              await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { ...g2, state: "ended" });
              await finalizeAndResetRound();
            }
          }
        } catch(e){}
      }
      return;
    }
  }
}

/* capture: when oni catches runner (same as before) */
async function checkCapturesAndHandle(){
  const onis = allPlayers.filter(p => p.team === "oni");
  const runners = allPlayers.filter(p => p.team === "runner");
  if (!onis.length || !runners.length) return;
  for (const r of runners){
    for (const o of onis){
      const d = Math.hypot(r.x - o.x, r.y - o.y);
      if (d <= CAPTURE_RADIUS){
        try {
          await updateDoc(doc(db, PLAYERS_COL, r._id), { possession:0, x: randPos().x, y: randPos().y, lastAction: serverTimestamp(), carryingStraw: null });
          await runTransaction(db, async (t) => {
            const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
            const s = await t.get(gRef);
            if (!s.exists()) return;
            const g = s.data();
            const scores = g.scores || { oni:0, runner:0 };
            scores.oni = (scores.oni || 0) + 5;
            t.update(gRef, { scores, lastUpdated: serverTimestamp() });
          });
          log(`${r.name} ãŒæ•ã¾ã£ãŸï¼ é¬¼ãƒãƒ¼ãƒ  +5`, "event");
          explosionAudio.currentTime = 0; explosionAudio.play().catch(()=>{});
          // check win
          const gSnap2 = await getDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID));
          if (gSnap2.exists()){
            const g2 = gSnap2.data();
            if ((g2.scores?.oni || 0) >= WIN_SCORE){
              log("é¬¼ãƒãƒ¼ãƒ ãŒå‹åˆ©ï¼ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†ã—ã¾ã™", "event");
              await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { ...g2, state: "ended" });
              await finalizeAndResetRound();
            }
          }
        } catch(e){ console.error(e); }
        break;
      }
    }
  }
}

/* ========== Utility: randomPassablePos, findNearestFreePos ========== */
function pointInsideWall(x,y){
  for (const rect of wallsRectangles){
    if (x >= rect.x && x <= rect.x+rect.w && y >= rect.y && y <= rect.y+rect.h) return true;
  }
  return false;
}
function randomPassablePos(){
  for (let i=0;i<300;i++){
    const c = Math.floor(Math.random()*MAZE_COLS), r = Math.floor(Math.random()*MAZE_ROWS);
    const rectX = c*CELL_SIZE, rectY = r*CELL_SIZE;
    const isWall = wallsRectangles.some(wr => wr.x === rectX && wr.y === rectY);
    if (!isWall){
      const margin = Math.max(PLAYER_RADIUS+4,8);
      const px = clamp(rectX + margin + Math.random()*(CELL_SIZE - margin*2), rectX+margin, rectX+CELL_SIZE-margin);
      const py = clamp(rectY + margin + Math.random()*(CELL_SIZE - margin*2), rectY+margin, rectY+CELL_SIZE-margin);
      if (!pointInsideWall(px,py)) return {x:px,y:py};
    }
  }
  // fallback spiral search
  return findNearestFreePos(MAP_SIZE/2, MAP_SIZE/2);
}
function findNearestFreePos(x,y){
  const c0 = clamp(Math.floor(x / CELL_SIZE), 0, MAZE_COLS-1);
  const r0 = clamp(Math.floor(y / CELL_SIZE), 0, MAZE_ROWS-1);
  const visited = Array.from({length:MAZE_ROWS},()=>Array(MAZE_COLS).fill(false));
  const q = [{r:r0,c:c0}]; visited[r0][c0]=true;
  while(q.length){
    const cur = q.shift();
    const cx = cur.c*CELL_SIZE + CELL_SIZE/2;
    const cy = cur.r*CELL_SIZE + CELL_SIZE/2;
    const overlapping = wallsRectangles.some(rect => circleRectOverlap(cx,cy,PLAYER_RADIUS+2,rect));
    if (!overlapping) return {x:cx,y:cy};
    const neighbors = [{dr:1,dc:0},{dr:-1,dc:0},{dr:0,dc:1},{dr:0,dc:-1}];
    for (const n of neighbors){
      const nr = cur.r + n.dr, nc = cur.c + n.dc;
      if (nr>=0 && nr<MAZE_ROWS && nc>=0 && nc<MAZE_COLS && !visited[nr][nc]){
        visited[nr][nc]=true; q.push({r:nr,c:nc});
      }
    }
  }
  // fallback random
  for (let i=0;i<200;i++){
    const px = Math.random()*MAP_SIZE, py = Math.random()*MAP_SIZE;
    if (!pointInsideWall(px,py)) return {x:px,y:py};
  }
  return {x:MAP_SIZE/2,y:MAP_SIZE/2};
}

/* ========== draw & render functions ========== */
function drawTextBubble(ctx, text, x, y, bg="#000", small=false){
  ctx.save(); ctx.font = (small ? "12px sans-serif":"13px sans-serif"); const metrics = ctx.measureText(text); const padX=8; const w=metrics.width+padX*2; const h=18; const bx=x-w/2, by=y-h/2;
  ctx.fillStyle = bg; const r=8; ctx.beginPath(); ctx.moveTo(bx+r,by); ctx.arcTo(bx+w,by,bx+w,by+h,r); ctx.arcTo(bx+w,by+h,bx,by+h,r); ctx.arcTo(bx,by+h,bx,by,r); ctx.arcTo(bx,by,bx+w,by,r); ctx.closePath(); ctx.fill();
  ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(text, x, y); ctx.restore();
}

function drawWorld(ctx, width, height, centerPlayer, applyVisibility){
  ctx.clearRect(0,0,width,height);
  let targetX = centerPlayer ? centerPlayer.x : MAP_SIZE/2;
  let targetY = centerPlayer ? centerPlayer.y : MAP_SIZE/2;
  const halfW = width/2, halfH = height/2;
  targetX = clamp(targetX, halfW, MAP_SIZE - halfW);
  targetY = clamp(targetY, halfH, MAP_SIZE - halfH);
  camera.x += (targetX - camera.x) * camera.lerp;
  camera.y += (targetY - camera.y) * camera.lerp;
  const toScreenX = mx => mx - (camera.x - halfW);
  const toScreenY = my => my - (camera.y - halfH);

  // map
  if (mapImageLoaded){ const scaleX = width / MAP_SIZE, scaleY = height / MAP_SIZE; ctx.drawImage(mapImage, (-(camera.x-halfW))*scaleX, (-(camera.y-halfH))*scaleY, MAP_SIZE*scaleX, MAP_SIZE*scaleY); }
  else { ctx.fillStyle="#081018"; ctx.fillRect(0,0,width,height); }

  // walls (draw rectangles)
  ctx.fillStyle = "#222";
  for (const rect of wallsRectangles){
    const sx = toScreenX(rect.x), sy = toScreenY(rect.y);
    const sw = rect.w, sh = rect.h;
    ctx.fillRect(sx, sy, sw, sh);
  }

  // deliveries
  for (const d of deliveries){
    const sx = toScreenX(d.x), sy = toScreenY(d.y);
    const label = d.occupied ? "â–³ (è¨­ç½®æ¸ˆ)" : "â–³ ç´å“æ‰€";
    const color = d.occupied ? "#8be08b" : "#ffd39a";
    drawTextBubble(ctx, label, sx, sy - 26, color);
    // sprite if available
  }

  // strawberries
  for (const s of strawberries){
    const sx = toScreenX(s.x), sy = toScreenY(s.y);
    let visible = true;
    if (applyVisibility && centerPlayer && centerPlayer.team === "runner") visible = Math.hypot(centerPlayer.x - s.x, centerPlayer.y - s.y) <= VISIBILITY_RADIUS;
    if (!visible) continue;
    drawTextBubble(ctx, "ãƒ» ã‚¤ãƒã‚´", sx, sy - 26, "#ff6b8a");
    ctx.fillStyle = s.available ? "#ff6b8a" : "#5a2a2f";
    ctx.beginPath(); ctx.arc(sx, sy, 8, 0, Math.PI*2); ctx.fill();
    const runnersNear = allPlayers.filter(p => p.team === "runner" && Math.hypot(p.x - s.x, p.y - s.y) <= PICKUP_RADIUS);
    if (runnersNear.length === 1){ ctx.strokeStyle="rgba(255,255,128,0.9)"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(sx,sy,12,0,Math.PI*2); ctx.stroke(); ctx.lineWidth=1; }
  }

  // players
  for (const p of allPlayers){
    let visible = true;
    if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
      visible = (p._id === centerPlayer._id) || (Math.hypot(centerPlayer.x - p.x, centerPlayer.y - p.y) <= VISIBILITY_RADIUS);
    }
    if (!visible) continue;
    const sx = toScreenX(p.x), sy = toScreenY(p.y);
    if (p.team === "runner"){ ctx.fillStyle="#4db8ff"; ctx.beginPath(); ctx.arc(sx,sy,12,0,Math.PI*2); ctx.fill(); }
    else { ctx.fillStyle="#ffcf4d"; ctx.fillRect(sx-12,sy-12,24,24); }
    if (localPlayer && p._id === localPlayer._id){ ctx.strokeStyle="#fff"; ctx.lineWidth=2; if (p.team==="runner"){ctx.beginPath();ctx.arc(sx,sy,15,0,Math.PI*2);ctx.stroke();}else ctx.strokeRect(sx-14,sy-14,28,28); ctx.lineWidth=1; }
    if (p.team==="runner" && p.carryingStraw) drawTextBubble(ctx, "é‹æ¬ä¸­", sx, sy - 36, "#2b6b2b");
    drawTextBubble(ctx, p.name, sx, sy + 20, "#000", true);
  }

  // darkness for runner
  if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
    ctx.save(); ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.beginPath(); ctx.rect(0,0,width,height); ctx.arc(width/2, height/2, VISIBILITY_RADIUS,0,Math.PI*2,true); try{ ctx.fill('evenodd'); }catch(e){ ctx.globalCompositeOperation='destination-out'; ctx.fill(); ctx.globalCompositeOperation='source-over'; } ctx.restore();
  }
}

/* minimap sync */
function drawMiniMap(){
  miniCtx.clearRect(0,0,miniMap.width,miniMap.height);
  const w = miniMap.width, h = miniMap.height;
  miniCtx.fillStyle="#041218"; miniCtx.fillRect(0,0,w,h);
  if (mapImageLoaded) miniCtx.drawImage(mapImage,0,0,w,h);
  for (const rect of wallsRectangles){ const sx=rect.x/MAP_SIZE*w, sy=rect.y/MAP_SIZE*h, sw=rect.w/MAP_SIZE*w, sh=rect.h/MAP_SIZE*h; miniCtx.fillStyle="#222"; miniCtx.fillRect(sx,sy,sw,sh); }
  for (const d of deliveries){ const sx = d.x/MAP_SIZE*w, sy = d.y/MAP_SIZE*h; miniCtx.fillStyle = d.occupied ? "#8be08b" : "#ffd39a"; miniCtx.beginPath(); miniCtx.moveTo(sx,sy-6); miniCtx.lineTo(sx-6,sy+6); miniCtx.lineTo(sx+6,sy+6); miniCtx.closePath(); miniCtx.fill(); }
  for (const s of strawberries){ const sx=s.x/MAP_SIZE*w, sy=s.y/MAP_SIZE*h; miniCtx.fillStyle = s.available ? "#ff6b8a" : "#5a2a2f"; miniCtx.beginPath(); miniCtx.arc(sx,sy,3,0,Math.PI*2); miniCtx.fill(); }
  for (const p of allPlayers){ const sx=p.x/MAP_SIZE*w, sy=p.y/MAP_SIZE*h; miniCtx.fillStyle = p.team==="oni"? "#ffcf4d":"#4db8ff"; miniCtx.beginPath(); miniCtx.arc(sx,sy,3,0,Math.PI*2); miniCtx.fill(); }
  miniCtx.strokeStyle="rgba(255,255,255,0.06)"; miniCtx.strokeRect(0,0,w,h);
}

/* render loop */
function renderLoop(){ requestAnimationFrame(renderLoop); drawWorld(gctx, gameCanvas.width, gameCanvas.height, localPlayer, true); drawMiniMap(); updateDashStatusUI(); updateBoostUI(); }
renderLoop();

/* ========== UI / Hooks ========== */
toTeamBtn.addEventListener('click', ()=> showScreen("team"));
chooseOni.addEventListener('click', ()=>{ joinedTeamChoice="oni"; showScreen("join"); });
chooseRunner.addEventListener('click', ()=>{ joinedTeamChoice="runner"; showScreen("join"); });
backFromTeam.addEventListener('click', ()=> showScreen("waiting"));
backFromJoin.addEventListener('click', ()=> showScreen("team"));

joinNow.addEventListener('click', async ()=>{
  const name = (inputName.value||"").trim();
  if (!name){ alert("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; }
  if (!joinedTeamChoice){ alert("ãƒãƒ¼ãƒ ã‚’é¸ã‚“ã§ãã ã•ã„"); return; }
  await joinAs(name, joinedTeamChoice);
  joinedTeamChoice = null; inputName.value = "";
});

leaveBtn.addEventListener('click', ()=> leave());

adminSmall.addEventListener('click', async ()=>{
  const pass = prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:");
  if (pass === ADMIN_PASS){ adminMode = true; adminResetBtn.classList.remove("hidden"); alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹"); renderPlayerList(); } else alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¸æ­£");
});
adminResetBtn.addEventListener('click', async ()=>{
  if (!adminMode) return alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™");
  if (!confirm("å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) return;
  await finalizeAndResetRound();
});
homeResetBtn.addEventListener('click', async ()=>{
  const pass = prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰:"); if (pass === ADMIN_PASS) await finalizeAndResetRound(); else alert("é•ã„ã¾ã™");
});

/* ========== Player list & UI helpers ========== */
function renderPlayerList(){
  playerListEl.innerHTML = "";
  const sorted = allPlayers.slice().sort((a,b)=> a.team.localeCompare(b.team) || (a.name||"").localeCompare(b.name));
  for (const p of sorted){
    const row = document.createElement("div"); row.className="playerRow";
    const left = document.createElement("div"); left.style.display="flex"; left.style.gap="8px"; left.style.alignItems="center";
    const shape = document.createElement("div"); shape.style.width="14px"; shape.style.height="14px"; shape.style.borderRadius = p.team==="runner" ? "50%":"3px";
    shape.style.background = p.team==="runner" ? "#4db8ff":"#ffd54d"; left.appendChild(shape);
    const info = document.createElement("div"); info.innerHTML = `<div style="font-weight:700">${p.name}</div><div class="small">${p.team}</div>`; left.appendChild(info);
    row.appendChild(left);
    const right = document.createElement("div"); right.style.textAlign="right";
    const coords = adminMode ? `<div class="small">${Math.round(p.x)},${Math.round(p.y)}</div>` : "";
    const carryText = p.carryingStraw ? `<div style="font-weight:700">é‹æ¬ä¸­</div>` : "";
    right.innerHTML = `${carryText}${coords}`;
    if (adminMode){
      const kick = document.createElement("button"); kick.textContent="é€€å‡º"; kick.style.background="#ff6b6b"; kick.style.border="none"; kick.style.padding="6px"; kick.style.borderRadius="6px";
      kick.onclick = async ()=>{ if (!confirm(`${p.name} ã‚’å¼·åˆ¶é€€å‡ºã—ã¾ã™ã‹ï¼Ÿ`)) return; try { await deleteDoc(doc(db, PLAYERS_COL, p._id)); log(`${p.name} ã‚’ç®¡ç†è€…ãŒé€€å‡ºã•ã›ã¾ã—ãŸ`, "event"); } catch(e){ alert("é€€å‡ºå¤±æ•—"); } };
      right.appendChild(kick);
    }
    row.appendChild(right);
    playerListEl.appendChild(row);
  }
}

/* dash status & boost UI */
function updateDashStatusUI(){
  if (!localPlayer){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: -"; return; }
  if (localPlayer.team !== "oni"){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: (é¬¼ã®ã¿)"; return; }
  const readyAt = localPlayer.dashReadyAt || 0; const now = Date.now();
  if (now >= readyAt) dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨å¯èƒ½"; else dashStatusEl.textContent = `ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨ä¸å¯ æ®‹ã‚Š ${Math.ceil((readyAt-now)/1000)}s`;
}
function updateBoostUI(){ if (!localPlayer){ boostStatusEl.textContent = ""; return; } if (localPlayer.team === "runner"){ const nearby = allPlayers.filter(p => p._id !== localPlayer._id && p.team === "runner" && Math.hypot(p.x-localPlayer.x,p.y-localPlayer.y)<=COOP_BOOST_DIST); if (nearby.length>=1){ boostStatusEl.textContent="ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ–ãƒ¼ã‚¹ãƒˆä¸­ï¼ˆè¿‘ãã«ä»²é–“ï¼‰"; boostStatusEl.style.background="linear-gradient(90deg,#7fffd4,#2ee6b6)"; } else { boostStatusEl.textContent=""; boostStatusEl.style.background="linear-gradient(180deg,#06281f,#0b3940)"; } } else boostStatusEl.textContent=""; }

/* ========== Bootstrap: create maze meta and seed objects, then setup listeners ========== */
(async function bootstrap(){
  try {
    await ensureGame();
    // create maze meta if missing and ensure objects
    await createAndStoreMazeIfNeeded();
    await seedMapOnce();
    setupListeners();
    showScreen("waiting");
    updateStatus("å¾…æ©Ÿä¸­");
  } catch(e){
    console.error("bootstrap err", e);
    updateStatus("åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼"); log("åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: " + (e.message||e), "error");
  }
})();

/* ========== Helper: isColliding = circleRectOverlap = defined above inline for reuse ========== */
function circleRectOverlap(cx,cy,r,rect){
  const rx = Math.max(rect.x, Math.min(cx, rect.x+rect.w));
  const ry = Math.max(rect.y, Math.min(cy, rect.y+rect.h));
  const dx = cx - rx, dy = cy - ry;
  return (dx*dx + dy*dy) <= (r*r);
}

/* ========== Periodic housekeeping: ensure objects not inside walls; win-check ========== */
setInterval(async ()=>{
  try {
    // ensure strawberries/deliveries not overlapping walls
    for (const s of strawberries){
      if (pointInsideWall(s.x,s.y)){
        const safe = findNearestFreePos(s.x,s.y);
        try { await updateDoc(doc(db, STRAWBERRIES_COL, s._id), { x: safe.x, y: safe.y, ownerId: null, available: true, placedAtDelivery: null }); } catch(e){}
      }
    }
    for (const d of deliveries){
      if (pointInsideWall(d.x,d.y)){
        const safe = findNearestFreePos(d.x,d.y);
        try { await updateDoc(doc(db, DELIVERIES_COL, d._id), { x: safe.x, y: safe.y, occupied: false, strawberryId: null }); } catch(e){}
      }
    }
    // win-check by scores
    const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
    const gSnap = await getDoc(gRef);
    if (!gSnap.exists()) return;
    const g = gSnap.data();
    const scores = g.scores || { oni:0, runner:0 };
    if (g.state === "playing" && (scores.oni >= WIN_SCORE || scores.runner >= WIN_SCORE)){
      log("ã‚¹ã‚³ã‚¢åˆ°é”ã«ã‚ˆã‚Šãƒ©ã‚¦ãƒ³ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™", "event");
      await setDoc(gRef, { ...g, state: "ended" });
      await finalizeAndResetRound();
    }
  } catch(e){ console.error("housekeeping err", e); }
}, 4000);

/* ========== Notes =====================================================
- This file aims to be robust: many operations are guarded with try/catch and
  transaction fallbacks. Maze generation and object seeding ensure items and
  players are never placed inside walls.
- SHIFT pickup uses a transaction-first approach and a forced fallback so that
  pressing SHIFT near a strawberry will pick it up in virtually all conditions.
- Movement resolves collisions by attempting slides and shrinking steps to
  avoid getting stuck inside walls.
- BGM (bgm.mp3) plays on join; browser autoplay policies typically permit
  playback after user interaction (join button).
- Tune constants at the top: FOOTSTEP_RANGE_MULT, DASH_MULT, GLOBAL_SPEED_MULT,
  MAZE_COLS/ROWS (and CELL_SIZE derived) to change difficulty and scale.
- Security: Firestore rules are not included â€” set proper rules before public use.
======================================================================= */

</script>
</body>
</html>
