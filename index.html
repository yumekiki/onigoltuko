<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ å®Œå…¨ç‰ˆï¼ˆFirestore v12.7.0ï¼‰</title>
<style>
  :root{
    --bg:#0d0f12; --panel:#0f1720; --accent:#ff6b6b; --oni:#ffcf4d; --runner:#4db8ff;
    --muted:#9aa3ad;
  }
  *{box-sizing:border-box}
  body{ margin:0; font-family:system-ui, "Hiragino Kaku Gothic ProN", "ãƒ¡ã‚¤ãƒªã‚ª", sans-serif; background:var(--bg); color:#e6eef6; }
  #app{ display:flex; height:100vh; gap:12px; padding:12px; }
  #left{ flex:1; display:flex; flex-direction:column; gap:12px; align-items:center; }
  #right{ width:380px; background:linear-gradient(180deg,#0b0d10 0%, #0f1113 100%); box-shadow:-6px 0 18px rgba(0,0,0,.6); padding:14px; display:flex; flex-direction:column; gap:12px; border-radius:10px; }
  canvas{ border-radius:8px; background:#081018; display:block; }
  .panel{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px; border-radius:8px; width:100%; box-sizing:border-box; }
  .center{ text-align:center; }
  button{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:inherit; padding:8px 12px; border-radius:8px; cursor:pointer; }
  .big{ font-size:1.05rem; padding:12px 16px; }
  .teamBtn{ display:flex; justify-content:space-between; align-items:center; gap:12px; padding:14px; border-radius:10px; }
  .oniBtn{ background:linear-gradient(90deg,#ffecb3,#ffd54d); color:#111; }
  .runnerBtn{ background:linear-gradient(90deg,#bfe8ff,#4db8ff); color:#022033; }
  .small{ font-size:0.85rem; color:var(--muted); }
  .logItem{ margin-bottom:6px; font-size:0.95rem; padding:6px 8px; border-radius:8px; }
  .log-info{ background: rgba(255,255,255,0.02); color:#dbe9ff; }
  .log-event{ background: rgba(170,220,255,0.06); color:#cfeeff; }
  .log-error{ background: rgba(255,100,100,0.06); color:#ffd3d3; }
  .playerRow{ display:flex; justify-content:space-between; align-items:center; padding:8px; border-radius:6px; background:rgba(255,255,255,0.02); }
  .kickBtn{ padding:6px 8px; border-radius:6px; background:#ff6b6b; border:none; color:#111; cursor:pointer; }
  #loadingOverlay { position:fixed; inset:0; background:rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:9999; color:#fff; font-size:1.1rem; display:none; border-radius:6px; }
  #boostStatus { margin-top:8px; font-weight:700; color:#bfffbf; text-align:center; min-height:22px; }
  #dashStatus { font-weight:700; color:#ffd; margin-left:10px; }
</style>
</head>
<body>
<div id="loadingOverlay">å‡¦ç†ä¸­... å°‘ã—ãŠå¾…ã¡ãã ã•ã„</div>

<div id="app">
  <div id="left">
    <div id="screen-waiting" class="panel">
      <div class="center">
        <h2>å¾…æ©Ÿ / ãƒ«ãƒ¼ãƒ«</h2>
        <p class="small">å‚åŠ ã™ã‚‹ã‚’æŠ¼ã™ã¨ãƒãƒ¼ãƒ é¸æŠã¸ã€‚ç®¡ç†ã¯å³ä¸Šã€Œç®¡ç†ã€ã‹ã‚‰å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆå¯èƒ½ã€‚</p>
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:center;">
          <button id="toTeamBtn" class="big">å‚åŠ ã™ã‚‹</button>
          <button id="homeResetBtn" class="big">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
      </div>
      <div style="margin-top:12px;">
        <div style="white-space:pre-wrap; color:#dfe9f4; font-size:0.95rem">
1ãƒ©ã‚¦ãƒ³ãƒ‰åˆ¶ãƒ»é€”ä¸­å‚åŠ å¯ãƒ»ã‚¢ã‚«ã‚¦ãƒ³ãƒˆä¸è¦ã€‚
é¬¼ (â–¢) ã¯ãƒãƒƒãƒ—å…¨ä½“å¯è¦–ã€ãƒ€ãƒƒã‚·ãƒ¥ï¼ˆ3ç§’ã€CT 10ç§’ï¼‰ã€‚
é€ƒã’ (ã€‡) ã¯è‡ªåˆ†ä¸­å¿ƒã®è¦–ç•Œã€‚ã‚¤ãƒã‚´(ãƒ»)ã¯2äººæƒã†ã¨å›åã€å„äºº +1ã€‚
ç´å“æ‰€(â–³) ã«è¿‘ã¥ãã¨è‡ªåˆ†ã®æ‰€æŒã‚¤ãƒã‚´ãŒãƒãƒ¼ãƒ ã‚¹ã‚³ã‚¢ã«å¤‰æ›ã•ã‚Œ 0 ã«ãªã‚Šã¾ã™ã€‚
é¬¼ãŒæ•ã¾ãˆã‚‹ã¨é¬¼ãƒãƒ¼ãƒ  +5 ç‚¹ã€‚å…ˆã« 50 ç‚¹ã§å‹åˆ©ã—ã€å³ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚
        </div>
      </div>
      <div style="margin-top:8px;" class="small center">ãƒãƒ¼ãƒ äººæ•° â€” é¬¼: <span id="waitOniCount">0</span> / é€ƒã’: <span id="waitRunnerCount">0</span></div>
    </div>

    <div id="screen-team" class="panel hidden">
      <h2 class="center">ãƒãƒ¼ãƒ ã‚’é¸ã‚“ã§ãã ã•ã„</h2>
      <div style="display:flex; gap:12px; margin-top:12px;">
        <div style="flex:1;">
          <button id="chooseOni" class="teamBtn oniBtn">
            <div>
              <div style="font-weight:700;">ğŸ‘¹ é¬¼ãƒãƒ¼ãƒ </div>
              <div class="small" id="oniCount">äººæ•°: 0</div>
            </div>
            <div style="display:flex; gap:8px; align-items:center;">
              <div class="small">ã‚¹ã‚³ã‚¢</div><div id="oniScore">0</div>
            </div>
          </button>
        </div>
        <div style="flex:1;">
          <button id="chooseRunner" class="teamBtn runnerBtn">
            <div>
              <div style="font-weight:700;">ğŸƒ é€ƒã’ãƒãƒ¼ãƒ </div>
              <div class="small" id="runnerCount">äººæ•°: 0</div>
            </div>
            <div style="display:flex; gap:8px; align-items:center;">
              <div class="small">ã‚¹ã‚³ã‚¢</div><div id="runnerScore">0</div>
            </div>
          </button>
        </div>
      </div>
      <div style="margin-top:10px;" class="muted center">æŠ¼ã™ã¨ãƒãƒ¼ãƒ é¸æŠç”»é¢ã¸ï¼ˆã¾ã å‚åŠ ã¯ã—ã¾ã›ã‚“ï¼‰</div>
      <div style="margin-top:12px;" class="center">
        <button id="backFromTeam">æˆ»ã‚‹</button>
      </div>
    </div>

    <div id="screen-join" class="panel hidden">
      <h2 class="center">åå‰ã‚’å…¥åŠ›ã—ã¦å‚åŠ </h2>
      <div style="display:flex; gap:8px; align-items:center; justify-content:center; margin-top:8px;">
        <input id="inputName" class="nameInput" placeholder="åå‰ã‚’å…¥åŠ›" maxlength="16" />
        <button id="joinNow">å‚åŠ </button>
      </div>
      <div style="margin-top:8px;" class="center muted">
        <button id="backFromJoin">æˆ»ã‚‹</button>
      </div>
    </div>

    <div id="screen-game" class="panel hidden" style="width:100%;">
      <div style="display:flex; align-items:center;">
        <div style="display:flex; gap:8px; align-items:center;">
          <div style="background:linear-gradient(90deg,#ffefd5,#fff1cc); padding:6px 10px; border-radius:8px; color:#1a1200; font-weight:700;">ğŸ‘¹ é¬¼: <span id="topOni">0</span></div>
          <div style="background:linear-gradient(90deg,#dff4ff,#d6f0ff); padding:6px 10px; border-radius:8px; color:#022033; font-weight:700;">ğŸƒ é€ƒã’: <span id="topRunner">0</span></div>
        </div>
        <div style="margin-left:auto; display:flex; align-items:center; gap:12px;">
          <div id="dashStatus">ãƒ€ãƒƒã‚·ãƒ¥: -</div>
          <button id="leaveBtn">é›¢è„±</button>
        </div>
      </div>

      <div style="margin-top:12px; width:100%;">
        <canvas id="gameCanvas" width="1200" height="640"></canvas>
        <div id="boostStatus" class="panel" style="margin-top:8px; background:linear-gradient(90deg,#06281f,#0b3940);"></div>
      </div>
    </div>
  </div>

  <div id="right">
    <div class="panel">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <div id="playerInfoName" style="font-weight:700;">æœªå‚åŠ </div>
          <div class="small" id="playerInfoTeam">ãƒãƒ¼ãƒ : -</div>
        </div>
        <div>
          <div class="small">æ”¾ç½®: <span id="idleCount">0</span>s</div>
        </div>
      </div>
    </div>

    <div class="panel" style="display:flex; flex-direction:column; gap:8px; height:40vh;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:700;">ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</div>
        <div class="small">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ </div>
      </div>
      <div id="playerList"></div>
      <div style="margin-top:6px; display:flex; justify-content:space-between; align-items:center;">
        <div class="small">ï¼ˆç®¡ç†è€…ã¯åº§æ¨™ãƒ»é€€å‡ºãƒœã‚¿ãƒ³ã‚’æ“ä½œå¯ï¼‰</div>
      </div>
    </div>

    <div class="panel" style="display:flex; flex-direction:column; gap:8px;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:700;">ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°</div>
        <div class="small">é‡è¦ãªå‡ºæ¥äº‹ã‚’è¡¨ç¤ºï¼ˆè‡ªå‹•æ¶ˆå»: 10sï¼‰</div>
      </div>
      <div id="log" class="muted"></div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="adminReset" class="hidden">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button>
        <div class="small" id="statusSmall">çŠ¶æ…‹: åˆæœŸ</div>
      </div>
      <div style="margin-top:8px;">
        <canvas id="miniMap" class="minimap"></canvas>
        <div class="small" style="color:#9aa3ad">map.png ã‚’ç½®ãã¨ãƒãƒƒãƒ—èƒŒæ™¯ã«åæ˜ ã•ã‚Œã¾ã™ã€‚</div>
      </div>
    </div>

  </div>
</div>

<!-- audio -->
<audio id="asioto" src="asioto.mp3" preload="auto"></audio>
<audio id="explosion" src="explosion.mp3" preload="auto"></audio>

<script type="module">
/* å®Œå…¨ç‰ˆ 1ãƒ•ã‚¡ã‚¤ãƒ« â€” ä¿®æ­£/è¿½åŠ ç‚¹ã‚’åæ˜ æ¸ˆã¿ */

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js";
import {
  getFirestore, collection, doc, setDoc, addDoc, updateDoc, deleteDoc, getDoc,
  onSnapshot, getDocs, runTransaction, writeBatch, serverTimestamp, Timestamp
} from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

/* Firebase config (ãƒ¦ãƒ¼ã‚¶ãƒ¼æä¾›ã®ã‚‚ã®) */
const firebaseConfig = {
  apiKey: "AIzaSyBmgtx4FW_3_0zy1MvAvZLPHmE_CE1txuE",
  authDomain: "zzke-ki1.firebaseapp.com",
  databaseURL: "https://zzke-ki1-default-rtdb.firebaseio.com",
  projectId: "zzke-ki1",
  storageBucket: "zzke-ki1.firebasestorage.app",
  messagingSenderId: "260981230516",
  appId: "1:260981230516:web:146a29f15b2716a9af80e1",
  measurementId: "G-GF5G1D4E10"
};

const app = initializeApp(firebaseConfig);
try { getAnalytics(app); } catch(e){ /* optional */ }
const db = getFirestore(app);

/* ====== è¨­å®šå€¤ï¼ˆã“ã“ã§èª¿æ•´ï¼‰ ====== */
const GAME_COLLECTION = "games";
const GAME_DOC_ID = "current_round";
const PLAYERS_COL = "players";
const STRAWBERRIES_COL = "strawberries";
const DELIVERIES_COL = "deliveries";

const MAP_SIZE = 2000;
const VISIBILITY_RADIUS = 200;
const PICKUP_RADIUS = 80;
const CAPTURE_RADIUS = 36;

const IDLE_TIMEOUT_SEC = 30; // è¡¨ç¤ºã®ã¿ï¼ˆè‡ªå‹•å‰Šé™¤ã¯åŸºæœ¬ã—ãªã„ï¼‰
const POSITION_THROTTLE_MS = 200;
const WIN_SCORE = 50;

/* ã‚°ãƒ­ãƒ¼ãƒãƒ«é€Ÿåº¦å€ç‡ï¼ˆè¦æ±‚: 1.8å€ï¼‰ */
const GLOBAL_SPEED_MULT = 1.8;
const BASE_RUNNER_SPEED = 2.6;
const BASE_ONI_SPEED = 2.4;
let RUNNER_SPEED = BASE_RUNNER_SPEED * GLOBAL_SPEED_MULT;
let ONI_SPEED = BASE_ONI_SPEED * GLOBAL_SPEED_MULT;

/* ãƒ€ãƒƒã‚·ãƒ¥: è¦æœ›ã§éå¸¸ã«å¼·ãï¼ˆæœ€çµ‚ï¼šã•ã‚‰ã«2å€ï¼‰ */
let DASH_MULT = 6.0; // æœ€çµ‚è¦æ±‚: ã•ã‚‰ã«äºŒå€ -> é«˜å€ç‡
const DASH_DUR_MS = 3000;
const DASH_CT_MS = 10000;

/* ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ–ãƒ¼ã‚¹ãƒˆï¼ˆæ··é›‘ï¼‰ */
const COOP_BOOST_DIST = 120;
const COOP_SPEED_MULT = 1.3;

/* è¶³éŸ³ã®è´ã“ãˆã‚‹ç¯„å›² (ã»ã©ã‚ˆãåºƒã’ã‚‹) */
const FOOTSTEP_RANGE_MULT = 2.0;

/* admin pass */
const ADMIN_PASS = "1122";

/* strawberry respawn immediate */
const STRAW_RESPAWN_IMMEDIATE = true;

/* ====== ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçŠ¶æ…‹ ====== */
let sessionId = null;
let localPlayer = null;
let allPlayers = [];
let strawberries = [];
let deliveries = [];
let gameDoc = null;
let lastPosSend = 0;
let joinedTeamChoice = null;
let adminMode = false;

/* canvas / UI refs */
const loadingOverlay = document.getElementById("loadingOverlay");
const gameCanvas = document.getElementById("gameCanvas");
const gctx = gameCanvas.getContext("2d");
const miniMap = document.getElementById("miniMap");
const miniCtx = miniMap.getContext("2d");

const toTeamBtn = document.getElementById("toTeamBtn");
const chooseOni = document.getElementById("chooseOni");
const chooseRunner = document.getElementById("chooseRunner");
const backFromTeam = document.getElementById("backFromTeam");
const backFromJoin = document.getElementById("backFromJoin");
const joinNow = document.getElementById("joinNow");
const inputName = document.getElementById("inputName");
const leaveBtn = document.getElementById("leaveBtn");
const playerInfoName = document.getElementById("playerInfoName");
const playerInfoTeam = document.getElementById("playerInfoTeam");
const topOni = document.getElementById("topOni");
const topRunner = document.getElementById("topRunner");
const oniCountEl = document.getElementById("oniCount");
const runnerCountEl = document.getElementById("runnerCount");
const oniScoreEl = document.getElementById("oniScore");
const runnerScoreEl = document.getElementById("runnerScore");
const logEl = document.getElementById("log");
const adminSmall = document.getElementById("adminSmall");
const adminResetBtn = document.getElementById("adminReset");
const statusSmall = document.getElementById("statusSmall");
const playerListEl = document.getElementById("playerList");
const homeResetBtn = document.getElementById("homeResetBtn");
const dashStatusEl = document.getElementById("dashStatus");
const boostStatusEl = document.getElementById("boostStatus");
const waitOniCount = document.getElementById("waitOniCount");
const waitRunnerCount = document.getElementById("waitRunnerCount");

/* audio */
const asiotoAudio = document.getElementById("asioto");
const explosionAudio = document.getElementById("explosion");

/* unsub handlers */
let unsubGame = null, unsubPlayers = null, unsubStraw = null, unsubDeliveries = null;

/* map image */
let mapImage = new Image();
let mapImageLoaded = false;
mapImage.src = "map.png";
mapImage.onload = () => { mapImageLoaded = true; };

/* ====== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ====== */
function showScreen(name){
  document.querySelectorAll('#screen-waiting,#screen-team,#screen-join,#screen-game').forEach(el => el.classList.add('hidden'));
  document.getElementById('screen-' + name).classList.remove('hidden');
}
function randPos(){ return { x: Math.floor(Math.random()*MAP_SIZE), y: Math.floor(Math.random()*MAP_SIZE) }; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function nowMillis(){ return Date.now(); }
function updateStatus(s){ statusSmall.textContent = "çŠ¶æ…‹: " + s; }
function showLoading(on){ loadingOverlay.style.display = on ? "flex" : "none"; }

/* ãƒ­ã‚°ï¼ˆè‡ªå‹•ã§10ç§’å¾Œã«æ¶ˆãˆã‚‹ï¼‰ */
function pushLog(text, type="info"){
  const el = document.createElement('div');
  el.className = 'logItem ' + (type === 'event' ? 'log-event' : (type === 'error' ? 'log-error' : 'log-info'));
  el.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
  logEl.prepend(el);
  setTimeout(()=>{ try{ el.remove(); }catch(e){} }, 10000); // 10ç§’ã§è‡ªå‹•å‰Šé™¤
}

/* ç”Ÿæˆæ¸ˆã¿ã‚»ãƒƒã‚·ãƒ§ãƒ³ID */
function genSessionId(){
  try { return 'p_' + (crypto.randomUUID ? crypto.randomUUID() : (Date.now() + '_' + Math.floor(Math.random()*1e6))); }
  catch(e){ return 'p_' + (Date.now() + '_' + Math.floor(Math.random()*1e6)); }
}

/* ====== Firestore: game doc & seed ====== */
async function ensureGame(){
  const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
  const snap = await getDoc(gRef);
  if (!snap.exists()){
    await setDoc(gRef, { state:"waiting", scores:{ oni:0, runner:0 }, mapSize:MAP_SIZE, createdAt: serverTimestamp() });
  }
}
async function seedMapOnce(){
  const dSnap = await getDocs(collection(db, DELIVERIES_COL));
  if (dSnap.size === 0){
    const pts = [
      { x: 80, y: 80 },
      { x: MAP_SIZE-80, y: 80 },
      { x: 80, y: MAP_SIZE-80 },
      { x: MAP_SIZE-80, y: MAP_SIZE-80 }
    ];
    for (const p of pts) await addDoc(collection(db, DELIVERIES_COL), p);
  }
  const sSnap = await getDocs(collection(db, STRAWBERRIES_COL));
  if (sSnap.size === 0){
    const spts = [
      { x: 400, y: 400, available:true },
      { x: 800, y: 700, available:true },
      { x: 1300, y: 1100, available:true },
      { x: 1600, y: 500, available:true },
    ];
    for (const s of spts) await addDoc(collection(db, STRAWBERRIES_COL), s);
  }
}

/* ====== Join: ãƒªã‚¹ãƒŠãƒ¼å…ˆç™»éŒ² â†’ setDoc ã§ player ä½œæˆ â†’ ãƒªã‚¹ãƒŠãƒ¼ã§ç¢ºèª â†’ ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ˆwaiting->playingï¼‰ ====== */
async function joinAs(name, team){
  showLoading(true);
  await ensureGame();
  await seedMapOnce();

  // æ—¢å­˜ã®åŒåã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤ï¼ˆä»•æ§˜ï¼‰
  try {
    const snaps = await getDocs(collection(db, PLAYERS_COL));
    for (const d of snaps.docs){
      const data = d.data();
      if (data && data.name === name){
        try { await deleteDoc(d.ref); pushLog(`å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³(${name})ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, "info"); } catch(e){}
      }
    }
  } catch(e){ /* ignore */ }

  // generate sessionId and set up listeners before writing doc (fix initial-join race)
  sessionId = genSessionId();
  setupListeners(); // listeners will look for sessionId in allPlayers
  // now write player doc using setDoc (stable id)
  try {
    await setDoc(doc(db, PLAYERS_COL, sessionId), {
      name: name || "Player",
      team,
      x: randPos().x, y: randPos().y,
      possession: 0,
      lastAction: serverTimestamp(),
      dashReadyAt: 0
    });
  } catch(e){
    showLoading(false);
    pushLog("å‚åŠ ä½œæˆã«å¤±æ•—: " + (e.message||e), "error");
    return;
  }

  // wait until our listener acknowledges the player doc is present (max timeout)
  const start = Date.now();
  let acknowledged = false;
  while (Date.now() - start < 5000){
    if (allPlayers.find(p => p._id === sessionId)){ acknowledged = true; break; }
    await new Promise(r => setTimeout(r, 150));
  }
  if (!acknowledged){
    // still proceed but warn
    pushLog("å‚åŠ å‡¦ç†ã®åæ˜ ãŒé…å»¶ã—ã¦ã„ã¾ã™ãŒç¶šè¡Œã—ã¾ã™", "error");
  }

  // set game to playing if waiting
  try {
    await runTransaction(db, async (t) => {
      const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
      const s = await t.get(gRef);
      if (!s.exists()) throw new Error("game missing");
      const g = s.data();
      if (g.state === "waiting") t.update(gRef, { state: "playing" });
    });
  } catch(e){}
  showLoading(false);
  showScreen("game");
  updateStatus(`å‚åŠ ä¸­: ${name} (${team})`);
  pushLog(`${name} ãŒå‚åŠ ã—ã¾ã—ãŸ`, "event");
}

/* ====== Leave ====== */
async function leave(){
  if (!sessionId) return;
  try { await deleteDoc(doc(db, PLAYERS_COL, sessionId)); } catch(e){}
  sessionId = null; localPlayer = null;
  tearDownListeners();
  showScreen("waiting");
  updateStatus("é›¢è„±ã—ã¾ã—ãŸ");
}

/* ====== Listeners (players/strawberries/deliveries/game) ====== */
function setupListeners(){
  // game
  if (unsubGame) unsubGame();
  unsubGame = onSnapshot(doc(db, GAME_COLLECTION, GAME_DOC_ID), (snap) => {
    if (!snap.exists()) return;
    gameDoc = snap.data();
    topOni.textContent = gameDoc.scores?.oni || 0;
    topRunner.textContent = gameDoc.scores?.runner || 0;
    oniScoreEl.textContent = gameDoc.scores?.oni || 0;
    runnerScoreEl.textContent = gameDoc.scores?.runner || 0;
    if (gameDoc.state === "waiting") {
      pushLog("ãƒ©ã‚¦ãƒ³ãƒ‰ãŒå¾…æ©ŸçŠ¶æ…‹ã«ãªã‚Šã¾ã—ãŸã€‚", "info");
      showScreen("team");
    }
  });

  // players
  if (unsubPlayers) unsubPlayers();
  unsubPlayers = onSnapshot(collection(db, PLAYERS_COL), (snap) => {
    const arr = [];
    snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    allPlayers = arr;
    localPlayer = allPlayers.find(p => p._id === sessionId) || localPlayer;

    // counts
    const oniCount = allPlayers.filter(p => p.team === "oni").length;
    const runnerCount = allPlayers.filter(p => p.team === "runner").length;
    oniCountEl.textContent = "äººæ•°: " + oniCount;
    runnerCountEl.textContent = "äººæ•°: " + runnerCount;
    waitOniCount.textContent = oniCount;
    waitRunnerCount.textContent = runnerCount;

    // info
    if (localPlayer){ playerInfoName.textContent = localPlayer.name; playerInfoTeam.textContent = "ãƒãƒ¼ãƒ : " + localPlayer.team; }
    else { playerInfoName.textContent = "æœªå‚åŠ "; playerInfoTeam.textContent = "ãƒãƒ¼ãƒ : -"; }
    renderPlayerList();

    // try collect strawberries on player changes (helps pickup reliability)
    for (const s of strawberries) attemptCollectStraw(s);
  });

  // strawberries
  if (unsubStraw) unsubStraw();
  unsubStraw = onSnapshot(collection(db, STRAWBERRIES_COL), (snap) => {
    const arr = []; snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    strawberries = arr;
    for (const s of strawberries) attemptCollectStraw(s);
  });

  // deliveries
  if (unsubDeliveries) unsubDeliveries();
  unsubDeliveries = onSnapshot(collection(db, DELIVERIES_COL), (snap) => {
    const arr = []; snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    deliveries = arr;
  });
}

function tearDownListeners(){
  if (unsubGame) unsubGame(); unsubGame = null;
  if (unsubPlayers) unsubPlayers(); unsubPlayers = null;
  if (unsubStraw) unsubStraw(); unsubStraw = null;
  if (unsubDeliveries) unsubDeliveries(); unsubDeliveries = null;
  allPlayers = []; strawberries = []; deliveries = []; gameDoc = null;
  renderPlayerList();
}

/* ====== Finalize & Reset (admin) ====== */
async function finalizeAndResetRound(){
  try {
    async function delAll(col){
      const snaps = await getDocs(collection(db, col));
      const batch = writeBatch(db);
      let any=false;
      for (const d of snaps.docs){ batch.delete(d.ref); any=true; }
      if (any) await batch.commit();
    }
    await delAll(PLAYERS_COL);
    await delAll(STRAWBERRIES_COL);
    await delAll(DELIVERIES_COL);
    await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { state:"waiting", scores:{oni:0, runner:0}, mapSize:MAP_SIZE, createdAt: serverTimestamp() });
    pushLog("ç®¡ç†è€…ã«ã‚ˆã‚‹å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆï¼šå…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤", "event");
  } catch(e){ console.error(e); }
}

/* ====== Strawberry collection (>=2 runners) + immediate teleport ====== */
async function attemptCollectStraw(straw){
  if (!straw || !straw.available) return;
  const nearby = allPlayers.filter(p => p.team === "runner" && Math.hypot(p.x - straw.x, p.y - straw.y) <= PICKUP_RADIUS);
  if (nearby.length < 2) return;
  try {
    await runTransaction(db, async (t) => {
      const sRef = doc(db, STRAWBERRIES_COL, straw._id);
      const sSnap = await t.get(sRef);
      if (!sSnap.exists()) throw new Error("straw missing");
      const sData = sSnap.data();
      if (!sData.available) throw new Error("already collected");
      t.update(sRef, { available: false });
      for (const p of nearby){
        const pRef = doc(db, PLAYERS_COL, p._id);
        const pSnap = await t.get(pRef);
        if (!pSnap.exists()) continue;
        const cur = pSnap.data().possession || 0;
        t.update(pRef, { possession: cur + 1, lastAction: serverTimestamp() });
      }
    });
    pushLog(`ã‚¤ãƒã‚´å›å: ${nearby.map(n=>n.name).join(", ")}`, "event");
    // immediate teleport (reposition)
    if (STRAW_RESPAWN_IMMEDIATE){
      try { await updateDoc(doc(db, STRAWBERRIES_COL, straw._id), { x: randPos().x, y: randPos().y, available: true }); } catch(e){}
    }
  } catch(e){}
}

/* ====== Delivery processing (player near any delivery) ====== */
async function tryDeliver(player){
  if (!player || player.team !== "runner") return;
  for (const d of deliveries){
    const dist = Math.hypot(player.x - d.x, player.y - d.y);
    if (dist <= PICKUP_RADIUS){
      const amount = player.possession || 0;
      if (amount <= 0) return;
      try {
        await runTransaction(db, async (t) => {
          const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
          const gSnap = await t.get(gRef);
          if (!gSnap.exists()) throw new Error("game missing");
          const g = gSnap.data();
          const scores = g.scores || { oni:0, runner:0 };
          scores.runner = (scores.runner || 0) + amount;
          t.update(gRef, { scores, lastUpdated: serverTimestamp() });
          t.update(doc(db, PLAYERS_COL, player._id), { possession: 0, lastAction: serverTimestamp() });
        });
        pushLog(`${player.name} ãŒç´å“ï¼ +${amount}`, "event");
        // check win
        const gsnap = await getDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID));
        if (gsnap.exists()){
          const g2 = gsnap.data();
          if ((g2.scores?.runner || 0) >= WIN_SCORE){
            pushLog("é€ƒã’ãƒãƒ¼ãƒ ãŒå‹åˆ©ï¼", "event");
            await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { ...g2, state: "ended" });
            await finalizeAndResetRound();
          }
        }
      } catch(e){ console.error(e); }
      return;
    }
  }
}

/* ====== Capture handling (oni catches runner) + +5 to oni score ====== */
async function checkCapturesAndHandle(){
  const onis = allPlayers.filter(p => p.team === "oni");
  const runners = allPlayers.filter(p => p.team === "runner");
  if (onis.length === 0 || runners.length === 0) return;
  for (const r of runners){
    for (const o of onis){
      const d = Math.hypot(r.x - o.x, r.y - o.y);
      if (d <= CAPTURE_RADIUS){
        try {
          // reset runner
          await updateDoc(doc(db, PLAYERS_COL, r._id), { possession:0, x: randPos().x, y: randPos().y, lastAction: serverTimestamp() });
          // add +5 to oni score
          await runTransaction(db, async (t) => {
            const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
            const s = await t.get(gRef);
            if (!s.exists()) return;
            const g = s.data();
            const scores = g.scores || { oni:0, runner:0 };
            scores.oni = (scores.oni || 0) + 5;
            t.update(gRef, { scores, lastUpdated: serverTimestamp() });
          });
          pushLog(`${r.name} ãŒæ•ã¾ã£ãŸï¼ é¬¼ãƒãƒ¼ãƒ  +5`, "event");
          explosionAudio.currentTime = 0; explosionAudio.play().catch(()=>{});
          // check win
          const gsnap = await getDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID));
          if (gsnap.exists()){
            const g2 = gsnap.data();
            if ((g2.scores?.oni || 0) >= WIN_SCORE){
              pushLog("é¬¼ãƒãƒ¼ãƒ ãŒå‹åˆ©ï¼", "event");
              await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { ...g2, state: "ended" });
              await finalizeAndResetRound();
            }
          }
        } catch(e){ console.error(e); }
        break;
      }
    }
  }
}

/* ====== Position Update (throttle) ====== */
async function sendPositionIfNeeded(x,y){
  if (!sessionId) return;
  const now = nowMillis();
  if (now - lastPosSend < POSITION_THROTTLE_MS) return;
  lastPosSend = now;
  try { await updateDoc(doc(db, PLAYERS_COL, sessionId), { x, y, lastAction: serverTimestamp() }); } catch(e){}
}

/* ====== Dash handling ====== */
function canDash(p){ if (!p || p.team !== "oni") return false; const readyAt = p.dashReadyAt || 0; return Date.now() >= readyAt; }
async function startDash(){
  if (!localPlayer || localPlayer.team !== "oni") return;
  const now = Date.now();
  try {
    await updateDoc(doc(db, PLAYERS_COL, sessionId), { dashReadyAt: now + DASH_CT_MS });
    localPlayer._isDashingUntil = now + DASH_DUR_MS;
    setTimeout(()=>{ if (localPlayer) localPlayer._isDashingUntil = 0; }, DASH_DUR_MS);
  } catch(e){}
}

/* ====== Drawing helpers & camera ====== */
function drawTextBubble(ctx, text, x, y, bg="#000", small=false){
  ctx.save();
  ctx.font = (small ? "12px sans-serif" : "13px sans-serif");
  const metrics = ctx.measureText(text);
  const padX = 8, padY = 6;
  const w = metrics.width + padX*2;
  const h = 18;
  const bx = x - w/2, by = y - h/2;
  ctx.fillStyle = bg || "rgba(0,0,0,0.6)";
  const r = 8;
  ctx.beginPath(); ctx.moveTo(bx+r, by);
  ctx.arcTo(bx+w, by, bx+w, by+h, r);
  ctx.arcTo(bx+w, by+h, bx, by+h, r);
  ctx.arcTo(bx, by+h, bx, by, r);
  ctx.arcTo(bx, by, bx+w, by, r);
  ctx.closePath(); ctx.fill();
  ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
  ctx.fillText(text, x, y);
  ctx.restore();
}

/* compute camera center & mapping helpers */
function computeCamera(centerPlayer, width, height){
  let camX = centerPlayer ? centerPlayer.x : MAP_SIZE/2;
  let camY = centerPlayer ? centerPlayer.y : MAP_SIZE/2;
  const halfW = width/2, halfH = height/2;
  camX = clamp(camX, halfW, MAP_SIZE - halfW);
  camY = clamp(camY, halfH, MAP_SIZE - halfH);
  return { camX, camY, halfW, halfH };
}
function worldToScreen(mx, my, cam){
  return { x: Math.round(mx - (cam.camX - cam.halfW)), y: Math.round(my - (cam.camY - cam.halfH)) };
}
function screenToWorld(sx, sy, cam){
  return { x: (cam.camX - cam.halfW) + sx, y: (cam.camY - cam.halfH) + sy };
}

/* draw world (main canvas) */
function drawWorld(ctx, width, height, centerPlayer, applyVisibility){
  ctx.clearRect(0,0,width,height);
  const cam = computeCamera(centerPlayer, width, height);
  if (mapImageLoaded){
    const scaleX = width / MAP_SIZE, scaleY = height / MAP_SIZE;
    ctx.drawImage(mapImage, (-(cam.camX - cam.halfW))*scaleX, (-(cam.camY - cam.halfH))*scaleY, MAP_SIZE*scaleX, MAP_SIZE*scaleY);
  } else {
    ctx.fillStyle = "#081018"; ctx.fillRect(0,0,width,height);
  }

  // deliveries
  for (const d of deliveries){
    const s = worldToScreen(d.x, d.y, cam);
    drawTextBubble(ctx, "â–³ ç´å“æ‰€", s.x, s.y - 26, "#ffd39a");
    ctx.fillStyle = "#ffd39a";
    ctx.beginPath(); ctx.moveTo(s.x, s.y-10); ctx.lineTo(s.x-10, s.y+10); ctx.lineTo(s.x+10, s.y+10); ctx.closePath(); ctx.fill();
  }

  // strawberries
  for (const sdoc of strawberries){
    const s = worldToScreen(sdoc.x, sdoc.y, cam);
    let visible = true;
    if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
      visible = Math.hypot(centerPlayer.x - sdoc.x, centerPlayer.y - sdoc.y) <= VISIBILITY_RADIUS;
    }
    if (!visible) continue;
    drawTextBubble(ctx, "ãƒ» ã‚¤ãƒã‚´", s.x, s.y - 26, "#ff6b8a");
    ctx.fillStyle = sdoc.available ? "#ff6b8a" : "#5a2a2f";
    ctx.beginPath(); ctx.arc(s.x, s.y, 8, 0, Math.PI*2); ctx.fill();
    const runnersNear = allPlayers.filter(p => p.team === "runner" && Math.hypot(p.x - sdoc.x, p.y - sdoc.y) <= PICKUP_RADIUS);
    if (runnersNear.length === 1){
      ctx.strokeStyle = "rgba(255,255,128,0.9)"; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(s.x, s.y, 12, 0, Math.PI*2); ctx.stroke(); ctx.lineWidth = 1;
    }
  }

  // players
  for (const p of allPlayers){
    let visible = true;
    if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
      if (p._id === centerPlayer._id) visible = true;
      else visible = (Math.hypot(centerPlayer.x - p.x, centerPlayer.y - p.y) <= VISIBILITY_RADIUS);
    }
    if (!visible) continue;
    const s = worldToScreen(p.x, p.y, cam);
    if (p.team === "runner"){ ctx.fillStyle = "#4db8ff"; ctx.beginPath(); ctx.arc(s.x, s.y, 12, 0, Math.PI*2); ctx.fill(); }
    else { ctx.fillStyle = "#ffcf4d"; ctx.fillRect(s.x-12, s.y-12, 24, 24); }

    if (localPlayer && p._id === localPlayer._id){
      ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;
      if (p.team === "runner"){ ctx.beginPath(); ctx.arc(s.x, s.y, 14, 0, Math.PI*2); ctx.stroke(); }
      else { ctx.strokeRect(s.x-14, s.y-14, 28, 28); }
      ctx.lineWidth = 1;
    }

    if (p.team === "runner"){
      drawTextBubble(ctx, (p.possession ? `ğŸ“${p.possession}` : "ğŸ“0"), s.x, s.y - 34, "#083047");
    }
    drawTextBubble(ctx, p.name, s.x, s.y + 20, "#000", true);
  }

  // field-of-view mask: draw around player's screen pos (fixes FOV freeze at edges)
  if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
    const centerScreen = worldToScreen(centerPlayer.x, centerPlayer.y, cam);
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.beginPath();
    ctx.rect(0,0,width,height);
    ctx.arc(centerScreen.x, centerScreen.y, VISIBILITY_RADIUS, 0, Math.PI*2, true);
    try{ ctx.fill('evenodd'); } catch(e){ ctx.globalCompositeOperation='destination-out'; ctx.fill(); ctx.globalCompositeOperation='source-over'; }
    ctx.restore();
  }

  // nearest teammate hint
  if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
    const others = allPlayers.filter(p => p.team === "runner" && p._id !== centerPlayer._id);
    if (others.length > 0){
      others.sort((a,b)=> Math.hypot(a.x-centerPlayer.x,a.y-centerPlayer.y) - Math.hypot(b.x-centerPlayer.x,b.y-centerPlayer.y));
      drawDirectionHint(ctx, others[0], centerPlayer, width, height, cam);
    }
  }
}

/* draw minimap */
function drawMiniMap(){
  miniCtx.clearRect(0,0,miniMap.width,miniMap.height);
  const w = miniMap.width, h = miniMap.height;
  miniCtx.fillStyle = "#041218"; miniCtx.fillRect(0,0,w,h);
  if (mapImageLoaded) miniCtx.drawImage(mapImage,0,0,w,h);
  for (const d of deliveries){
    const sx = d.x / MAP_SIZE * w, sy = d.y / MAP_SIZE * h;
    miniCtx.fillStyle = "#ffd39a"; miniCtx.beginPath(); miniCtx.moveTo(sx, sy-6); miniCtx.lineTo(sx-6, sy+6); miniCtx.lineTo(sx+6, sy+6); miniCtx.closePath(); miniCtx.fill();
  }
  for (const s of strawberries){
    const sx = s.x / MAP_SIZE * w, sy = s.y / MAP_SIZE * h;
    miniCtx.fillStyle = s.available ? "#ff6b8a" : "#5a2a2f"; miniCtx.beginPath(); miniCtx.arc(sx, sy, 3,0,Math.PI*2); miniCtx.fill();
  }
  for (const p of allPlayers){
    const sx = p.x / MAP_SIZE * w, sy = p.y / MAP_SIZE * h;
    miniCtx.fillStyle = p.team === "oni" ? "#ffcf4d" : "#4db8ff";
    miniCtx.beginPath(); miniCtx.arc(sx, sy, 3 + (localPlayer && localPlayer._id === p._id ? 2 : 0), 0, Math.PI*2); miniCtx.fill();
  }
  miniCtx.strokeStyle = "rgba(255,255,255,0.06)"; miniCtx.strokeRect(0,0,w,h);
}

/* draw direction hint */
function drawDirectionHint(ctx, target, self, width, height, cam){
  const dx = target.x - self.x, dy = target.y - self.y;
  const angle = Math.atan2(dy, dx);
  const cx = width/2, cy = height/2;
  const edgeX = cx + Math.cos(angle) * (Math.min(width,height)/2 - 30);
  const edgeY = cy + Math.sin(angle) * (Math.min(width,height)/2 - 30);
  ctx.save();
  ctx.translate(edgeX, edgeY);
  ctx.rotate(angle);
  ctx.fillStyle = "#ff8";
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-10,-6); ctx.lineTo(-10,6); ctx.closePath(); ctx.fill();
  const dist = Math.round(Math.hypot(dx,dy));
  drawTextBubble(ctx, `${target.name} (${dist}m)`, edgeX + 18, edgeY, "#222", true);
  ctx.restore();
}

/* ===== render loop ===== */
function renderLoop(){
  requestAnimationFrame(renderLoop);
  drawWorld(gctx, gameCanvas.width, gameCanvas.height, localPlayer, true);
  drawMiniMap();
  updateDashStatusUI();
  updateBoostUI();
}
renderLoop();

/* ===== input: WASD + click-to-move (ã‚¯ãƒªãƒƒã‚¯ç§»å‹•ã¯ã‚­ãƒ¼æŠ¼ä¸‹ã§ä¸­æ–­) ===== */
const pressed = new Set();
let lastKeyEventTime = Date.now();
let clickTarget = null;

window.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){
    e.preventDefault(); lastKeyEventTime = Date.now(); pressed.add(k);
    // cancel click target while keys pressed (keys take precedence)
    if (clickTarget) clickTarget = null;
  }
});
window.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){
    e.preventDefault(); lastKeyEventTime = Date.now(); pressed.delete(k);
  }
});
window.addEventListener('blur', ()=>{ pressed.clear(); clickTarget = null; });

setInterval(()=>{ if (Date.now() - lastKeyEventTime > 1000) pressed.clear(); }, 1200);

/* canvas click -> compute world coords and set clickTarget */
gameCanvas.addEventListener('click', (ev) => {
  if (!localPlayer) return;
  const rect = gameCanvas.getBoundingClientRect();
  const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top;
  const cam = computeCamera(localPlayer, gameCanvas.width, gameCanvas.height);
  const world = screenToWorld(sx, sy, cam);
  clickTarget = { x: world.x, y: world.y };
});

/* movement tick */
setInterval(async ()=>{
  if (!localPlayer || !sessionId) return;
  let sp = localPlayer.team === "oni" ? ONI_SPEED : RUNNER_SPEED;

  // dash trigger (Shift)
  if (localPlayer.team === "oni" && (pressed.has("shift")) && canDash(localPlayer)){
    await startDash();
  }
  if (localPlayer._isDashingUntil && Date.now() < localPlayer._isDashingUntil) sp *= DASH_MULT;

  // coop boost
  let hasBoost = false;
  if (localPlayer.team === "runner"){
    const nearby = allPlayers.filter(p => p._id !== localPlayer._id && p.team === "runner" && Math.hypot(p.x - localPlayer.x, p.y - localPlayer.y) <= COOP_BOOST_DIST);
    if (nearby.length >= 1){ sp *= COOP_SPEED_MULT; hasBoost = true; }
  }

  // determine movement: keys take precedence, else clickTarget moves
  let dx = 0, dy = 0;
  if (pressed.has("a") || pressed.has("arrowleft")) dx -= 1;
  if (pressed.has("d") || pressed.has("arrowright")) dx += 1;
  if (pressed.has("w") || pressed.has("arrowup")) dy -= 1;
  if (pressed.has("s") || pressed.has("arrowdown")) dy += 1;

  if (dx === 0 && dy === 0 && clickTarget){
    // move toward clickTarget
    const vx = clickTarget.x - localPlayer.x, vy = clickTarget.y - localPlayer.y;
    const dist = Math.hypot(vx, vy);
    if (dist < 4){ clickTarget = null; return; }
    dx = vx / dist; dy = vy / dist;
  } else if (dx === 0 && dy === 0) {
    return;
  }

  const mag = Math.hypot(dx,dy) || 1;
  dx = dx / mag * sp; dy = dy / mag * sp;
  const nx = clamp(localPlayer.x + dx, 0, MAP_SIZE);
  const ny = clamp(localPlayer.y + dy, 0, MAP_SIZE);
  localPlayer.x = nx; localPlayer.y = ny;
  await sendPositionIfNeeded(nx, ny);

  // if hasBoost AND near an available strawberry and 2 players present, ensure collection
  if (hasBoost){
    for (const s of strawberries){
      const d = Math.hypot(localPlayer.x - s.x, localPlayer.y - s.y);
      if (d <= PICKUP_RADIUS){
        // prefer to attempt collection immediately (transaction inside)
        await attemptCollectStraw(s);
      }
    }
  }

  // regular checks
  await tryDeliver(localPlayer);
  for (const s of strawberries) await attemptCollectStraw(s);
  await checkCapturesAndHandle();
}, 100);

/* ===== footstep sound: runners hear if oni within range (expanded but controlled) ===== */
setInterval(()=>{
  if (!localPlayer) return;
  if (localPlayer.team === "runner"){
    const onis = allPlayers.filter(p => p.team === "oni");
    for (const o of onis){
      const d = Math.hypot(o.x - localPlayer.x, o.y - localPlayer.y);
      if (d <= VISIBILITY_RADIUS * FOOTSTEP_RANGE_MULT){
        asiotoAudio.currentTime = 0; asiotoAudio.play().catch(()=>{});
        break;
      }
    }
  }
}, 900);

/* ===== player list rendering (admin sees coords & kick) ===== */
function renderPlayerList(){
  playerListEl.innerHTML = "";
  const sorted = allPlayers.slice().sort((a,b)=> a.team.localeCompare(b.team) || (a.name||"").localeCompare(b.name));
  for (const p of sorted){
    const row = document.createElement("div"); row.className = "playerRow";
    const left = document.createElement("div"); left.style.display="flex"; left.style.gap="8px"; left.style.alignItems="center";
    const shape = document.createElement("div"); shape.style.width="14px"; shape.style.height="14px"; shape.style.borderRadius = p.team === "runner" ? "50%" : "3px";
    shape.style.background = p.team === "runner" ? "#4db8ff" : "#ffd54d";
    left.appendChild(shape);
    const info = document.createElement("div"); info.innerHTML = `<div style="font-weight:700">${p.name}</div><div class="small">${p.team}</div>`;
    left.appendChild(info);
    row.appendChild(left);

    const right = document.createElement("div"); right.style.textAlign = "right";
    const coords = adminMode ? `<div style="color:#9fb8c8;font-size:0.85rem">${Math.round(p.x)},${Math.round(p.y)}</div>` : "";
    right.innerHTML = `<div style="font-weight:700">${p.possession || 0}ğŸ“</div>${coords}`;
    if (adminMode){
      const kick = document.createElement("button"); kick.className="kickBtn"; kick.textContent = "é€€å‡º";
      kick.onclick = async () => {
        if (!confirm(`${p.name} ã‚’å¼·åˆ¶é€€å‡ºã•ã›ã¾ã™ã‹ï¼Ÿ`)) return;
        try { await deleteDoc(doc(db, PLAYERS_COL, p._id)); pushLog(`${p.name} ã‚’ç®¡ç†è€…ãŒé€€å‡ºã•ã›ã¾ã—ãŸ`, "event"); } catch(e){ alert("é€€å‡ºã«å¤±æ•—ã—ã¾ã—ãŸ"); }
      };
      right.appendChild(kick);
    }
    row.appendChild(right);
    playerListEl.appendChild(row);
  }
}

/* ===== dash status UI ===== */
function updateDashStatusUI(){
  if (!localPlayer){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: -"; return; }
  if (localPlayer.team !== "oni"){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: (é¬¼ã®ã¿)"; return; }
  const readyAt = localPlayer.dashReadyAt || 0;
  const now = Date.now();
  if (now >= readyAt) dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨å¯èƒ½";
  else { const sec = Math.ceil((readyAt - now)/1000); dashStatusEl.textContent = `ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨ä¸å¯ æ®‹ã‚Š ${sec}s`; }
}

/* ===== boost UI ===== */
function updateBoostUI(){
  if (!localPlayer){ boostStatusEl.textContent = ""; return; }
  if (localPlayer.team === "runner"){
    const nearby = allPlayers.filter(p => p._id !== localPlayer._id && p.team === "runner" && Math.hypot(p.x - localPlayer.x, p.y - localPlayer.y) <= COOP_BOOST_DIST);
    if (nearby.length >= 1){ boostStatusEl.textContent = "ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ–ãƒ¼ã‚¹ãƒˆä¸­ï¼ˆè¿‘ãã«ä»²é–“ï¼‰"; boostStatusEl.style.background = "linear-gradient(90deg,#7fffd4,#2ee6b6)"; }
    else { boostStatusEl.textContent = ""; boostStatusEl.style.background = "linear-gradient(90deg,#06281f,#0b3940)"; }
  } else { boostStatusEl.textContent = ""; }
}

/* ===== UI hooks ===== */
toTeamBtn.addEventListener('click', ()=> showScreen("team"));
chooseOni.addEventListener('click', ()=>{ joinedTeamChoice = "oni"; showScreen("join"); });
chooseRunner.addEventListener('click', ()=>{ joinedTeamChoice = "runner"; showScreen("join"); });
backFromTeam.addEventListener('click', ()=> showScreen("waiting"));
backFromJoin.addEventListener('click', ()=> showScreen("team"));
joinNow.addEventListener('click', async ()=>{
  const name = (inputName.value || "").trim();
  if (!name){ alert("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; }
  if (!joinedTeamChoice){ alert("ãƒãƒ¼ãƒ ã‚’é¸ã‚“ã§ãã ã•ã„"); return; }
  await joinAs(name, joinedTeamChoice);
  joinedTeamChoice = null; inputName.value = "";
});
leaveBtn.addEventListener('click', ()=> leave());

adminSmall.addEventListener('click', async ()=>{
  const pass = prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:");
  if (pass === ADMIN_PASS){ adminMode = true; adminResetBtn.classList.remove("hidden"); alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹"); renderPlayerList(); }
  else alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¸æ­£");
});
adminResetBtn.addEventListener('click', async ()=>{
  if (!adminMode) return alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™");
  if (!confirm("å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) return;
  await finalizeAndResetRound();
});
homeResetBtn.addEventListener('click', async ()=>{
  const pass = prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ");
  if (pass === ADMIN_PASS){ await finalizeAndResetRound(); } else alert("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™");
});

/* ===== bootstrap ===== */
(async function boot(){
  await ensureGame();
  await seedMapOnce();
  showScreen("waiting");
  updateStatus("å¾…æ©Ÿä¸­");
})();

/* periodic win check & housekeeping */
setInterval(async () => {
  try {
    const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
    const gSnap = await getDoc(gRef);
    if (!gSnap.exists()) return;
    const g = gSnap.data();
    const scores = g.scores || { oni:0, runner:0 };
    if (g.state === "playing" && (scores.oni >= WIN_SCORE || scores.runner >= WIN_SCORE)){
      pushLog("å‹åˆ©æ¡ä»¶åˆ°é”ã«ã‚ˆã‚Šãƒ©ã‚¦ãƒ³ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™ã€‚", "event");
      await setDoc(gRef, { ...g, state: "ended" });
      await finalizeAndResetRound();
    }
  } catch(e){}
}, 3000);

/* ensure strawberry checks and captures often */
setInterval(async ()=>{ for (const s of strawberries) attemptCollectStraw(s); await checkCapturesAndHandle(); }, 1200);

</script>
</body>
</html>
