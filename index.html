<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤åŸºç›¤ - å®Œå…¨çµ±åˆç‰ˆ</title>
<style>
  :root{
    --bg:#0d0f12; --panel:#111317; --oni:#ffcf4d; --runner:#4db8ff; --muted:#9aa3ad;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui, "Hiragino Kaku Gothic ProN","ãƒ¡ã‚¤ãƒªã‚ª",sans-serif;background:var(--bg);color:#e6eef6}
  #app{display:flex;height:100vh;gap:12px;padding:12px}
  #left{flex:1;display:flex;flex-direction:column;gap:12px;align-items:center}
  #right{width:380px;background:linear-gradient(180deg,#0b0d10,#0f1113);box-shadow:-6px 0 18px rgba(0,0,0,.6);padding:14px;border-radius:10px;display:flex;flex-direction:column;gap:12px}
  canvas{border-radius:8px;background:#081018;display:block}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:8px;width:100%}
  .center{text-align:center}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 12px;border-radius:8px;cursor:pointer}
  .big{font-size:1.05rem;padding:10px 14px}
  .small{font-size:0.85rem;color:var(--muted)}
  .logItem{margin-bottom:6px;padding:6px 8px;border-radius:8px}
  .log-info{background:rgba(255,255,255,0.02)}
  .log-event{background:rgba(255,215,170,0.06)}
  .log-error{background:rgba(255,80,80,0.06)}
  .playerRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:6px;background:rgba(255,255,255,0.02)}
  .kickBtn{padding:6px 8px;border-radius:6px;background:#ff6b6b;border:none;color:#111;cursor:pointer}
  #loadingOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999;color:#fff;font-size:1.1rem;display:none}
  #victoryOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:10000}
  #victoryOverlay .panel{font-size:2rem;padding:24px;border-radius:12px}
  #boostStatus{margin-top:8px;font-weight:700;color:#bfffbf;text-align:center;min-height:22px}
</style>
</head>
<body>
<div id="adminSmall" style="position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:6px;cursor:pointer;z-index:110">ç®¡ç†</div>

<div id="app">
  <div id="left">
    <div id="screen-waiting" class="panel">
      <div class="center">
        <h2>å¾…æ©Ÿ / ãƒ«ãƒ¼ãƒ«</h2>
        <p class="small">å‚åŠ ã™ã‚‹ã‚’æŠ¼ã™ã¨ãƒãƒ¼ãƒ é¸æŠã¸ã€‚ç®¡ç†ã¯å³ä¸Šã€Œç®¡ç†ã€ã€‚map.png ã‚’ç½®ãã¨ãƒãƒƒãƒ—ã«åæ˜ ã€‚</p>
        <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
          <button id="toTeamBtn" class="big">å‚åŠ ã™ã‚‹</button>
          <button id="homeResetBtn" class="big">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
      </div>
      <div style="margin-top:12px">
        <pre style="white-space:pre-wrap;font-size:0.95rem;color:#dfe9f4">
ãƒ»é¬¼(â–¢): ãƒãƒƒãƒ—å…¨ä½“å¯è¦–ã€‚ã‚·ãƒ•ãƒˆã§ãƒ€ãƒƒã‚·ãƒ¥ï¼ˆCT è¡¨ç¤ºï¼‰ã€‚æ•ç²ã§é¬¼ãƒãƒ¼ãƒ +5ã€‚
ãƒ»é€ƒã’(ã€‡): è‡ªåˆ†ä¸­å¿ƒã®è¦–ç•Œã€‚ã‚·ãƒ•ãƒˆã§ã‚¤ãƒã‚´ã‚’æ´ã‚“ã§é‹ã¹ã‚‹ï¼ˆæ´ã‚“ã§ã„ã‚‹é–“é€Ÿåº¦0.2å€ï¼‰ã€‚
ãƒ»ã‚¤ãƒã‚´(ãƒ»): å¸¸æ™‚ 4 å€‹ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ã ãŒä¸­å¿ƒå¯„ã‚Šï¼‰ã€‚2 äººä»¥ä¸Šã§é€šå¸¸å›å(+1 each)ã€‚
ãƒ»ç´å“(â–³): è§’ã®4ã‹æ‰€ã€‚4ã‹æ‰€ã™ã¹ã¦ã«ã‚¤ãƒã‚´ã‚’é…ç½®ã™ã‚‹ã¨é€ƒã’ãƒãƒ¼ãƒ å‹åˆ©ã€‚
ãƒ»å…ˆã«ãƒãƒ¼ãƒ ã‚¹ã‚³ã‚¢ 50 or ä¸Šè¨˜æ¡ä»¶ã§å‹åˆ©ã€å³ãƒªã‚»ãƒƒãƒˆã€‚
        </pre>
      </div>
      <div style="margin-top:8px" class="small center">ãƒãƒ¼ãƒ äººæ•° â€” é¬¼: <span id="waitOniCount">0</span> / é€ƒã’: <span id="waitRunnerCount">0</span></div>
    </div>

    <div id="screen-team" class="panel hidden">
      <h2 class="center">ãƒãƒ¼ãƒ ã‚’é¸ã‚“ã§ãã ã•ã„</h2>
      <div style="display:flex;gap:12px;margin-top:12px">
        <div style="flex:1"><button id="chooseOni" class="big" style="width:100;background:linear-gradient(90deg,#ffecb3,#ffd54d);color:#111">ğŸ‘¹ é¬¼ãƒãƒ¼ãƒ  <div class="small" id="oniCount">äººæ•°: 0</div></button></div>
        <div style="flex:1"><button id="chooseRunner" class="big" style="width:100;background:linear-gradient(90deg,#bfe8ff,#4db8ff);color:#022033">ğŸƒ é€ƒã’ãƒãƒ¼ãƒ  <div class="small" id="runnerCount">äººæ•°: 0</div></button></div>
      </div>
      <div style="margin-top:12px" class="center"><button id="backFromTeam">æˆ»ã‚‹</button></div>
    </div>

    <div id="screen-join" class="panel hidden">
      <h2 class="center">åå‰ã‚’å…¥åŠ›ã—ã¦å‚åŠ </h2>
      <div style="display:flex;gap:8px;align-items:center;justify-content:center;margin-top:8px">
        <input id="inputName" placeholder="åå‰" style="padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);width:220px;background:transparent;color:inherit" maxlength="16"/>
        <button id="joinNow">å‚åŠ </button>
      </div>
      <div style="margin-top:8px" class="center muted"><button id="backFromJoin">æˆ»ã‚‹</button></div>
    </div>

    <div id="screen-game" class="panel hidden" style="width:100%">
      <div style="display:flex;align-items:center;gap:12px">
        <div style="background:linear-gradient(90deg,#ffefd5,#fff1cc);padding:8px;border-radius:8px;color:#1a1200;font-weight:700">ğŸ‘¹ é¬¼: <span id="topOni">0</span></div>
        <div style="background:linear-gradient(90deg,#dff4ff,#d6f0ff);padding:8px;border-radius:8px;color:#022033;font-weight:700">ğŸƒ é€ƒã’: <span id="topRunner">0</span></div>
        <div style="margin-left:auto;display:flex;align-items:center;gap:8px"><div id="dashStatus">ãƒ€ãƒƒã‚·ãƒ¥: -</div><button id="leaveBtn">é›¢è„±</button></div>
      </div>

      <div style="margin-top:12px;width:100%">
        <canvas id="gameCanvas" width="1200" height="640"></canvas>
        <div id="boostStatus" class="panel" style="margin-top:8px;background:linear-gradient(180deg,#06281f,#0b3940)"></div>
      </div>
    </div>
  </div>

  <div id="right">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><div id="playerInfoName" style="font-weight:700">æœªå‚åŠ </div><div class="small" id="playerInfoTeam">ãƒãƒ¼ãƒ : -</div></div>
        <div><div class="small">æ”¾ç½®: <span id="idleCount">0</span>s</div></div>
      </div>
    </div>

    <div class="panel" style="display:flex;flex-direction:column;gap:8px;height:40vh">
      <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</div><div class="small">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ </div></div>
      <div id="playerList" style="overflow:auto;max-height:220px"></div>
      <div style="margin-top:6px" class="small">ï¼ˆç®¡ç†è€…ã¯åº§æ¨™ãƒ»é€€å‡ºãƒœã‚¿ãƒ³ã‚’æ“ä½œå¯ï¼‰</div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°</div><div class="small">10ç§’ã§æ¶ˆãˆã¾ã™</div></div>
      <div id="log" style="height:160px;overflow:auto;margin-top:8px"></div>
      <div style="display:flex;gap:8px;align-items:center;margin-top:8px"><button id="adminReset" class="hidden">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button><div id="statusSmall" class="small">çŠ¶æ…‹: åˆæœŸ</div></div>
      <div style="margin-top:8px"><canvas id="miniMap" width=320 height=140 style="width:100%;height:140px;border-radius:6px;background:#041218"></canvas><div class="small">map.png ã‚’ç½®ãã¨ãƒŸãƒ‹ãƒãƒƒãƒ—ã«åæ˜ </div></div>
    </div>
  </div>
</div>

<div id="loadingOverlay">å‡¦ç†ä¸­... å°‘ã—ãŠå¾…ã¡ãã ã•ã„</div>
<div id="victoryOverlay"><div class="panel" id="victoryPanel" style="background:rgba(0,0,0,0.8);color:#fff"></div></div>

<!-- audio -->
<audio id="asioto" src="asioto.mp3" preload="auto"></audio>
<audio id="explosion" src="explosion.mp3" preload="auto"></audio>

<script type="module">
/*
  å®Œå…¨ç‰ˆã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ
  å¤‰æ›´ç‚¹ï¼ˆã¾ã¨ã‚ï¼‰
  - å®‰å®šã—ãŸ join ãƒ•ãƒ­ãƒ¼ï¼ˆæœ€åˆã®å‚åŠ è€…ãŒå£Šã‚Œã‚‹å•é¡Œã¸ã®å¯¾å‡¦ï¼‰
  - ã‚¢ã‚»ãƒƒãƒˆå¯¾å¿œ: å„ç¨® PNG ã‚’èª­ã¿è¾¼ã¿å¯èƒ½ï¼ˆè¨­å®šæ¬„ã«ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç½®ãã ã‘ï¼‰
  - ã‚¤ãƒã‚´ã¯å¸¸ã« 4 å€‹ã‚¹ãƒãƒ¼ãƒ³ï¼ˆä¸­å¿ƒå¯„ã‚Šã®ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
  - é€ƒã’ã¯ã‚·ãƒ•ãƒˆã§è¿‘ãã®ã‚¤ãƒã‚´ã‚’æ´ã‚“ã§é‹ã¹ã‚‹ï¼ˆæŠ¼ã—ã¦ã„ã‚‹é–“ã®ã¿ï¼‰ã€‚é‹æ¬ä¸­ã¯é€Ÿåº¦ 0.2xã€‚
  - ã‚¤ãƒã‚´ã‚’å„ç´å“æ‰€ï¼ˆ4ã‹æ‰€ï¼‰ã«ç½®ãã¨é€ƒã’ãƒãƒ¼ãƒ å‹åˆ©ï¼ˆå³çµ‚äº†ï¼‰
  - é¬¼ãƒ€ãƒƒã‚·ãƒ¥å¼·åŒ–ï¼ˆæ—¢å­˜ã‹ã‚‰ã•ã‚‰ã« x3ï¼‰
  - è¶³éŸ³ç¯„å›²ã‚’ 5 å€ã«
  - ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°ã¯ 10 ç§’ã§è‡ªå‹•æ¶ˆå»
  - ã‚«ãƒ¡ãƒ©ã¯ lerp ã§æ»‘ã‚‰ã‹è¿½å¾“ï¼ˆè¦–ç•ŒãŒå›ºã¾ã‚‹å•é¡Œã‚’æ”¹å–„ï¼‰
  - ç”»åƒãŒç„¡ã‘ã‚Œã°æ—¢å­˜ã®å›³å½¢ã§æç”»ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
  - æ—¢å­˜ UI/æ©Ÿèƒ½ã¯å£Šã•ãªã„ã‚ˆã†æ³¨æ„
*/

/* Firebase imports (single import section) */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js";
import {
  getFirestore, collection, doc, addDoc, setDoc, updateDoc, deleteDoc, getDoc,
  onSnapshot, getDocs, runTransaction, writeBatch, serverTimestamp, Timestamp
} from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

/* User-provided Firebase config (same as before) */
const firebaseConfig = {
  apiKey: "AIzaSyBmgtx4FW_3_0zy1MvAvZLPHmE_CE1txuE",
  authDomain: "zzke-ki1.firebaseapp.com",
  databaseURL: "https://zzke-ki1-default-rtdb.firebaseio.com",
  projectId: "zzke-ki1",
  storageBucket: "zzke-ki1.firebasestorage.app",
  messagingSenderId: "260981230516",
  appId: "1:260981230516:web:146a29f15b2716a9af80e1",
  measurementId: "G-GF5G1D4E10"
};

const app = initializeApp(firebaseConfig);
try{ getAnalytics(app); } catch(e){ /* optional */ }
const db = getFirestore(app);

/* Collections & constants */
const GAME_COLLECTION = "games";
const GAME_DOC_ID = "current_round";
const PLAYERS_COL = "players";
const STRAWBERRIES_COL = "strawberries";
const DELIVERIES_COL = "deliveries";

const MAP_SIZE = 2000;
let VISIBILITY_RADIUS = 200;
const PICKUP_RADIUS = 80;
const CAPTURE_RADIUS = 36;
const POSITION_THROTTLE_MS = 160;
const WIN_SCORE = 50;

/* Speeds: previous multipliers kept. Now overall additional 1.8 applied earlier.
   We'll apply requested extra 1.8 multiplier earlier already present; ensure not duplicated.
   For safety we set base then apply overall multiplier once.
*/
const GLOBAL_SPEED_MULT = 1.8; // user requested
const BASE_RUNNER = 2.6;
const BASE_ONI = 2.4;
let RUNNER_SPEED = BASE_RUNNER * GLOBAL_SPEED_MULT;
let ONI_SPEED = BASE_ONI * GLOBAL_SPEED_MULT;

/* Dash: previous was 6x, user requested further x3 -> set DASH_MULT accordingly.
   To avoid compounding ambiguous multipliers, use explicit number requested: "ã•ã‚‰ã«3å€" from current -> we set final DASH_MULT = 18.
   (Careful: this is very fast â€” it's what user asked.)
*/
let DASH_MULT = 18.0;
const DASH_DUR_MS = 3000;
const DASH_CT_MS = 10000;

/* Coop boost */
const COOP_BOOST_DIST = 120;
const COOP_SPEED_MULT = 1.3;

/* Footstep wide range: 5x */
const FOOTSTEP_RANGE_MULT = 5;

/* Admin password */
const ADMIN_PASS = "1122";

/* Straw respawn immediate or random: we'll spawn 4 strawberries and keep them always (when collected we'll teleport) */
const STRAW_COUNT = 4;

/* Client state */
let sessionId = null;
let localPlayer = null;
let allPlayers = [];
let strawberries = [];
let deliveries = [];
let gameDoc = null;
let lastPosSend = 0;
let joinedTeamChoice = null;
let adminMode = false;

/* UI refs */
const screens = { waiting: document.getElementById("screen-waiting"), team: document.getElementById("screen-team"), join: document.getElementById("screen-join"), game: document.getElementById("screen-game") };
const loadingOverlay = document.getElementById("loadingOverlay");
const gameCanvas = document.getElementById("gameCanvas");
const gctx = gameCanvas.getContext("2d");
const miniMap = document.getElementById("miniMap");
const miniCtx = miniMap.getContext("2d");
const boostStatusEl = document.getElementById("boostStatus");

const toTeamBtn = document.getElementById("toTeamBtn");
const chooseOni = document.getElementById("chooseOni");
const chooseRunner = document.getElementById("chooseRunner");
const backFromTeam = document.getElementById("backFromTeam");
const backFromJoin = document.getElementById("backFromJoin");
const joinNow = document.getElementById("joinNow");
const inputName = document.getElementById("inputName");
const leaveBtn = document.getElementById("leaveBtn");
const playerInfoName = document.getElementById("playerInfoName");
const playerInfoTeam = document.getElementById("playerInfoTeam");
const topOni = document.getElementById("topOni");
const topRunner = document.getElementById("topRunner");
const oniCountEl = document.getElementById("oniCount");
const runnerCountEl = document.getElementById("runnerCount");
const oniScoreEl = document.getElementById("oniScore");
const runnerScoreEl = document.getElementById("runnerScore");
const logEl = document.getElementById("log");
const adminSmall = document.getElementById("adminSmall");
const adminResetBtn = document.getElementById("adminReset");
const statusSmall = document.getElementById("statusSmall");
const playerListEl = document.getElementById("playerList");
const homeResetBtn = document.getElementById("homeResetBtn");
const dashStatusEl = document.getElementById("dashStatus");
const waitOniCount = document.getElementById("waitOniCount");
const waitRunnerCount = document.getElementById("waitRunnerCount");
const victoryOverlay = document.getElementById("victoryOverlay");
const victoryPanel = document.getElementById("victoryPanel");

/* audio */
const asiotoAudio = document.getElementById("asioto");
const explosionAudio = document.getElementById("explosion");

/* unsub handles */
let unsubGame = null, unsubPlayers = null, unsubStraw = null, unsubDeliveries = null;

/* asset paths - put PNG files in same folder or edit names here */
const ASSETS = {
  map: "map.png",
  runner: "runner.png",
  oni: "oni.png",
  delivery: "delivery.png",
  strawberry: "strawberry.png"
};
const IMAGES = {};
let assetsLoaded = 0, assetsToLoad = Object.keys(ASSETS).length;
for (const k in ASSETS){
  const img = new Image();
  img.src = ASSETS[k];
  img.onload = ()=> { IMAGES[k] = img; assetsLoaded++; };
  img.onerror = ()=> { IMAGES[k] = null; assetsLoaded++; };
}

/* camera smoothing */
const camera = { x: MAP_SIZE/2, y: MAP_SIZE/2, lerp: 0.18 };

/* utility */
function showScreen(name){ for(const k in screens) screens[k].classList.add("hidden"); screens[name].classList.remove("hidden"); }
function randPosCenterBiased(){
  // bias toward center: sample Gaussian-like by averaging several uniforms
  const bias = () => Math.floor((Math.random()+Math.random()+Math.random())/3 * MAP_SIZE);
  return { x: Math.floor(MAP_SIZE/4 + (MAP_SIZE/2) * Math.random() ), y: Math.floor(MAP_SIZE/4 + (MAP_SIZE/2) * Math.random() ) };
}
function randPos(){ return { x: Math.floor(Math.random()*MAP_SIZE), y: Math.floor(Math.random()*MAP_SIZE) }; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function nowMillis(){ return Date.now(); }
function showLoading(on){ loadingOverlay.style.display = on ? "flex" : "none"; }
function pushLog(text, type="info"){
  const el = document.createElement("div");
  el.className = "logItem " + (type==="event"?"log-event":(type==="error"?"log-error":"log-info"));
  el.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
  logEl.prepend(el);
  setTimeout(()=>{ try{ if (el.parentNode) el.parentNode.removeChild(el); }catch(e){} }, 10000); // auto remove after 10s
  while(logEl.children.length > 200) logEl.removeChild(logEl.lastChild);
}
function updateStatus(s){ statusSmall.textContent = "çŠ¶æ…‹: " + s; }

/* Firestore ensure game doc */
async function ensureGame(){
  const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
  const snap = await getDoc(gRef);
  if (!snap.exists()){
    await setDoc(gRef, { state:"waiting", scores:{ oni:0, runner:0 }, mapSize:MAP_SIZE, createdAt: serverTimestamp() });
  }
}

/* seed deliveries + strawberries */
async function seedMapAndStrawberries(){
  // deliveries: corners
  const dSnap = await getDocs(collection(db, DELIVERIES_COL));
  if (dSnap.size === 0){
    const pts = [
      { x: 80, y: 80 },
      { x: MAP_SIZE-80, y: 80 },
      { x: 80, y: MAP_SIZE-80 },
      { x: MAP_SIZE-80, y: MAP_SIZE-80 }
    ];
    for (const p of pts) await addDoc(collection(db, DELIVERIES_COL), { x: p.x, y: p.y, hasStraw:false, placedBy:"" });
  }
  // strawberries: ensure exactly 4 present
  const sSnap = await getDocs(collection(db, STRAWBERRIES_COL));
  if (sSnap.size === 0){
    for (let i=0;i<STRAW_COUNT;i++){
      const pos = randPosCenterBiased();
      await addDoc(collection(db, STRAWBERRIES_COL), { x: pos.x, y: pos.y, available:true });
    }
  } else {
    // If count differs, normalize to 4: if less create, if more leave as-is
    if (sSnap.size < STRAW_COUNT){
      const need = STRAW_COUNT - sSnap.size;
      for (let i=0;i<need;i++){ const pos = randPosCenterBiased(); await addDoc(collection(db, STRAWBERRIES_COL), { x: pos.x, y: pos.y, available:true }); }
    }
  }
}

/* stable join flow (avoid first-join bug):
   - create player doc
   - setup listeners prior to waiting; wait for snapshot to include created doc
   - only then proceed to game screen
*/
async function joinAs(name, team){
  showLoading(true);
  await ensureGame();
  try {
    // remove previous same-name sessions to avoid duplicates
    try {
      const snaps = await getDocs(collection(db, PLAYERS_COL));
      for (const d of snaps.docs){
        const data = d.data();
        if (data && data.name === name){
          try { await deleteDoc(d.ref); pushLog(`å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼ˆ${name}ï¼‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, "info"); } catch(e) {}
        }
      }
    } catch(e){}

    const pRef = await addDoc(collection(db, PLAYERS_COL), {
      name: name || "Player",
      team,
      x: randPosCenterBiased().x, y: randPosCenterBiased().y,
      possession: 0,
      carrying: "", // id of strawberry if carrying
      lastAction: serverTimestamp(),
      dashReadyAt: 0
    });
    sessionId = pRef.id;

    // setup listeners early (idempotent since we ensure not to double-create)
    setupListeners();

    // wait up to 5s for the players snapshot to include the new doc
    const start = Date.now();
    let ok = false;
    while(Date.now() - start < 5000){
      if (allPlayers.find(p => p._id === sessionId)){ ok = true; break; }
      await new Promise(r => setTimeout(r, 150));
    }
    if (!ok) pushLog("æœ€åˆã®å‚åŠ å‡¦ç†ãŒé…å»¶ã—ã¦ã„ã¾ã™ã€‚æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚", "error");

    // set game to playing if waiting
    try {
      await runTransaction(db, async (t) => {
        const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
        const s = await t.get(gRef);
        if (!s.exists()) throw new Error("game missing");
        const g = s.data();
        if (g.state === "waiting") t.update(gRef, { state: "playing" });
      });
    } catch(e){}

    showLoading(false);
    showScreen("game");
    updateStatus("å‚åŠ ä¸­: " + name + " (" + team + ")");
    pushLog(`${name} ãŒå‚åŠ ã—ã¾ã—ãŸ (ãƒãƒ¼ãƒ : ${team})`, "event");
  } catch(e){
    showLoading(false);
    pushLog("å‚åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ: " + (e.message || e), "error");
    alert("å‚åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
  }
}

/* leave */
async function leave(){
  if (!sessionId) return;
  try { await deleteDoc(doc(db, PLAYERS_COL, sessionId)); } catch(e){}
  sessionId = null; localPlayer = null;
  tearDownListeners();
  showScreen("waiting");
  updateStatus("é›¢è„±ã—ã¾ã—ãŸ");
}

/* listeners (single set, idempotent) */
function setupListeners(){
  if (unsubGame) unsubGame();
  unsubGame = onSnapshot(doc(db, GAME_COLLECTION, GAME_DOC_ID), (snap) => {
    if (!snap.exists()) return;
    gameDoc = snap.data();
    topOni.textContent = gameDoc.scores?.oni || 0;
    topRunner.textContent = gameDoc.scores?.runner || 0;
    oniScoreEl.textContent = gameDoc.scores?.oni || 0;
    runnerScoreEl.textContent = gameDoc.scores?.runner || 0;
    if (gameDoc.state === "waiting"){
      pushLog("ãƒ©ã‚¦ãƒ³ãƒ‰ãŒå¾…æ©ŸçŠ¶æ…‹ã«ãªã‚Šã¾ã—ãŸã€‚", "info");
      showScreen("team");
    }
  });

  if (unsubPlayers) unsubPlayers();
  unsubPlayers = onSnapshot(collection(db, PLAYERS_COL), (snap) => {
    const arr = [];
    snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    allPlayers = arr;
    localPlayer = allPlayers.find(p => p._id === sessionId) || localPlayer;
    const oniCount = allPlayers.filter(p => p.team === "oni").length;
    const runnerCount = allPlayers.filter(p => p.team === "runner").length;
    oniCountEl.textContent = "äººæ•°: " + oniCount;
    runnerCountEl.textContent = "äººæ•°: " + runnerCount;
    waitOniCount.textContent = oniCount;
    waitRunnerCount.textContent = runnerCount;
    if (localPlayer){ playerInfoName.textContent = localPlayer.name; playerInfoTeam.textContent = "ãƒãƒ¼ãƒ : " + localPlayer.team; } else { playerInfoName.textContent = "æœªå‚åŠ "; playerInfoTeam.textContent = "ãƒãƒ¼ãƒ : -"; }
    renderPlayerList();
    // check deliveries placed -> if all have hasStraw true then runners win (in case other client updated)
    checkRunnerWinByDeliveries();
  });

  if (unsubStraw) unsubStraw();
  unsubStraw = onSnapshot(collection(db, STRAWBERRIES_COL), (snap) => {
    const arr = []; snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    strawberries = arr;
    // try collection attempts to avoid miss
    for (const s of strawberries) attemptCollectStraw(s);
  });

  if (unsubDeliveries) unsubDeliveries();
  unsubDeliveries = onSnapshot(collection(db, DELIVERIES_COL), (snap) => {
    const arr = []; snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    deliveries = arr;
    // check runner victory
    checkRunnerWinByDeliveries();
  });
}

function tearDownListeners(){
  if (unsubGame) unsubGame(); unsubGame = null;
  if (unsubPlayers) unsubPlayers(); unsubPlayers = null;
  if (unsubStraw) unsubStraw(); unsubStraw = null;
  if (unsubDeliveries) unsubDeliveries(); unsubDeliveries = null;
  allPlayers = []; strawberries = []; deliveries = []; gameDoc = null;
  renderPlayerList();
}

/* finalize reset */
async function finalizeAndResetRound(){
  try {
    async function delAll(col){
      const snaps = await getDocs(collection(db, col));
      const batch = writeBatch(db);
      let any=false;
      for (const d of snaps.docs){ batch.delete(d.ref); any=true; }
      if (any) await batch.commit();
    }
    await delAll(PLAYERS_COL);
    await delAll(STRAWBERRIES_COL);
    await delAll(DELIVERIES_COL);
    await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { state:"waiting", scores:{oni:0, runner:0}, mapSize:MAP_SIZE, createdAt: serverTimestamp() });
    pushLog("å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ", "event");
  } catch(e){ console.error(e); }
}

/* Helper: check if all deliveries have hasStraw true -> runners win */
async function checkRunnerWinByDeliveries(){
  if (!deliveries || deliveries.length < 4) return;
  const allPlaced = deliveries.every(d => d.hasStraw === true);
  if (allPlaced){
    pushLog("é€ƒã’ãƒãƒ¼ãƒ ãŒ4ã‹æ‰€ã™ã¹ã¦ã«ã‚¤ãƒã‚´ã‚’é…ç½®ã—ã¾ã—ãŸï¼å‹åˆ©ï¼", "event");
    // set game doc state ended and finalize
    try {
      const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
      const gSnap = await getDoc(gRef);
      if (gSnap.exists()){
        const g = gSnap.data();
        await setDoc(gRef, { ...g, state: "ended" });
      }
      await finalizeAndResetRound();
      showVictory("é€ƒã’ãƒãƒ¼ãƒ ã®å‹åˆ©ï¼");
    } catch(e){}
  }
}

/* attemptCollectStraw (standard + boosted-pair rule + carrying feature handled separately)
   - If >=2 runners within PICKUP_RADIUS and neither is carrying, increment possession for each and teleport strawberry
*/
async function attemptCollectStraw(straw){
  if (!straw || !straw.available) return;
  const nearby = allPlayers.filter(p => p.team === "runner" && Math.hypot(p.x - straw.x, p.y - straw.y) <= PICKUP_RADIUS);
  if (nearby.length < 2) return;
  try {
    await runTransaction(db, async (t) => {
      const sRef = doc(db, STRAWBERRIES_COL, straw._id);
      const sSnap = await t.get(sRef);
      if (!sSnap.exists()) throw new Error("straw missing");
      const sData = sSnap.data();
      if (!sData.available) throw new Error("already collected");
      t.update(sRef, { available: false });
      for (const p of nearby){
        const pRef = doc(db, PLAYERS_COL, p._id);
        const pSnap = await t.get(pRef);
        if (!pSnap.exists()) continue;
        const cur = pSnap.data().possession || 0;
        t.update(pRef, { possession: cur + 1, lastAction: serverTimestamp() });
      }
    });
    pushLog(`ã‚¤ãƒã‚´å›å: ${nearby.map(n=>n.name).join(", ")}`, "event");
    // teleport strawberry to new center-biased position and mark available
    const newPos = randPosCenterBiased();
    try { await updateDoc(doc(db, STRAWBERRIES_COL, straw._id), { x: newPos.x, y: newPos.y, available: true }); } catch(e){}
  } catch(e){}
}

/* Carrying logic: runner holds shift near an available strawberry -> start carrying
   Player doc field 'carrying' stores strawId while carrying (string or "")
   While carrying:
   - player's movement speed *= 0.2
   - if near delivery and still holding shift -> place strawberry on that delivery (set delivery.hasStraw = true)
*/
async function tryStartCarryingIfPossible(player){
  if (!player || player.team !== "runner") return;
  if (player.carrying) return; // already carrying
  // find nearby available strawberry
  const straw = strawberries.find(s => s.available && Math.hypot(s.x - player.x, s.y - player.y) <= PICKUP_RADIUS);
  if (!straw) return;
  // mark carrying in transaction
  try {
    await runTransaction(db, async (t) => {
      const sRef = doc(db, STRAWBERRIES_COL, straw._id);
      const sSnap = await t.get(sRef);
      if (!sSnap.exists()) throw new Error("straw missing");
      const sData = sSnap.data();
      if (!sData.available) throw new Error("already taken");
      t.update(sRef, { available: false });
      const pRef = doc(db, PLAYERS_COL, player._id);
      t.update(pRef, { carrying: straw._id, lastAction: serverTimestamp() });
    });
    pushLog(`${player.name} ãŒã‚¤ãƒã‚´ã‚’æ´ã¿ã¾ã—ãŸ`, "event");
  } catch(e){}
}

async function tryPlaceCarryingOnDelivery(player){
  if (!player || player.team !== "runner") return;
  const strawId = player.carrying || "";
  if (!strawId) return;
  // find delivery under player
  const del = deliveries.find(d => Math.hypot(d.x - player.x, d.y - player.y) <= PICKUP_RADIUS);
  if (!del) return;
  // if delivery already has straw, cannot place
  if (del.hasStraw) {
    // drop the strawberry nearby instead: teleport strawberry to a nearby spot and clear carrying
    try {
      await updateDoc(doc(db, STRAWBERRIES_COL, strawId), { x: Math.min(MAP_SIZE-40, Math.max(40, player.x+30)), y: Math.min(MAP_SIZE-40, Math.max(40, player.y+30)), available: true });
      await updateDoc(doc(db, PLAYERS_COL, player._id), { carrying: "", lastAction: serverTimestamp() });
      pushLog(`${player.name} ã®é…ç½®å¤±æ•—ï¼ˆãã®ç´å“æ‰€ã¯æ—¢ã«ã‚¤ãƒã‚´ã‚ã‚Šï¼‰`, "info");
    } catch(e){}
    return;
  }
  // place strawberry at delivery
  try {
    await runTransaction(db, async (t) => {
      const delRef = doc(db, DELIVERIES_COL, del._id);
      const delSnap = await t.get(delRef);
      if (!delSnap.exists()) throw new Error("delivery missing");
      const dData = delSnap.data();
      if (dData.hasStraw) throw new Error("already placed");
      t.update(delRef, { hasStraw: true, placedBy: player.name });
      // update player
      const pRef = doc(db, PLAYERS_COL, player._id);
      t.update(pRef, { carrying: "", lastAction: serverTimestamp() });
      // mark strawberry doc as placedAt delivery (or delete)
      const sRef = doc(db, STRAWBERRIES_COL, strawId);
      t.update(sRef, { available: false, placedAt: del._id });
    });
    pushLog(`${player.name} ãŒç´å“æ‰€ã«ã‚¤ãƒã‚´ã‚’é…ç½®ã—ã¾ã—ãŸ: ${del._id}`, "event");
    // check runner victory
    await checkRunnerWinByDeliveries();
  } catch(e){}
}

/* capture handling */
async function checkCapturesAndHandle(){
  const onis = allPlayers.filter(p => p.team === "oni");
  const runners = allPlayers.filter(p => p.team === "runner");
  if (onis.length === 0 || runners.length === 0) return;
  for (const r of runners){
    for (const o of onis){
      const d = Math.hypot(r.x - o.x, r.y - o.y);
      if (d <= CAPTURE_RADIUS){
        try {
          await updateDoc(doc(db, PLAYERS_COL, r._id), { possession:0, carrying:"", x: randPos().x, y: randPos().y, lastAction: serverTimestamp() });
          await runTransaction(db, async (t) => {
            const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
            const s = await t.get(gRef);
            if (!s.exists()) return;
            const g = s.data();
            const scores = g.scores || { oni:0, runner:0 };
            scores.oni = (scores.oni || 0) + 5;
            t.update(gRef, { scores, lastUpdated: serverTimestamp() });
          });
          pushLog(`${r.name} ãŒæ•ã¾ã£ãŸï¼ é¬¼ãƒãƒ¼ãƒ  +5`, "event");
          explosionAudio.currentTime = 0; explosionAudio.play().catch(()=>{});
          const gSnap2 = await getDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID));
          if (gSnap2.exists()){
            const g2 = gSnap2.data();
            if ((g2.scores?.oni || 0) >= WIN_SCORE){
              pushLog("é¬¼ãƒãƒ¼ãƒ ãŒå‹åˆ©ï¼", "event");
              await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { ...g2, state: "ended" });
              await finalizeAndResetRound();
              showVictory("é¬¼ãƒãƒ¼ãƒ ã®å‹åˆ©ï¼");
            }
          }
        } catch(e){}
        break;
      }
    }
  }
}

/* position update throttled */
async function sendPositionIfNeeded(x,y){
  if (!sessionId) return;
  const now = nowMillis();
  if (now - lastPosSend < POSITION_THROTTLE_MS) return;
  lastPosSend = now;
  try { await updateDoc(doc(db, PLAYERS_COL, sessionId), { x, y, lastAction: serverTimestamp() }); } catch(e){}
}

/* dash handling */
function canDash(p){ if (!p || p.team !== "oni") return false; const readyAt = p.dashReadyAt || 0; return Date.now() >= readyAt; }
async function startDash(){
  if (!localPlayer || localPlayer.team !== "oni") return;
  const now = Date.now();
  try {
    await updateDoc(doc(db, PLAYERS_COL, sessionId), { dashReadyAt: now + DASH_CT_MS });
    localPlayer._isDashingUntil = now + DASH_DUR_MS;
    setTimeout(()=>{ if (localPlayer) localPlayer._isDashingUntil = 0; }, DASH_DUR_MS);
  } catch(e){}
}

/* render helpers & assets drawing */
const IM = IMAGES; // alias
function drawImageOrShape(ctx, key, x, y, size){
  const img = IM[key];
  if (img){
    ctx.drawImage(img, x - size/2, y - size/2, size, size);
  } else {
    // fallback shapes
    if (key === 'runner'){ ctx.fillStyle = "#4db8ff"; ctx.beginPath(); ctx.arc(x,y,size/2,0,Math.PI*2); ctx.fill(); }
    if (key === 'oni'){ ctx.fillStyle = "#ffcf4d"; ctx.fillRect(x-size/2,y-size/2,size,size); }
    if (key === 'delivery'){ ctx.fillStyle = "#ffd39a"; ctx.beginPath(); ctx.moveTo(x,y-size/2); ctx.lineTo(x-size/2,y+size/2); ctx.lineTo(x+size/2,y+size/2); ctx.closePath(); ctx.fill(); }
    if (key === 'strawberry'){ ctx.fillStyle = "#ff6b8a"; ctx.beginPath(); ctx.arc(x,y,size/3,0,Math.PI*2); ctx.fill(); }
    if (key === 'map'){ ctx.fillStyle = "#081018"; ctx.fillRect(0,0,gameCanvas.width,gameCanvas.height); }
  }
}

/* draw world with camera lerp */
function drawWorld(ctx, width, height, centerPlayer, applyVisibility){
  ctx.clearRect(0,0,width,height);
  // target camera center & clamp
  let targetX = centerPlayer ? centerPlayer.x : MAP_SIZE/2;
  let targetY = centerPlayer ? centerPlayer.y : MAP_SIZE/2;
  const halfW = width/2, halfH = height/2;
  targetX = clamp(targetX, halfW, MAP_SIZE - halfW);
  targetY = clamp(targetY, halfH, MAP_SIZE - halfH);
  camera.x += (targetX - camera.x) * camera.lerp;
  camera.y += (targetY - camera.y) * camera.lerp;
  const toScreenX = (mx) => (mx - (camera.x - halfW));
  const toScreenY = (my) => (my - (camera.y - halfH));

  // draw map background or image
  if (IM['map']) {
    const scaleX = width / MAP_SIZE, scaleY = height / MAP_SIZE;
    ctx.drawImage(IM['map'], (-(camera.x - halfW))*scaleX, (-(camera.y - halfH))*scaleY, MAP_SIZE*scaleX, MAP_SIZE*scaleY);
  } else {
    ctx.fillStyle = "#081018"; ctx.fillRect(0,0,width,height);
  }

  // deliveries (â–³) w/ label
  for (const d of deliveries){
    const sx = toScreenX(d.x), sy = toScreenY(d.y);
    drawImageOrShape(ctx, 'delivery', sx, sy, 28);
    drawTextBubble(ctx, d.hasStraw ? "â–³ ç´å“æ‰€ (ç½®ã‹ã‚ŒãŸ)" : "â–³ ç´å“æ‰€", sx, sy - 26, "#ffd39a");
  }

  // strawberries (ãƒ»)
  for (const s of strawberries){
    // if placedAt delivery, skip (draw indicator on delivery)
    if (s.placedAt) continue;
    const sx = toScreenX(s.x), sy = toScreenY(s.y);
    let visible = true;
    if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
      visible = Math.hypot(centerPlayer.x - s.x, centerPlayer.y - s.y) <= VISIBILITY_RADIUS;
    }
    if (!visible) continue;
    drawImageOrShape(ctx, 'strawberry', sx, sy, 18);
    const runnersNear = allPlayers.filter(p => p.team === "runner" && Math.hypot(p.x - s.x, p.y - s.y) <= PICKUP_RADIUS);
    if (runnersNear.length === 1){
      ctx.strokeStyle = "rgba(255,255,128,0.9)"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(sx, sy, 14,0,Math.PI*2); ctx.stroke(); ctx.lineWidth=1;
    }
  }

  // players
  for (const p of allPlayers){
    let visible = true;
    if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
      if (p._id === centerPlayer._id) visible = true;
      else visible = (Math.hypot(centerPlayer.x - p.x, centerPlayer.y - p.y) <= VISIBILITY_RADIUS);
    }
    if (!visible) continue;
    const sx = toScreenX(p.x), sy = toScreenY(p.y);
    drawImageOrShape(ctx, p.team === "runner" ? 'runner' : 'oni', sx, sy, 28);
    // show carrying status
    if (p.carrying){
      drawTextBubble(ctx, "æŒã¡é‹ã³ä¸­", sx, sy - 36, "#0b4f32");
    }
    drawTextBubble(ctx, p.name, sx, sy + 20, "#000", true);
  }

  // runner darkness overlay
  if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.beginPath(); ctx.rect(0,0,width,height); ctx.arc(width/2, height/2, VISIBILITY_RADIUS,0,Math.PI*2,true);
    try{ ctx.fill('evenodd'); }catch(e){ ctx.globalCompositeOperation='destination-out'; ctx.fill(); ctx.globalCompositeOperation='source-over'; }
    ctx.restore();
  }

  // nearest teammate hint
  if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
    const others = allPlayers.filter(p => p.team === "runner" && p._id !== centerPlayer._id);
    if (others.length > 0){
      others.sort((a,b)=> Math.hypot(a.x-centerPlayer.x,a.y-centerPlayer.y) - Math.hypot(b.x-centerPlayer.x,b.y-centerPlayer.y));
      const near = others[0]; drawDirectionHint(ctx, near, centerPlayer, width, height);
    }
  }
}

/* drawMiniMap */
function drawMiniMap(){
  miniCtx.clearRect(0,0,miniMap.width,miniMap.height);
  const w = miniMap.width, h = miniMap.height;
  miniCtx.fillStyle = "#041218"; miniCtx.fillRect(0,0,w,h);
  if (IM['map']) miniCtx.drawImage(IM['map'],0,0,w,h);
  // deliveries
  for (const d of deliveries){ const sx = d.x / MAP_SIZE * w, sy = d.y / MAP_SIZE * h; miniCtx.fillStyle="#ffd39a"; miniCtx.beginPath(); miniCtx.moveTo(sx,sy-6); miniCtx.lineTo(sx-6,sy+6); miniCtx.lineTo(sx+6,sy+6); miniCtx.closePath(); miniCtx.fill(); }
  // strawberries
  for (const s of strawberries){ if (s.placedAt) continue; const sx = s.x / MAP_SIZE * w, sy = s.y / MAP_SIZE * h; miniCtx.fillStyle = s.available ? "#ff6b8a" : "#5a2a2f"; miniCtx.beginPath(); miniCtx.arc(sx,sy,3,0,Math.PI*2); miniCtx.fill(); }
  // players
  for (const p of allPlayers){ const sx = p.x / MAP_SIZE * w, sy = p.y / MAP_SIZE * h; miniCtx.fillStyle = p.team === "oni" ? "#ffcf4d" : "#4db8ff"; miniCtx.beginPath(); miniCtx.arc(sx,sy,3,0,Math.PI*2); miniCtx.fill(); }
  miniCtx.strokeStyle = "rgba(255,255,255,0.06)"; miniCtx.strokeRect(0,0,w,h);
}

/* drawing helper: bubble text */
function drawTextBubble(ctx, text, x, y, bg="#000", small=false){
  ctx.save();
  ctx.font = (small ? "12px sans-serif" : "13px sans-serif");
  const metrics = ctx.measureText(text);
  const padX = 8, h = 18;
  const w = metrics.width + padX*2;
  const bx = x - w/2, by = y - h/2;
  ctx.fillStyle = bg;
  const r = 8;
  ctx.beginPath();
  ctx.moveTo(bx+r, by);
  ctx.arcTo(bx+w, by, bx+w, by+h, r);
  ctx.arcTo(bx+w, by+h, bx, by+h, r);
  ctx.arcTo(bx, by+h, bx, by, r);
  ctx.arcTo(bx, by, bx+w, by, r);
  ctx.closePath(); ctx.fill();
  ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
  ctx.fillText(text, x, y);
  ctx.restore();
}

/* direction hint */
function drawDirectionHint(ctx, target, self, width, height){
  const dx = target.x - self.x, dy = target.y - self.y;
  const angle = Math.atan2(dy, dx);
  const cx = width/2, cy = height/2;
  const edgeX = cx + Math.cos(angle) * (Math.min(width,height)/2 - 30);
  const edgeY = cy + Math.sin(angle) * (Math.min(width,height)/2 - 30);
  ctx.save(); ctx.translate(edgeX, edgeY); ctx.rotate(angle);
  ctx.fillStyle = "#ff8"; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-10,-6); ctx.lineTo(-10,6); ctx.closePath(); ctx.fill();
  const dist = Math.round(Math.hypot(dx,dy));
  drawTextBubble(ctx, `${target.name} (${dist}m)`, edgeX + 18, edgeY, "#222", true);
  ctx.restore();
}

/* Render loop with smoothing */
function renderLoop(){
  requestAnimationFrame(renderLoop);
  drawWorld(gctx, gameCanvas.width, gameCanvas.height, localPlayer, true);
  drawMiniMap();
  updateDashStatusUI();
  updateBoostUI();
}
renderLoop();

/* input handling (robust for long-press) */
const pressed = new Set();
let lastKeyEventTime = Date.now();
window.addEventListener('keydown', (e)=>{ const k = e.key.toLowerCase(); if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){ e.preventDefault(); lastKeyEventTime = Date.now(); pressed.add(k); }});
window.addEventListener('keyup', (e)=>{ const k = e.key.toLowerCase(); if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){ e.preventDefault(); lastKeyEventTime = Date.now(); pressed.delete(k); }});
window.addEventListener('blur', ()=>{ pressed.clear(); });
setInterval(()=>{ if (Date.now() - lastKeyEventTime > 1000) pressed.clear(); }, 1200);

/* movement tick with carrying behavior:
   - if runner and holding shift and near strawberry -> start carrying
   - while carrying (player.carrying truthy) movement speed *= 0.2
   - if carrying and near delivery and still holding shift -> place
*/
setInterval(async ()=>{
  if (!localPlayer || !sessionId) return;
  let sp = localPlayer.team === "oni" ? ONI_SPEED : RUNNER_SPEED;
  // dash trigger for oni
  if (localPlayer.team === "oni" && (pressed.has("shift")) && canDash(localPlayer)){
    await startDash();
  }
  if (localPlayer._isDashingUntil && Date.now() < localPlayer._isDashingUntil) sp *= DASH_MULT;
  // coop boost
  if (localPlayer.team === "runner"){
    const nearby = allPlayers.filter(p => p._id !== localPlayer._id && p.team === "runner" && Math.hypot(p.x - localPlayer.x, p.y - localPlayer.y) <= COOP_BOOST_DIST);
    if (nearby.length >= 1) sp *= COOP_SPEED_MULT;
  }
  // carrying slows to 0.2x
  const carrying = localPlayer.carrying && localPlayer.carrying.length > 0;
  if (carrying) sp *= 0.2;

  // movement delta
  let dx=0, dy=0;
  if (pressed.has("a") || pressed.has("arrowleft")) dx -= 1;
  if (pressed.has("d") || pressed.has("arrowright")) dx += 1;
  if (pressed.has("w") || pressed.has("arrowup")) dy -= 1;
  if (pressed.has("s") || pressed.has("arrowdown")) dy += 1;
  if (dx === 0 && dy === 0){
    // if holding shift and runner & near strawberry -> try start carrying
    if (pressed.has("shift") && localPlayer.team === "runner"){
      await tryStartCarryingIfPossible(localPlayer);
      // if carrying and still holding shift and near delivery -> try place
      if (localPlayer.carrying) await tryPlaceCarryingOnDelivery(localPlayer);
    }
    return;
  }
  const mag = Math.hypot(dx,dy) || 1;
  dx = dx/mag * sp; dy = dy/mag * sp;
  const nx = clamp(localPlayer.x + dx, 0, MAP_SIZE);
  const ny = clamp(localPlayer.y + dy, 0, MAP_SIZE);
  localPlayer.x = nx; localPlayer.y = ny;
  await sendPositionIfNeeded(nx, ny);
  // while moving, if holding shift and runner attempt pickup or place
  if (pressed.has("shift") && localPlayer.team === "runner"){
    if (!localPlayer.carrying) await tryStartCarryingIfPossible(localPlayer);
    else await tryPlaceCarryingOnDelivery(localPlayer);
  }
  for (const s of strawberries) await attemptCollectStraw(s);
  await checkCapturesAndHandle();
}, 100);

/* footstep sound: runners hear if oni within expanded range (5x) */
setInterval(()=>{
  if (!localPlayer) return;
  if (localPlayer.team === "runner"){
    const onis = allPlayers.filter(p => p.team === "oni");
    for (const o of onis){
      const d = Math.hypot(o.x - localPlayer.x, o.y - localPlayer.y);
      if (d <= VISIBILITY_RADIUS * FOOTSTEP_RANGE_MULT){
        asiotoAudio.currentTime = 0; asiotoAudio.play().catch(()=>{});
        break;
      }
    }
  }
}, 900);

/* periodic checks to keep responsiveness */
setInterval(async ()=>{
  for (const s of strawberries) attemptCollectStraw(s);
  await checkCapturesAndHandle();
}, 1200);

/* player list rendering with admin kick & coords */
function renderPlayerList(){
  playerListEl.innerHTML = "";
  const sorted = allPlayers.slice().sort((a,b)=> a.team.localeCompare(b.team) || (a.name||"").localeCompare(b.name));
  for (const p of sorted){
    const row = document.createElement("div"); row.className = "playerRow";
    const left = document.createElement("div"); left.style.display="flex"; left.style.gap="8px"; left.style.alignItems="center";
    const shape = document.createElement("div"); shape.style.width="14px"; shape.style.height="14px"; shape.style.borderRadius = p.team==="runner"?"50%":"3px"; shape.style.background = p.team==="runner"?"#4db8ff":"#ffd54d";
    left.appendChild(shape);
    const info = document.createElement("div"); info.innerHTML = `<div style="font-weight:700">${p.name}</div><div class="small">${p.team}</div>`; left.appendChild(info);
    row.appendChild(left);
    const right = document.createElement("div"); right.style.textAlign="right";
    const coords = adminMode ? `<div class="small" style="color:#9fb8c8">${Math.round(p.x)},${Math.round(p.y)}</div>` : "";
    right.innerHTML = `<div style="font-weight:700">${p.possession||0}ğŸ“</div>${coords}`;
    if (adminMode){
      const kick = document.createElement("button"); kick.className="kickBtn"; kick.textContent="é€€å‡º";
      kick.onclick = async ()=>{ if (!confirm(`${p.name} ã‚’å¼·åˆ¶é€€å‡ºã•ã›ã¾ã™ã‹ï¼Ÿ`)) return; try { await deleteDoc(doc(db, PLAYERS_COL, p._id)); pushLog(`${p.name} ã‚’ç®¡ç†è€…ãŒé€€å‡ºã•ã›ã¾ã—ãŸ`, "event"); } catch(e){ alert("é€€å‡ºã«å¤±æ•—ã—ã¾ã—ãŸ"); } };
      right.appendChild(kick);
    }
    row.appendChild(right);
    playerListEl.appendChild(row);
  }
}

/* update dash UI */
function updateDashStatusUI(){
  if (!localPlayer){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: -"; return; }
  if (localPlayer.team !== "oni"){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: (é¬¼ã®ã¿)"; return; }
  const readyAt = localPlayer.dashReadyAt || 0;
  const now = Date.now();
  if (now >= readyAt) dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨å¯èƒ½";
  else dashStatusEl.textContent = `ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨ä¸å¯ æ®‹ã‚Š ${Math.ceil((readyAt-now)/1000)}s`;
}

/* boost UI */
function updateBoostUI(){
  if (!localPlayer){ boostStatusEl.textContent = ""; return; }
  if (localPlayer.team === "runner"){
    const nearby = allPlayers.filter(p => p._id !== localPlayer._id && p.team === "runner" && Math.hypot(p.x - localPlayer.x, p.y - localPlayer.y) <= COOP_BOOST_DIST);
    if (nearby.length >= 1){ boostStatusEl.textContent = "ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ–ãƒ¼ã‚¹ãƒˆä¸­ï¼ˆè¿‘ãã«ä»²é–“ï¼‰"; boostStatusEl.style.background = "linear-gradient(90deg,#7fffd4,#2ee6b6)"; }
    else { boostStatusEl.textContent = ""; boostStatusEl.style.background = "linear-gradient(180deg,#06281f,#0b3940)"; }
  } else boostStatusEl.textContent = "";
}

/* show victory overlay */
function showVictory(text){
  victoryPanel.textContent = text;
  victoryOverlay.style.display = "flex";
  setTimeout(()=>{ victoryOverlay.style.display = "none"; }, 4000);
}

/* UI hooks */
toTeamBtn.addEventListener('click', ()=> showScreen("team"));
chooseOni.addEventListener('click', ()=>{ joinedTeamChoice = "oni"; showScreen("join"); });
chooseRunner.addEventListener('click', ()=>{ joinedTeamChoice = "runner"; showScreen("join"); });
backFromTeam.addEventListener('click', ()=> showScreen("waiting"));
backFromJoin.addEventListener('click', ()=> showScreen("team"));
joinNow.addEventListener('click', async ()=>{
  const name = (inputName.value||"").trim();
  if (!name) return alert("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
  if (!joinedTeamChoice) return alert("ãƒãƒ¼ãƒ é¸æŠã—ã¦ãã ã•ã„");
  await joinAs(name, joinedTeamChoice);
  joinedTeamChoice = null; inputName.value = "";
});
leaveBtn.addEventListener('click', ()=> leave());
adminSmall.addEventListener('click', async ()=> {
  const pass = prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰:"); if (pass === ADMIN_PASS){ adminMode = true; adminResetBtn.classList.remove("hidden"); alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹"); renderPlayerList(); } else alert("ä¸æ­£ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰");
});
adminResetBtn.addEventListener('click', async ()=> { if (!adminMode) return alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ãŒå¿…è¦"); if (!confirm("å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ã—ã¾ã™ï¿½ï¿½ï¼Ÿ")) return; await finalizeAndResetRound(); });
homeResetBtn.addEventListener('click', async ()=> { const pass = prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰:"); if (pass === ADMIN_PASS) await finalizeAndResetRound(); else alert("é•ã†"); });

/* boot */
(async function boot(){
  await ensureGame();
  await seedMapAndStrawberries();
  showScreen("waiting");
  updateStatus("å¾…æ©Ÿä¸­");
})();

/* periodic win check (scores) */
setInterval(async ()=>{
  try {
    const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
    const gSnap = await getDoc(gRef);
    if (!gSnap.exists()) return;
    const g = gSnap.data();
    const scores = g.scores || { oni:0, runner:0 };
    if (g.state === "playing" && (scores.oni >= WIN_SCORE || scores.runner >= WIN_SCORE)){
      pushLog("ã‚¹ã‚³ã‚¢åˆ°é”ã«ã‚ˆã‚Šãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†", "event");
      await setDoc(gRef, { ...g, state: "ended" });
      if ((scores.oni || 0) >= WIN_SCORE) showVictory("é¬¼ãƒãƒ¼ãƒ ã®å‹åˆ©ï¼");
      else showVictory("é€ƒã’ãƒãƒ¼ãƒ ã®å‹åˆ©ï¼");
      await finalizeAndResetRound();
    }
  } catch(e){}
}, 3000);

/* periodic responsiveness */
setInterval(async ()=>{ for (const s of strawberries) attemptCollectStraw(s); await checkCapturesAndHandle(); }, 1200);

/* End of code */
</script>
</body>
</html>
