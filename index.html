
<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤åŸºç›¤ - å®Œå…¨ç‰ˆï¼ˆä¿®æ­£ç‰ˆï¼‰</title>
<style>
  :root{
    --bg:#0d0f12; --panel:#111317; --oni:#ffcf4d; --runner:#4db8ff; --muted:#9aa3ad;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui, "Hiragino Kaku Gothic ProN","ãƒ¡ã‚¤ãƒªã‚ª",sans-serif;background:var(--bg);color:#e6eef6}
  #app{display:flex;gap:12px;padding:12px}
  #left{flex:1;display:flex;flex-direction:column;gap:12px}
  #right{width:380px;background:linear-gradient(180deg,#0b0d10,#0f1113);padding:14px;border-radius:10px}
  canvas{border-radius:8px;background:#081018;display:block}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:8px}
  h2{margin:4px 0 8px}
  .small{font-size:0.85rem;color:var(--muted)}
  .big{font-size:1.05rem;padding:10px 14px;border-radius:10px}
  .teamBtn{display:flex;justify-content:space-between;align-items:center;padding:14px;border-radius:10px;border:none;cursor:pointer}
  .oniBtn{background:linear-gradient(90deg,#ffecb3,#ffd54d);color:#111}
  .runnerBtn{background:linear-gradient(90deg,#bfe8ff,#4db8ff);color:#022033}
  #log{max-height:140px;overflow:auto}
  .logItem{margin-bottom:8px;padding:8px;border-radius:8px}
  .log-info{background:rgba(255,255,255,0.02)}
  .log-event{background:rgba(255,215,170,0.06)}
  .log-error{background:rgba(255,80,80,0.06)}
  .playerRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:6px;background:rgba(255,255,255,0.02);margin-bottom:6px}
  .kickBtn{padding:6px 8px;border-radius:6px;background:#ff6b6b;border:none;color:#111;cursor:pointer}
  #loadingOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;color:#fff;font-size:1.1rem;z-index:9999}
  #boostStatus{margin-top:8px;font-weight:700;color:#bfffbf;text-align:center;min-height:22px}
  #dashStatus{font-weight:700;color:#ffd;margin-left:10px}
</style>
</head>
<body>
<div id="loadingOverlay">å‡¦ç†ä¸­... å°‘ã—ãŠå¾…ã¡ãã ã•ã„</div>
<div id="app">
  <div id="left">
    <div id="screen-waiting" class="panel">
      <h2>å¾…æ©Ÿ / ãƒ«ãƒ¼ãƒ«</h2>
      <p class="small">å‚åŠ ã™ã‚‹ã‚’æŠ¼ã™ã¨ãƒãƒ¼ãƒ é¸æŠã¸ã€‚ç®¡ç†ã¯å³ä¸Šã®ã€Œç®¡ç†ã€ã‹ã‚‰å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆå¯èƒ½ã€‚</p>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="toTeamBtn" class="big">å‚åŠ ã™ã‚‹</button>
        <button id="homeResetBtn" class="big">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
      <div style="margin-top:12px" class="small">
1ãƒ©ã‚¦ãƒ³ãƒ‰åˆ¶ãƒ»é€”ä¸­å‚åŠ å¯ãƒ»ã‚¢ã‚«ã‚¦ãƒ³ãƒˆä¸è¦ã€‚
é¬¼ (â–¢) ã¯å…¨ä½“å¯è¦–ã€‚Shiftã§ãƒ€ãƒƒã‚·ãƒ¥ï¼ˆ3ç§’ã€CT10ç§’ï¼‰ã€‚
é€ƒã’ (ã€‡) ã¯è‡ªåˆ†ä¸­å¿ƒã®è¦–ç•Œã€‚ã‚¤ãƒã‚´(ãƒ»)ã¯2äººæƒã†ã¨å›åï¼ˆå„+1ï¼‰ã€‚
ç´å“æ‰€(â–³) ã«è¿‘ã¥ãã¨æ‰€æŒãŒãƒãƒ¼ãƒ ã‚¹ã‚³ã‚¢ã«å¤‰æ›ã•ã‚Œ0ã«ãªã‚‹ã€‚
é¬¼ãŒæ•ã¾ãˆã‚‹ã¨é¬¼ãƒãƒ¼ãƒ  +5ç‚¹ã€‚å…ˆã«50ç‚¹é”æˆã§å³å‹åˆ©ãƒ»ãƒªã‚»ãƒƒãƒˆã€‚
      </div>
      <div style="margin-top:8px" class="small">é¬¼: <span id="waitOniCount">0</span> / é€ƒã’: <span id="waitRunnerCount">0</span></div>
    </div>

    <div id="screen-team" class="panel hidden">
      <h2>ãƒãƒ¼ãƒ ã‚’é¸ã‚“ã§ãã ã•ã„</h2>
      <div style="display:flex;gap:12px">
        <button id="chooseOni" class="teamBtn oniBtn">
          <div><div style="font-weight:700">ğŸ‘¹ é¬¼</div><div class="small" id="oniCount">äººæ•°: 0</div></div>
          <div class="small">ã‚¹ã‚³ã‚¢: <span id="oniScore">0</span></div>
        </button>
        <button id="chooseRunner" class="teamBtn runnerBtn">
          <div><div style="font-weight:700">ğŸƒ é€ƒã’</div><div class="small" id="runnerCount">äººæ•°: 0</div></div>
          <div class="small">ã‚¹ã‚³ã‚¢: <span id="runnerScore">0</span></div>
        </button>
      </div>
      <div style="margin-top:12px;text-align:center"><button id="backFromTeam">æˆ»ã‚‹</button></div>
    </div>

    <div id="screen-join" class="panel hidden">
      <h2>åå‰ã‚’å…¥åŠ›ã—ã¦å‚åŠ </h2>
      <div style="display:flex;gap:8px;align-items:center;justify-content:center">
        <input id="inputName" class="nameInput" placeholder="åå‰" maxlength="16" style="padding:8px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;width:220px">
        <button id="joinNow" class="big">å‚åŠ </button>
      </div>
      <div style="text-align:center;margin-top:8px"><button id="backFromJoin">æˆ»ã‚‹</button></div>
    </div>

    <div id="screen-game" class="panel hidden">
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <div style="display:flex;gap:12px">
          <div style="background:linear-gradient(90deg,#ffefd5,#fff1cc);padding:8px 12px;border-radius:8px;color:#1a1200;font-weight:700">ğŸ‘¹ é¬¼: <span id="topOni">0</span></div>
          <div style="background:linear-gradient(90deg,#dff4ff,#d6f0ff);padding:8px 12px;border-radius:8px;color:#022033;font-weight:700">ğŸƒ é€ƒã’: <span id="topRunner">0</span></div>
        </div>
        <div style="display:flex;align-items:center;gap:8px">
          <div id="dashStatus">ãƒ€ãƒƒã‚·ãƒ¥: -</div>
          <button id="leaveBtn">é›¢è„±</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <canvas id="gameCanvas" width="1200" height="640"></canvas>
        <div id="boostStatus" class="panel" style="margin-top:8px;background:linear-gradient(90deg,#06281f,#0b3940)"></div>
      </div>
    </div>
  </div>

  <div id="right">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><div id="playerInfoName" style="font-weight:700">æœªå‚åŠ </div><div class="small" id="playerInfoTeam">ãƒãƒ¼ãƒ : -</div></div>
        <div class="small">æ”¾ç½®: <span id="idleCount">0</span>s</div>
      </div>
    </div>

    <div class="panel" style="height:40vh;overflow:auto">
      <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</div><div class="small">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ </div></div>
      <div id="playerList" style="margin-top:8px"></div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°</div><div class="small">10ç§’ã§æ¶ˆå»</div>
      </div>
      <div id="log" style="margin-top:8px"></div>
      <div style="display:flex;gap:8px;align-items:center;margin-top:8px"><button id="adminReset" class="hidden">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button><div class="small" id="statusSmall">çŠ¶æ…‹: åˆæœŸ</div></div>
      <div style="margin-top:12px"><canvas id="miniMap" class="minimap" width="340" height="140"></canvas><div class="small">map.png ã‚’é…ç½®ã™ã‚‹ã¨èƒŒæ™¯åæ˜ </div></div>
    </div>
  </div>
</div>

<!-- audio files -->
<audio id="asioto" src="asioto.mp3" preload="auto"></audio>
<audio id="explosion" src="explosion.mp3" preload="auto"></audio>

<script type="module">
/* Firebase SDKs */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js";
import {
  getFirestore, collection, doc, addDoc, setDoc, updateDoc, deleteDoc, getDoc,
  onSnapshot, getDocs, runTransaction, writeBatch, serverTimestamp, Timestamp
} from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

/* ========== Firebase config ========== */
const firebaseConfig = {
  apiKey: "AIzaSyBmgtx4FW_3_0zy1MvAvZLPHmE_CE1txuE",
  authDomain: "zzke-ki1.firebaseapp.com",
  databaseURL: "https://zzke-ki1-default-rtdb.firebaseio.com",
  projectId: "zzke-ki1",
  storageBucket: "zzke-ki1.firebasestorage.app",
  messagingSenderId: "260981230516",
  appId: "1:260981230516:web:146a29f15b2716a9af80e1",
  measurementId: "G-GF5G1D4E10"
};

const app = initializeApp(firebaseConfig);
try{ getAnalytics(app); } catch(e){ /* ignore */ }
const db = getFirestore(app);

/* ========== Constants ========== */
const GAME_COLLECTION = "games";
const GAME_DOC_ID = "current_round";
const PLAYERS_COL = "players";
const STRAWBERRIES_COL = "strawberries";
const DELIVERIES_COL = "deliveries";

const MAP_SIZE = 2000;
const VISIBILITY_RADIUS = 200;
const PICKUP_RADIUS = 80;
const CAPTURE_RADIUS = 36;
const POSITION_THROTTLE_MS = 200;
const WIN_SCORE = 50;

/* Base speeds multiplied by prior requests then final 1.8x */
let RUNNER_SPEED = 2.6 * 1.5 * 1.8; // base 2.6 * prev1.5 * now1.8
let ONI_SPEED = 2.4 * 1.5 * 1.8;

let DASH_MULT = 6.0; // previous 3 -> doubled by request -> 6
const DASH_DUR_MS = 3000;
const DASH_CT_MS = 10000;

const COOP_BOOST_DIST = 120;
const COOP_SPEED_MULT = 1.3;

let FOOTSTEP_RANGE_MULT = 1.8; // expanded (not too huge)

const ADMIN_PASS = "1122";

/* ========== State ========== */
let sessionId = null;
let localPlayer = null;
let allPlayers = [];
let strawberries = [];
let deliveries = [];
let gameDoc = null;
let lastPosSend = 0;
let joinedTeamChoice = null;
let adminMode = false;

/* UI refs */
const loadingOverlay = document.getElementById("loadingOverlay");
const screens = {
  waiting: document.getElementById("screen-waiting"),
  team: document.getElementById("screen-team"),
  join: document.getElementById("screen-join"),
  game: document.getElementById("screen-game")
};
const gameCanvas = document.getElementById("gameCanvas");
const gctx = gameCanvas.getContext("2d");
const miniMap = document.getElementById("miniMap");
const miniCtx = miniMap.getContext("2d");
const boostStatusEl = document.getElementById("boostStatus");
const dashStatusEl = document.getElementById("dashStatus");

const toTeamBtn = document.getElementById("toTeamBtn");
const chooseOni = document.getElementById("chooseOni");
const chooseRunner = document.getElementById("chooseRunner");
const backFromTeam = document.getElementById("backFromTeam");
const backFromJoin = document.getElementById("backFromJoin");
const joinNow = document.getElementById("joinNow");
const inputName = document.getElementById("inputName");
const leaveBtn = document.getElementById("leaveBtn");
const playerInfoName = document.getElementById("playerInfoName");
const playerInfoTeam = document.getElementById("playerInfoTeam");
const topOni = document.getElementById("topOni");
const topRunner = document.getElementById("topRunner");
const oniCountEl = document.getElementById("oniCount");
const runnerCountEl = document.getElementById("runnerCount");
const oniScoreEl = document.getElementById("oniScore");
const runnerScoreEl = document.getElementById("runnerScore");
const logEl = document.getElementById("log");
const adminSmall = document.getElementById("adminSmall");
const adminResetBtn = document.getElementById("adminReset");
const statusSmall = document.getElementById("statusSmall");
const playerListEl = document.getElementById("playerList");
const homeResetBtn = document.getElementById("homeResetBtn");
const waitOniCount = document.getElementById("waitOniCount");
const waitRunnerCount = document.getElementById("waitRunnerCount");

const asiotoAudio = document.getElementById("asioto");
const explosionAudio = document.getElementById("explosion");

/* unsub handles */
let unsubGame = null, unsubPlayers = null, unsubStraw = null, unsubDeliveries = null;

/* map image */
let mapImage = new Image();
let mapImageLoaded = false;
mapImage.src = "map.png";
mapImage.onload = () => { mapImageLoaded = true; };

/* ===== Helpers ===== */
function showScreen(name){ for(const k in screens) screens[k].classList.add("hidden"); screens[name].classList.remove("hidden"); }
function showLoading(on){ loadingOverlay.style.display = on ? "flex" : "none"; }
function randPos(){ return { x: Math.floor(Math.random()*MAP_SIZE), y: Math.floor(Math.random()*MAP_SIZE)}; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function updateStatus(s){ statusSmall.textContent = "çŠ¶æ…‹: " + s; }

/* log with auto-remove after 10s */
function pushLog(text, type="info"){
  const el = document.createElement("div");
  el.className = "logItem " + (type==="event" ? "log-event" : (type==="error" ? "log-error" : "log-info"));
  el.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
  logEl.prepend(el);
  // auto remove after 10s
  setTimeout(()=>{ try{ el.remove(); }catch(e){} }, 10000);
  while(logEl.children.length > 300) logEl.removeChild(logEl.lastChild);
}

/* ========== Firestore ensure game doc ========== */
async function ensureGame(){
  const gameRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
  const snap = await getDoc(gameRef);
  if (!snap.exists()){
    await setDoc(gameRef, { state:"waiting", scores:{ oni:0, runner:0 }, mapSize:MAP_SIZE, createdAt: serverTimestamp() });
  }
}

/* ========== Robust join flow (fixes first-join bug) ========== */
async function joinAs(name, team){
  showLoading(true);
  await ensureGame();

  // remove previous same-name sessions
  try {
    const snaps = await getDocs(collection(db, PLAYERS_COL));
    for (const d of snaps.docs){
      const data = d.data();
      if (data && data.name === name){
        try { await deleteDoc(d.ref); pushLog(`å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ (${name}) ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, "info"); } catch(e){}
      }
    }
  } catch(e){ /* ignore */ }

  // create player doc
  try {
    const pRef = await addDoc(collection(db, PLAYERS_COL), {
      name, team, x: randPos().x, y: randPos().y, possession: 0, lastAction: serverTimestamp(), dashReadyAt: 0
    });
    sessionId = pRef.id;

    // set up listeners immediately so snapshot updates arrive
    setupListeners();

    // WAIT for player's doc to be visible via getDoc (max wait 5s)
    const start = Date.now();
    let ok = false;
    while (Date.now() - start < 5000){
      try {
        const snap = await getDoc(doc(db, PLAYERS_COL, sessionId));
        if (snap.exists()){ ok = true; break; }
      } catch(e){}
      await new Promise(r=>setTimeout(r, 150));
    }
    if (!ok){
      pushLog("å‚åŠ å‡¦ç†ãŒé…å»¶ã—ã¦ã„ã¾ã™ã€‚æ¥ç¶šçŠ¶æ³ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚", "error");
    }

    // ensure game state set to playing if it was waiting (transactional)
    try {
      await runTransaction(db, async (t) => {
        const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
        const s = await t.get(gRef);
        if (!s.exists()) throw new Error("game missing");
        const g = s.data();
        if (g.state === "waiting") t.update(gRef, { state: "playing" });
      });
    } catch(e){ /* ignore */ }

    // WAIT until localPlayer (from onSnapshot) is set to avoid camera freeze
    const start2 = Date.now();
    let ready=false;
    while (Date.now() - start2 < 5000){
      if (allPlayers.find(p => p._id === sessionId)){ ready=true; break; }
      await new Promise(r=>setTimeout(r,100));
    }
    // if still not ready, proceed but inform
    if (!ready) pushLog("å‚åŠ ã¯æˆåŠŸã—ã¾ã—ãŸãŒã€åŒæœŸãŒé…ã‚Œã¦ã„ã¾ã™ã€‚æ•°ç§’ãŠå¾…ã¡ãã ã•ã„ã€‚", "info");
    showLoading(false);
    showScreen("game");
    updateStatus(`å‚åŠ ä¸­: ${name} (${team})`);
    pushLog(`${name} ãŒå‚åŠ ã—ã¾ã—ãŸ (ãƒãƒ¼ãƒ : ${team})`, "event");
  } catch(e){
    showLoading(false); pushLog("å‚åŠ å¤±æ•—: " + (e.message||e), "error"); alert("å‚åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ");
  }
}

/* ========== leave ========== */
async function leave(){
  if (!sessionId) return;
  try { await deleteDoc(doc(db, PLAYERS_COL, sessionId)); } catch(e){}
  sessionId = null; localPlayer = null;
  tearDownListeners();
  showScreen("waiting");
  updateStatus("é›¢è„±ã—ã¾ã—ãŸ");
}

/* ========== Listeners ========== */
function setupListeners(){
  // game doc
  if (unsubGame) unsubGame();
  unsubGame = onSnapshot(doc(db, GAME_COLLECTION, GAME_DOC_ID), (snap) => {
    if (!snap.exists()) return;
    gameDoc = snap.data();
    topOni.textContent = gameDoc.scores?.oni || 0;
    topRunner.textContent = gameDoc.scores?.runner || 0;
    oniScoreEl.textContent = gameDoc.scores?.oni || 0;
    runnerScoreEl.textContent = gameDoc.scores?.runner || 0;
    if (gameDoc.state === "waiting"){
      pushLog("ã‚µãƒ¼ãƒ: å¾…æ©ŸçŠ¶æ…‹ã«æˆ»ã‚Šã¾ã—ãŸã€‚", "info");
      showScreen("team");
    }
  });

  // players
  if (unsubPlayers) unsubPlayers();
  unsubPlayers = onSnapshot(collection(db, PLAYERS_COL), (snap) => {
    const arr=[]; snap.forEach(d => { const data=d.data(); data._id=d.id; arr.push(data); });
    allPlayers = arr;
    localPlayer = allPlayers.find(p=>p._id===sessionId) || localPlayer;
    // counts
    const oniCount = allPlayers.filter(p=>p.team==="oni").length;
    const runnerCount = allPlayers.filter(p=>p.team==="runner").length;
    oniCountEl.textContent = "äººæ•°: " + oniCount;
    runnerCountEl.textContent = "äººæ•°: " + runnerCount;
    waitOniCount.textContent = oniCount;
    waitRunnerCount.textContent = runnerCount;
    if (localPlayer){ playerInfoName.textContent = localPlayer.name; playerInfoTeam.textContent = "ãƒãƒ¼ãƒ : " + localPlayer.team; } else { playerInfoName.textContent="æœªå‚åŠ "; playerInfoTeam.textContent="ãƒãƒ¼ãƒ : -"; }
    renderPlayerList();
  });

  // strawberries
  if (unsubStraw) unsubStraw();
  unsubStraw = onSnapshot(collection(db, STRAWBERRIES_COL), (snap) => {
    const arr=[]; snap.forEach(d=>{ const data=d.data(); data._id=d.id; arr.push(data); });
    strawberries = arr;
    for (const s of strawberries) attemptCollectStraw(s); // safety call
  });

  // deliveries
  if (unsubDeliveries) unsubDeliveries();
  unsubDeliveries = onSnapshot(collection(db, DELIVERIES_COL), (snap) => {
    const arr=[]; snap.forEach(d=>{ const data=d.data(); data._id=d.id; arr.push(data); });
    deliveries = arr;
  });
}

function tearDownListeners(){
  if (unsubGame) unsubGame(); unsubGame=null;
  if (unsubPlayers) unsubPlayers(); unsubPlayers=null;
  if (unsubStraw) unsubStraw(); unsubStraw=null;
  if (unsubDeliveries) unsubDeliveries(); unsubDeliveries=null;
  allPlayers=[]; strawberries=[]; deliveries=[]; gameDoc=null;
  renderPlayerList();
}

/* ========== finalize/reset ========== */
async function finalizeAndResetRound(){
  try{
    async function delAll(col){
      const snaps = await getDocs(collection(db, col));
      const batch = writeBatch(db);
      let any=false;
      for (const d of snaps.docs){ batch.delete(d.ref); any=true; }
      if (any) await batch.commit();
    }
    await delAll(PLAYERS_COL);
    await delAll(STRAWBERRIES_COL);
    await delAll(DELIVERIES_COL);
    await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { state:"waiting", scores:{oni:0, runner:0}, mapSize:MAP_SIZE, createdAt: serverTimestamp() });
    pushLog("ç®¡ç†è€…: å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ãƒ»ãƒ©ã‚¦ãƒ³ãƒ‰ãƒªã‚»ãƒƒãƒˆ", "event");
  } catch(e){ console.error(e); }
}

/* ========== Strawberry: advanced collection logic ==========
   - If >=2 runners within PICKUP_RADIUS:
       * If they are in speed-boost (i.e., have nearby teammate) AND/OR general rule, each nearby runner gets +1
   - Immediately teleport strawberry to a random position (available: true)
*/
async function attemptCollectStraw(straw){
  if (!straw || !straw.available) return;
  const runnersNearby = allPlayers.filter(p => p.team === "runner" && Math.hypot(p.x - straw.x, p.y - straw.y) <= PICKUP_RADIUS);
  if (runnersNearby.length < 2) return;

  // Determine which runners to award:
  // Preference: if two or more runnersNearby and at least two of them are in boost (near another runner), award those boosted players.
  // Otherwise award the nearest two.
  const boosted = runnersNearby.filter(p => {
    const nearCount = allPlayers.filter(o => o.team==="runner" && o._id !== p._id && Math.hypot(o.x - p.x, o.y - p.y) <= COOP_BOOST_DIST).length;
    return nearCount >= 1;
  });

  let targets = [];
  if (boosted.length >= 2){
    targets = boosted.slice(0,2);
  } else {
    runnersNearby.sort((a,b)=> Math.hypot(a.x-straw.x,a.y-straw.y) - Math.hypot(b.x-straw.x,b.y-straw.y));
    targets = runnersNearby.slice(0,2);
  }

  // Perform transactional updates: mark strawberry unavailable, increment targets' possession
  try {
    await runTransaction(db, async (t) => {
      const sRef = doc(db, STRAWBERRIES_COL, straw._id);
      const sSnap = await t.get(sRef);
      if (!sSnap.exists()) throw new Error("straw missing");
      const sData = sSnap.data();
      if (!sData.available) throw new Error("already collected");
      t.update(sRef, { available:false });
      for (const p of targets){
        const pRef = doc(db, PLAYERS_COL, p._id);
        const pSnap = await t.get(pRef);
        if (!pSnap.exists()) continue;
        const cur = pSnap.data().possession || 0;
        t.update(pRef, { possession: cur + 1, lastAction: serverTimestamp() });
      }
    });
    pushLog(`ã‚¤ãƒã‚´å›å: ${targets.map(t=>t.name).join(", ")}`, "event");
    // teleport strawberry immediately
    try {
      const newPos = randPos();
      await updateDoc(doc(db, STRAWBERRIES_COL, straw._id), { x: newPos.x, y: newPos.y, available: true });
    } catch(e){}
  } catch(e){}
}

/* ========== Delivery: transfer possession to team score and check win ========== */
async function tryDeliver(player){
  if (!player || player.team !== "runner") return;
  for (const d of deliveries){
    const dist = Math.hypot(player.x - d.x, player.y - d.y);
    if (dist <= PICKUP_RADIUS){
      const amount = player.possession || 0;
      if (amount <= 0) return;
      try {
        await runTransaction(db, async (t) => {
          const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
          const gSnap = await t.get(gRef);
          if (!gSnap.exists()) throw new Error("game missing");
          const g = gSnap.data();
          const scores = g.scores || { oni:0, runner:0 };
          scores.runner = (scores.runner || 0) + amount;
          t.update(gRef, { scores, lastUpdated: serverTimestamp() });
          t.update(doc(db, PLAYERS_COL, player._id), { possession: 0, lastAction: serverTimestamp() });
        });
        pushLog(`${player.name} ãŒç´å“ï¼ +${amount}`, "event");
        // check win
        const gSnap2 = await getDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID));
        if (gSnap2.exists()){
          const g2 = gSnap2.data();
          if ((g2.scores?.runner||0) >= WIN_SCORE){
            pushLog("é€ƒã’ãƒãƒ¼ãƒ ãŒå‹åˆ©ï¼ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™ã€‚", "event");
            await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { ...g2, state:"ended" });
            await finalizeAndResetRound();
          }
        }
      } catch(e){}
      return;
    }
  }
}

/* ========== Capture handling: +5 to oni on capture ========== */
async function checkCapturesAndHandle(){
  const onis = allPlayers.filter(p => p.team === "oni");
  const runners = allPlayers.filter(p => p.team === "runner");
  if (onis.length === 0 || runners.length === 0) return;
  for (const r of runners){
    for (const o of onis){
      const d = Math.hypot(r.x - o.x, r.y - o.y);
      if (d <= CAPTURE_RADIUS){
        try {
          await updateDoc(doc(db, PLAYERS_COL, r._id), { possession:0, x: randPos().x, y: randPos().y, lastAction: serverTimestamp() });
          await runTransaction(db, async (t) => {
            const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
            const s = await t.get(gRef);
            if (!s.exists()) return;
            const g = s.data();
            const scores = g.scores || { oni:0, runner:0 };
            scores.oni = (scores.oni || 0) + 5;
            t.update(gRef, { scores, lastUpdated: serverTimestamp() });
          });
          pushLog(`${r.name} ãŒæ•ã¾ã£ãŸï¼ é¬¼ãƒãƒ¼ãƒ  +5`, "event");
          explosionAudio.currentTime = 0; explosionAudio.play().catch(()=>{});
          // check win
          const gSnap2 = await getDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID));
          if (gSnap2.exists()){
            const g2 = gSnap2.data();
            if ((g2.scores?.oni||0) >= WIN_SCORE){
              pushLog("é¬¼ãƒãƒ¼ãƒ ãŒå‹åˆ©ï¼ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™ã€‚", "event");
              await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { ...g2, state:"ended" });
              await finalizeAndResetRound();
            }
          }
        } catch(e){}
        break;
      }
    }
  }
}

/* ========== Position send (throttled) ========== */
async function sendPositionIfNeeded(x,y){
  if (!sessionId) return;
  const now = Date.now();
  if (now - lastPosSend < POSITION_THROTTLE_MS) return;
  lastPosSend = now;
  try { await updateDoc(doc(db, PLAYERS_COL, sessionId), { x, y, lastAction: serverTimestamp() }); } catch(e){}
}

/* ========== Dash ========== */
function canDash(p){ if (!p || p.team !== "oni") return false; return Date.now() >= (p.dashReadyAt || 0); }
async function startDash(){
  if (!localPlayer || localPlayer.team !== "oni") return;
  const now = Date.now();
  try {
    await updateDoc(doc(db, PLAYERS_COL, sessionId), { dashReadyAt: now + DASH_CT_MS });
    localPlayer._isDashingUntil = now + DASH_DUR_MS;
    setTimeout(()=>{ if (localPlayer) localPlayer._isDashingUntil = 0; }, DASH_DUR_MS);
  } catch(e){}
}

/* ========== seed map (corner deliveries only) ========== */
async function seedMapOnce(){
  const dSnap = await getDocs(collection(db, DELIVERIES_COL));
  if (dSnap.size === 0){
    const pts = [{ x:80,y:80 },{ x:MAP_SIZE-80,y:80 },{ x:80,y:MAP_SIZE-80 },{ x:MAP_SIZE-80,y:MAP_SIZE-80 }];
    for (const p of pts) await addDoc(collection(db, DELIVERIES_COL), p);
  }
  const sSnap = await getDocs(collection(db, STRAWBERRIES_COL));
  if (sSnap.size === 0){
    const spts = [{ x:400,y:400,available:true },{ x:800,y:700,available:true },{ x:1300,y:1100,available:true },{ x:1600,y:500,available:true }];
    for (const s of spts) await addDoc(collection(db, STRAWBERRIES_COL), s);
  }
}

/* ========== Drawing helpers & render loop ========== */
function drawTextBubble(ctx, text, x, y, bg="#000", small=false){
  ctx.save(); ctx.font = small ? "12px sans-serif":"13px sans-serif";
  const metrics = ctx.measureText(text); const pad=8; const w=metrics.width+pad*2; const h=18; const bx=x-w/2; const by=y-h/2;
  ctx.fillStyle = bg; const r=8;
  ctx.beginPath(); ctx.moveTo(bx+r,by); ctx.arcTo(bx+w,by,bx+w,by+h,r); ctx.arcTo(bx+w,by+h,bx,by+h,r); ctx.arcTo(bx,by+h,bx,by,r); ctx.arcTo(bx,by,bx+w,by,r); ctx.closePath(); ctx.fill();
  ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(text,x,y); ctx.restore();
}
function drawDirectionHint(ctx,target,self,width,height){
  const dx=target.x-self.x, dy=target.y-self.y; const angle=Math.atan2(dy,dx); const cx=width/2, cy=height/2;
  const edgeX = cx + Math.cos(angle)*(Math.min(width,height)/2-30); const edgeY = cy + Math.sin(angle)*(Math.min(width,height)/2-30);
  ctx.save(); ctx.translate(edgeX,edgeY); ctx.rotate(angle); ctx.fillStyle="#ff8"; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-10,-6); ctx.lineTo(-10,6); ctx.closePath(); ctx.fill();
  drawTextBubble(ctx,`${target.name} (${Math.round(Math.hypot(dx,dy))}m)`, edgeX+18, edgeY, "#222", true); ctx.restore();
}
function drawWorld(ctx,width,height,centerPlayer,applyVisibility){
  ctx.clearRect(0,0,width,height);
  let camX=centerPlayer?centerPlayer.x:MAP_SIZE/2, camY=centerPlayer?centerPlayer.y:MAP_SIZE/2;
  const halfW=width/2, halfH=height/2; camX=clamp(camX,halfW,MAP_SIZE-halfW); camY=clamp(camY,halfH,MAP_SIZE-halfH);
  const toScreenX = mx => mx - (camX-halfW), toScreenY = my => my - (camY-halfH);

  if (mapImageLoaded){ const sx=(-(camX-halfW))*(width/MAP_SIZE), sy=(-(camY-halfH))*(height/MAP_SIZE); ctx.drawImage(mapImage, sx, sy, width, height); } else { ctx.fillStyle="#081018"; ctx.fillRect(0,0,width,height); }

  for (const d of deliveries){ const sx=toScreenX(d.x), sy=toScreenY(d.y); drawTextBubble(ctx,"â–³ ç´å“æ‰€",sx,sy-26,"#ffd39a"); ctx.fillStyle="#ffd39a"; ctx.beginPath(); ctx.moveTo(sx,sy-10); ctx.lineTo(sx-10,sy+10); ctx.lineTo(sx+10,sy+10); ctx.closePath(); ctx.fill(); }

  for (const s of strawberries){
    const sx=toScreenX(s.x), sy=toScreenY(s.y);
    let visible=true;
    if (applyVisibility && centerPlayer && centerPlayer.team==="runner"){ visible = Math.hypot(centerPlayer.x-s.x,centerPlayer.y-s.y)<=VISIBILITY_RADIUS; }
    if (!visible) continue;
    drawTextBubble(ctx,"ãƒ» ã‚¤ãƒã‚´",sx,sy-26,"#ff6b8a"); ctx.fillStyle = s.available ? "#ff6b8a" : "#5a2a2f"; ctx.beginPath(); ctx.arc(sx,sy,8,0,Math.PI*2); ctx.fill();
    const runnersNear = allPlayers.filter(p=>p.team==="runner" && Math.hypot(p.x-s.x,p.y-s.y)<=PICKUP_RADIUS);
    if (runnersNear.length===1){ ctx.strokeStyle="rgba(255,255,128,0.9)"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(sx,sy,12,0,Math.PI*2); ctx.stroke(); ctx.lineWidth=1; }
  }

  for (const p of allPlayers){
    let visible=true;
    if (applyVisibility && centerPlayer && centerPlayer.team==="runner"){ if (p._id===centerPlayer._id) visible=true; else visible = Math.hypot(centerPlayer.x-p.x,centerPlayer.y-p.y) <= VISIBILITY_RADIUS; }
    if (!visible) continue;
    const sx=toScreenX(p.x), sy=toScreenY(p.y);
    if (p.team==="runner"){ ctx.fillStyle="#4db8ff"; ctx.beginPath(); ctx.arc(sx,sy,12,0,Math.PI*2); ctx.fill(); }
    else { ctx.fillStyle="#ffcf4d"; ctx.fillRect(sx-12,sy-12,24,24); }
    if (localPlayer && p._id===localPlayer._id){ ctx.strokeStyle="#fff"; ctx.lineWidth=2; if (p.team==="runner"){ ctx.beginPath(); ctx.arc(sx,sy,14,0,Math.PI*2); ctx.stroke(); } else ctx.strokeRect(sx-14,sy-14,28,28); ctx.lineWidth=1; }
    if (p.team==="runner"){ const posText = (p.possession?`ğŸ“${p.possession}`:"ğŸ“0"); drawTextBubble(ctx,posText,sx,sy-34,"#083047"); }
    drawTextBubble(ctx,p.name,sx,sy+20,"#000",true);
  }

  if (applyVisibility && centerPlayer && centerPlayer.team==="runner"){ ctx.save(); ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.beginPath(); ctx.rect(0,0,width,height); ctx.arc(width/2,height/2,VISIBILITY_RADIUS,0,Math.PI*2,true); try{ ctx.fill('evenodd'); }catch(e){ ctx.globalCompositeOperation='destination-out'; ctx.fill(); ctx.globalCompositeOperation='source-over'; } ctx.restore(); }
  if (applyVisibility && centerPlayer && centerPlayer.team==="runner"){ const others = allPlayers.filter(p=>p.team==="runner" && p._id!==centerPlayer._id); if (others.length>0){ others.sort((a,b)=>Math.hypot(a.x-centerPlayer.x,a.y-centerPlayer.y)-Math.hypot(b.x-centerPlayer.x,b.y-centerPlayer.y)); drawDirectionHint(gctx, others[0], centerPlayer, width, height); } }
}

function drawMiniMap(){
  miniCtx.clearRect(0,0,miniMap.width,miniMap.height);
  const w = miniMap.width, h = miniMap.height;
  miniCtx.fillStyle="#041218"; miniCtx.fillRect(0,0,w,h);
  if (mapImageLoaded) miniCtx.drawImage(mapImage,0,0,w,h);
  for (const d of deliveries){ const sx=d.x/MAP_SIZE*w, sy=d.y/MAP_SIZE*h; miniCtx.fillStyle="#ffd39a"; miniCtx.beginPath(); miniCtx.moveTo(sx,sy-6); miniCtx.lineTo(sx-6,sy+6); miniCtx.lineTo(sx+6,sy+6); miniCtx.closePath(); miniCtx.fill(); }
  for (const s of strawberries){ const sx=s.x/MAP_SIZE*w, sy=s.y/MAP_SIZE*h; miniCtx.fillStyle=s.available?"#ff6b8a":"#5a2a2f"; miniCtx.beginPath(); miniCtx.arc(sx,sy,3,0,Math.PI*2); miniCtx.fill(); }
  for (const p of allPlayers){ const sx=p.x/MAP_SIZE*w, sy=p.y/MAP_SIZE*h; if (localPlayer && localPlayer.team==="runner"){ if (p._id===localPlayer._id){ miniCtx.fillStyle="#00ff80"; miniCtx.beginPath(); miniCtx.arc(sx,sy,5,0,Math.PI*2); miniCtx.fill(); } else if (p.team==="runner"){ miniCtx.fillStyle="#4db8ff"; miniCtx.beginPath(); miniCtx.arc(sx,sy,4,0,Math.PI*2); miniCtx.fill(); } } else { miniCtx.fillStyle=p.team==="oni"?"#ffcf4d":"#4db8ff"; miniCtx.beginPath(); miniCtx.arc(sx,sy,3,0,Math.PI*2); miniCtx.fill(); } }
  miniCtx.strokeStyle="rgba(255,255,255,0.06)"; miniCtx.strokeRect(0,0,w,h);
}

/* render loop */
(function renderLoop(){ requestAnimationFrame(renderLoop); drawWorld(gctx,gameCanvas.width,gameCanvas.height,localPlayer,true); drawMiniMap(); updateDashStatusUI(); updateBoostUI(); })();

/* ========== Input handling robustly (fix stuck long-press bug) ========== */
const pressed = new Set();
let lastKeyEventTime = Date.now();
window.addEventListener('keydown',(e)=>{ const k=e.key.toLowerCase(); if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){ e.preventDefault(); pressed.add(k); lastKeyEventTime=Date.now(); }});
window.addEventListener('keyup',(e)=>{ const k=e.key.toLowerCase(); if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){ e.preventDefault(); pressed.delete(k); lastKeyEventTime=Date.now(); }});
window.addEventListener('blur', ()=> pressed.clear());
setInterval(()=>{ if (Date.now()-lastKeyEventTime>1000) pressed.clear(); },1200);

/* movement tick */
setInterval(async ()=>{
  if (!localPlayer || !sessionId) return;
  let sp = localPlayer.team==="oni" ? ONI_SPEED : RUNNER_SPEED;
  if (localPlayer.team==="oni" && (pressed.has("shift")) && canDash(localPlayer)) await startDash();
  if (localPlayer._isDashingUntil && Date.now() < localPlayer._isDashingUntil) sp *= DASH_MULT;
  if (localPlayer.team==="runner"){
    const nearby = allPlayers.filter(p=> p._id!==localPlayer._id && p.team==="runner" && Math.hypot(p.x-localPlayer.x,p.y-localPlayer.y) <= COOP_BOOST_DIST);
    if (nearby.length>=1) sp *= COOP_SPEED_MULT;
  }
  let dx=0,dy=0;
  if (pressed.has("a")||pressed.has("arrowleft")) dx-=1;
  if (pressed.has("d")||pressed.has("arrowright")) dx+=1;
  if (pressed.has("w")||pressed.has("arrowup")) dy-=1;
  if (pressed.has("s")||pressed.has("arrowdown")) dy+=1;
  if (dx===0 && dy===0) return;
  const mag = Math.hypot(dx,dy)||1; dx = dx/mag * sp; dy = dy/mag * sp;
  const nx = clamp(localPlayer.x + dx, 0, MAP_SIZE); const ny = clamp(localPlayer.y + dy, 0, MAP_SIZE);
  // optimistic update
  localPlayer.x = nx; localPlayer.y = ny;
  await sendPositionIfNeeded(nx, ny);
  await tryDeliver(localPlayer);
  for (const s of strawberries) await attemptCollectStraw(s);
  await checkCapturesAndHandle();
}, 100);

/* footstep: runners hear if any oni within reduced-but-wider range */
setInterval(()=>{
  if (!localPlayer) return;
  if (localPlayer.team==="runner"){
    const onis = allPlayers.filter(p=>p.team==="oni");
    for (const o of onis){
      const d = Math.hypot(o.x-localPlayer.x, o.y-localPlayer.y);
      if (d <= VISIBILITY_RADIUS * FOOTSTEP_RANGE_MULT){
        asiotoAudio.currentTime = 0; asiotoAudio.play().catch(()=>{});
        break;
      }
    }
  }
}, 900);

/* player list rendering (admin kick & coords) */
function renderPlayerList(){
  playerListEl.innerHTML = "";
  const sorted = allPlayers.slice().sort((a,b)=> a.team.localeCompare(b.team) || (a.name||"").localeCompare(b.name));
  for (const p of sorted){
    const row = document.createElement("div"); row.className="playerRow";
    const left = document.createElement("div"); left.style.display="flex"; left.style.gap="8px"; left.style.alignItems="center";
    const shape = document.createElement("div"); shape.style.width="14px"; shape.style.height="14px"; shape.style.borderRadius = p.team==="runner"?"50%":"3px";
    shape.style.background = p.team==="runner" ? "#4db8ff" : "#ffd54d";
    left.appendChild(shape);
    const info = document.createElement("div"); info.innerHTML = `<div style="font-weight:700">${p.name}</div><div class="small">${p.team}</div>`;
    left.appendChild(info);
    row.appendChild(left);
    const right = document.createElement("div"); right.style.textAlign="right";
    const coords = adminMode ? `<div class="small" style="color:#9fb8c8">${Math.round(p.x)},${Math.round(p.y)}</div>` : "";
    right.innerHTML = `<div style="font-weight:700">${p.possession||0}ğŸ“</div>${coords}`;
    if (adminMode){
      const kick = document.createElement("button"); kick.className="kickBtn"; kick.textContent="é€€å‡º";
      kick.onclick = async ()=>{ if (!confirm(`${p.name} ã‚’å¼·åˆ¶é€€å‡ºã—ã¾ã™ã‹ï¼Ÿ`)) return; try{ await deleteDoc(doc(db, PLAYERS_COL, p._id)); pushLog(`${p.name} ã‚’ç®¡ç†è€…ãŒé€€å‡ºã•ã›ã¾ã—ãŸ`, "event"); }catch(e){ alert("é€€å‡ºã«å¤±æ•—ã—ã¾ã—ãŸ"); } };
      right.appendChild(kick);
    }
    row.appendChild(right);
    playerListEl.appendChild(row);
  }
}

/* dash UI & boost UI */
function updateDashStatusUI(){
  if (!localPlayer){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: -"; return; }
  if (localPlayer.team !== "oni"){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: (é¬¼ã®ã¿)"; return; }
  const readyAt = localPlayer.dashReadyAt || 0;
  const now = Date.now();
  if (now >= readyAt) dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨å¯èƒ½";
  else dashStatusEl.textContent = `ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨ä¸å¯ æ®‹ã‚Š ${Math.ceil((readyAt-now)/1000)}s`;
}
function updateBoostUI(){
  if (!localPlayer){ boostStatusEl.textContent = ""; return; }
  if (localPlayer.team==="runner"){
    const nearby = allPlayers.filter(p=>p._id!==localPlayer._id && p.team==="runner" && Math.hypot(p.x-localPlayer.x,p.y-localPlayer.y)<=COOP_BOOST_DIST);
    if (nearby.length>=1){ boostStatusEl.textContent="ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ–ãƒ¼ã‚¹ãƒˆä¸­ï¼ˆè¿‘ãã«ä»²é–“ï¼‰"; boostStatusEl.style.background="linear-gradient(90deg,#7fffd4,#2ee6b6)"; }
    else { boostStatusEl.textContent=""; boostStatusEl.style.background="linear-gradient(90deg,#06281f,#0b3940)"; }
  } else boostStatusEl.textContent="";
}

/* ========== UI hooks ========== */
toTeamBtn.addEventListener('click', ()=> showScreen("team"));
chooseOni.addEventListener('click', ()=>{ joinedTeamChoice="oni"; showScreen("join"); });
chooseRunner.addEventListener('click', ()=>{ joinedTeamChoice="runner"; showScreen("join"); });
backFromTeam.addEventListener('click', ()=> showScreen("waiting"));
backFromJoin.addEventListener('click', ()=> showScreen("team"));
joinNow.addEventListener('click', async ()=>{ const name=(inputName.value||"").trim(); if (!name){ alert("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; } if (!joinedTeamChoice){ alert("ãƒãƒ¼ãƒ ã‚’é¸ã‚“ã§ãã ã•ã„"); return; } await joinAs(name, joinedTeamChoice); joinedTeamChoice=null; inputName.value=""; });
leaveBtn.addEventListener('click', ()=> leave());

adminSmall.addEventListener('click', async ()=>{ const pass=prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:"); if (pass===ADMIN_PASS){ adminMode=true; adminResetBtn.classList.remove("hidden"); alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹"); renderPlayerList(); } else alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¸æ­£"); });
adminResetBtn.addEventListener('click', async ()=>{ if (!adminMode) return alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™"); if (!confirm("å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) return; await finalizeAndResetRound(); });
homeResetBtn.addEventListener('click', async ()=>{ const pass=prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›:"); if (pass===ADMIN_PASS){ await finalizeAndResetRound(); } else alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰é•ã„ã¾ã™"); });

/* ========== Boot ========== */
(async function boot(){
  await ensureGame();
  await seedMapOnce();
  showScreen("waiting");
  updateStatus("å¾…æ©Ÿä¸­");
})();

/* ========== Periodic tasks: win-check, strawberry/capture checks ====== */
setInterval(async ()=>{
  try{
    const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
    const gSnap = await getDoc(gRef);
    if (!gSnap.exists()) return;
    const g = gSnap.data();
    const scores = g.scores || {oni:0, runner:0};
    if (g.state === "playing" && (scores.oni >= WIN_SCORE || scores.runner >= WIN_SCORE)){
      pushLog("ã‚¹ã‚³ã‚¢åˆ°é”ã§ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™ã€‚", "event");
      await setDoc(gRef, { ...g, state:"ended" });
      await finalizeAndResetRound();
    }
  }catch(e){}
}, 3000);

setInterval(async ()=>{ for (const s of strawberries) attemptCollectStraw(s); await checkCapturesAndHandle(); }, 1200);

/* ========== End of script ========== */
</script>
</body>
</html>
