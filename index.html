<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤åŸºç›¤ - å®Œå…¨ç‰ˆï¼ˆç”»åƒå¯¾å¿œãƒ»ã‚­ãƒ£ãƒªãƒ¼å®Ÿè£…ï¼‰</title>
<style>
  :root{
    --bg:#0d0f12; --panel:#111317; --oni:#ffcf4d; --runner:#4db8ff;
    --muted:#9aa3ad;
  }
  * { box-sizing: border-box; }
  body{ margin:0; font-family:system-ui, "Hiragino Kaku Gothic ProN", "ãƒ¡ã‚¤ãƒªã‚ª", sans-serif; background:var(--bg); color:#eaf2ff; }
  #app{ display:flex; height:100vh; gap:12px; padding:12px; }
  #left{ flex:1; display:flex; flex-direction:column; gap:12px; align-items:center; }
  #right{ width:380px; background:linear-gradient(180deg,#0b0d10,#0f1113); box-shadow:-6px 0 18px rgba(0,0,0,.6); padding:14px; display:flex; flex-direction:column; gap:12px; border-radius:10px; }
  canvas{ border-radius:8px; background:#081018; display:block; }
  .panel{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px; border-radius:8px; width:100%; box-sizing:border-box; }
  .center{ text-align:center; }
  button{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:inherit; padding:10px 14px; border-radius:8px; cursor:pointer; }
  .big{ font-size:1.05rem; padding:12px 16px; }
  .small{ font-size:0.85rem; color:var(--muted); }
  #log{ flex:1; overflow:auto; padding:8px; background:transparent; border-radius:6px; }
  .logItem{ margin-bottom:6px; font-size:0.95rem; padding:6px 8px; border-radius:8px; }
  .log-info{ background: rgba(255,255,255,0.02); color:#dbe9ff; }
  .log-event{ background: rgba(255,215,170,0.06); color:#fff0df; }
  .log-error{ background: rgba(255,80,80,0.06); color:#ffd3d3; }
  #loadingOverlay { position:fixed; inset:0; background:rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:9999; color:#fff; font-size:1.1rem; display:none; }
  .playerRow{ display:flex; justify-content:space-between; align-items:center; padding:8px; border-radius:6px; background:rgba(255,255,255,0.02); }
  .minimap{ width:100%; height:140px; border-radius:6px; background:#041218; display:block; }
  .bubble { background: rgba(0,0,0,0.6); padding:4px 8px; border-radius:10px; color:#fff; display:inline-block; font-size:12px; }
  #boostStatus{ margin-top:8px; font-weight:700; color:#bfffbf; text-align:center; min-height:22px; }
</style>
</head>
<body>
<div id="loadingOverlay">å‡¦ç†ä¸­... å°‘ã—ãŠå¾…ã¡ãã ã•ã„</div>

<div id="adminSmall" style="position:fixed; left:12px; top:12px; z-index:100; background:rgba(0,0,0,0.35); padding:6px 8px; border-radius:6px; cursor:pointer;">ç®¡ç†</div>

<div id="app">
  <div id="left">
    <div id="screen-waiting" class="panel">
      <div class="center">
        <h2>å¾…æ©Ÿ / ãƒ«ãƒ¼ãƒ«</h2>
        <p class="small">å‚åŠ ã™ã‚‹ã‚’æŠ¼ã™ã¨ãƒãƒ¼ãƒ é¸æŠã¸ã€‚map.png ç­‰ã®ç”»åƒã‚’åŒãƒ•ã‚©ãƒ«ãƒ€ã«ç½®ãã¨åæ˜ ã•ã‚Œã¾ã™ã€‚</p>
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:center;">
          <button id="toTeamBtn" class="big">å‚åŠ ã™ã‚‹</button>
          <button id="homeResetBtn" class="big">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
      </div>
      <div style="margin-top:12px;">
        <pre style="white-space:pre-wrap; color:#dfe9f4;">
ãƒ©ã‚¦ãƒ³ãƒ‰åˆ¶ãƒ»é€”ä¸­å‚åŠ å¯
ãƒ»ã‚¤ãƒã‚´ã¯å¸¸ã«4ã¤ãƒ©ãƒ³ãƒ€ãƒ ã‚¹ãƒãƒ¼ãƒ³ï¼ˆä¸­å¿ƒå¯„ã‚Šï¼‰
ãƒ»é€ƒã’ã¯Shiftã§ã‚¤ãƒã‚´ã‚’æ´ã‚“ã§é‹ã¹ã‚‹ï¼ˆé•·æŠ¼ã—ã§é‹æ¬ã€é‹æ¬ä¸­é€Ÿåº¦0.2å€ï¼‰
ãƒ»4ã¤ã™ã¹ã¦ã®ç´å“æ‰€ã«ã‚¤ãƒã‚´ãŒç½®ã‹ã‚ŒãŸã‚‰é€ƒã’ãƒãƒ¼ãƒ ã®å‹åˆ©
ãƒ»é¬¼ãŒæ•ã¾ãˆãŸ1äººã”ã¨ã«é¬¼ãƒãƒ¼ãƒ  +5ç‚¹
ãƒ»ãƒ€ãƒƒã‚·ãƒ¥ã¯éå¸¸ã«é€Ÿã„ï¼ˆè¦èª¿æ•´ï¼‰
        </pre>
      </div>
    </div>

    <div id="screen-team" class="panel hidden">
      <h2 class="center">ãƒãƒ¼ãƒ ã‚’é¸ã‚“ã§ãã ã•ã„</h2>
      <div style="display:flex; gap:12px; margin-top:12px;">
        <button id="chooseOni" class="big">ğŸ‘¹ é¬¼ãƒãƒ¼ãƒ </button>
        <button id="chooseRunner" class="big">ğŸƒ é€ƒã’ãƒãƒ¼ãƒ </button>
      </div>
      <div style="margin-top:12px;" class="center">
        <button id="backFromTeam">æˆ»ã‚‹</button>
      </div>
    </div>

    <div id="screen-join" class="panel hidden">
      <h2 class="center">åå‰ã‚’å…¥åŠ›ã—ã¦å‚åŠ </h2>
      <div style="display:flex; gap:8px; align-items:center; justify-content:center; margin-top:8px;">
        <input id="inputName" class="nameInput" placeholder="åå‰ã‚’å…¥åŠ›" maxlength="16" />
        <button id="joinNow">å‚åŠ </button>
      </div>
      <div style="margin-top:8px;" class="center muted">
        <button id="backFromJoin">æˆ»ã‚‹</button>
      </div>
    </div>

    <div id="screen-game" class="panel hidden" style="width:100%;">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <div><strong>ğŸ‘¹ é¬¼: <span id="topOni">0</span></strong></div>
        <div><strong>ğŸƒ é€ƒã’: <span id="topRunner">0</span></strong></div>
        <div style="margin-left:auto; display:flex; align-items:center; gap:8px;">
          <div id="dashStatus" class="bubble">ãƒ€ãƒƒã‚·ãƒ¥: -</div>
          <button id="leaveBtn">é›¢è„±</button>
        </div>
      </div>

      <div style="margin-top:12px;">
        <canvas id="gameCanvas" width="1200" height="640"></canvas>
        <div id="boostStatus" class="panel" style="margin-top:8px; background:linear-gradient(90deg,#072b20,#0a3d2b);"></div>
      </div>
    </div>
  </div>

  <div id="right">
    <div class="panel">
      <div style="display:flex; justify-content:space-between;">
        <div>
          <div id="playerInfoName" style="font-weight:700;">æœªå‚åŠ </div>
          <div class="small" id="playerInfoTeam">ãƒãƒ¼ãƒ : -</div>
        </div>
        <div><div class="small">æ”¾ç½®: <span id="idleCount">0</span>s</div></div>
      </div>
    </div>

    <div class="panel" style="display:flex; flex-direction:column; gap:8px; height:40vh;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:700;">ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</div>
        <div class="small">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ </div>
      </div>
      <div id="playerList"></div>
    </div>

    <div class="panel" style="display:flex; flex-direction:column; gap:8px;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:700;">ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°</div>
        <div class="small">10ç§’ã§æ¶ˆãˆã¾ã™</div>
      </div>
      <div id="log" class="muted"></div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="adminReset" class="hidden">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button>
        <div class="small" id="statusSmall">çŠ¶æ…‹: åˆæœŸ</div>
      </div>
      <div style="margin-top:8px;">
        <canvas id="miniMap" class="minimap"></canvas>
        <div class="small">map.png ã‚’ç½®ãã¨èƒŒæ™¯ã«åæ˜ ã•ã‚Œã¾ã™ã€‚player.png, oni.png, strawberry.png, delivery.png ã‚’åŒãƒ•ã‚©ãƒ«ãƒ€ã«ç½®ãã¨è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
      </div>
    </div>
  </div>
</div>

<!-- audio -->
<audio id="asioto" src="asioto.mp3" preload="auto"></audio>
<audio id="explosion" src="explosion.mp3" preload="auto"></audio>

<script type="module">
/*
  ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã‚’å£Šã•ãšæ‹¡å¼µã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚
  è¿½åŠ ç‚¹:
  - ç”»åƒ (map.png, runner.png, oni.png, strawberry.png, delivery.png) ã‚’ä½¿ã£ã¦æç”»
  - ã‚¤ãƒã‚´ã‚’å¿…ãš4ã¤ spawnï¼ˆä¸­å¿ƒå¯„ã›ï¼‰
  - é€ƒã’ãŒShifté•·æŠ¼ã—ã§ã‚¤ãƒã‚´ã‚’æ´ã‚“ã§é‹æ¬ï¼ˆé‹æ¬ä¸­é€Ÿåº¦0.2å€ï¼‰
  - æ´ã‚€/ç½®ãã¯ã‚µãƒ¼ãƒå´ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ç®¡ç†ï¼ˆcarriedBy / deliveryIdï¼‰
  - ãƒ€ãƒƒã‚·ãƒ¥é€Ÿåº¦ã‚’ã•ã‚‰ã«3å€ï¼ˆéå¸¸ã«é«˜é€Ÿ: DASH_MULT ã‚’å¤§ããè¨­å®šï¼‰
  - è¶³éŸ³ç¯„å›²ã‚’5å€ã«
  - ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°ã‚’10ç§’ã§è‡ªå‹•å‰Šé™¤
  - ã‚«ãƒ¡ãƒ©ã‚’ lerp ã§è¿½å¾“ï¼ˆè¦–ç•Œãƒ•ãƒªãƒ¼ã‚ºæ”¹å–„ï¼‰
  - é€ƒã’ã®å‹åˆ©æ¡ä»¶: 4ã¤ã®ç´å“æ‰€ã™ã¹ã¦ã«ã‚¤ãƒã‚´ãŒç½®ã‹ã‚ŒãŸã‚‰å‹åˆ©
  æ³¨æ„: Firestore ãƒ«ãƒ¼ãƒ«ã®è¨­å®šã‚’é‹ç”¨ã§å¿…ãšè¡Œã£ã¦ãã ã•ã„ã€‚
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js";
import {
  getFirestore, collection, doc, addDoc, setDoc, updateDoc, deleteDoc, getDoc,
  onSnapshot, getDocs, runTransaction, writeBatch, serverTimestamp, Timestamp
} from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

/* ===== Firebase config (user provided) ===== */
const firebaseConfig = {
  apiKey: "AIzaSyBmgtx4FW_3_0zy1MvAvZLPHmE_CE1txuE",
  authDomain: "zzke-ki1.firebaseapp.com",
  databaseURL: "https://zzke-ki1-default-rtdb.firebaseio.com",
  projectId: "zzke-ki1",
  storageBucket: "zzke-ki1.firebasestorage.app",
  messagingSenderId: "260981230516",
  appId: "1:260981230516:web:146a29f15b2716a9af80e1",
  measurementId: "G-GF5G1D4E10"
};

const app = initializeApp(firebaseConfig);
try { getAnalytics(app); } catch(e){ /* ok */ }
const db = getFirestore(app);

/* ===== Constants ===== */
const GAME_COLLECTION = "games";
const GAME_DOC_ID = "current_round";
const PLAYERS_COL = "players";
const STRAWBERRIES_COL = "strawberries";
const DELIVERIES_COL = "deliveries";

const MAP_SIZE = 2000;
let VISIBILITY_RADIUS = 200;
const PICKUP_RADIUS = 80;
const CAPTURE_RADIUS = 36;
const POSITION_THROTTLE_MS = 180;
const WIN_SCORE = 50;

/* Speeds: apply previous multipliers and then another 1.8x if required earlier.
   We keep them large per user requests, but adjustable here.
*/
let RUNNER_SPEED = 2.6 * 1.5 * 1.8; // earlier multipliers included
let ONI_SPEED = 2.4 * 1.5 * 1.8;

/* Dash: previous became 6x; now multiply by 3 -> 18x. (User requested "ã•ã‚‰ã«3å€")
   Warning: very large â€” tune if needed.
*/
let DASH_MULT = 18.0; // extremely fast during dash
const DASH_DUR_MS = 3000;
const DASH_CT_MS = 10000;

/* coop boost */
const COOP_BOOST_DIST = 120;
const COOP_SPEED_MULT = 1.3;

/* footstep audible range to 5x as requested */
let FOOTSTEP_RANGE_MULT = 5.0;

/* admin password */
const ADMIN_PASS = "1122";

/* strawberry respawn / initial spawn count */
const STRAW_COUNT = 4;
const STRAW_RESPAWN_IMMEDIATE = false; // when collected we teleport immediately only if desired

/* ===== State ===== */
let sessionId = null;
let localPlayer = null;
let allPlayers = [];
let strawberries = [];
let deliveries = [];
let gameDoc = null;
let lastPosSend = 0;
let joinedTeamChoice = null;
let adminMode = false;

/* UI refs */
const loadingOverlay = document.getElementById("loadingOverlay");
const gameCanvas = document.getElementById("gameCanvas");
const gctx = gameCanvas.getContext("2d");
const miniMap = document.getElementById("miniMap");
const miniCtx = miniMap.getContext("2d");
const boostStatusEl = document.getElementById("boostStatus");
const dashStatusEl = document.getElementById("dashStatus");
const logEl = document.getElementById("log");

/* audio */
const asiotoAudio = document.getElementById("asioto");
const explosionAudio = document.getElementById("explosion");

/* unsub handles */
let unsubGame = null, unsubPlayers = null, unsubStraw = null, unsubDeliveries = null;

/* Camera smoothing */
const camera = { x: MAP_SIZE/2, y: MAP_SIZE/2, lerp: 0.18 };

/* Image assets (optional) */
const imgMap = new Image();
const imgRunner = new Image();
const imgOni = new Image();
const imgStraw = new Image();
const imgDelivery = new Image();
let imgMapLoaded=false, imgRunnerLoaded=false, imgOniLoaded=false, imgStrawLoaded=false, imgDeliveryLoaded=false;

imgMap.src = "map.png"; imgMap.onload = () => imgMapLoaded = true;
imgRunner.src = "runner.png"; imgRunner.onload = () => imgRunnerLoaded = true;
imgOni.src = "oni.png"; imgOni.onload = () => imgOniLoaded = true;
imgStraw.src = "strawberry.png"; imgStraw.onload = () => imgStrawLoaded = true;
imgDelivery.src = "delivery.png"; imgDelivery.onload = () => imgDeliveryLoaded = true;

/* helpers */
function showLoading(on){ loadingOverlay.style.display = on ? "flex" : "none"; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function nowMillis(){ return Date.now(); }
function updateStatus(s){ document.getElementById("statusSmall").textContent = "çŠ¶æ…‹: " + s; }
function pushLog(text, type="info"){
  const el = document.createElement("div");
  el.className = "logItem " + (type === "event" ? "log-event" : (type === "error" ? "log-error" : "log-info"));
  el.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
  logEl.prepend(el);
  setTimeout(()=>{ if (el.parentNode) el.parentNode.removeChild(el); }, 10000); // auto remove after 10s
  while(logEl.children.length > 200) logEl.removeChild(logEl.lastChild);
}

/* Firestore ensure game doc */
async function ensureGame(){
  const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
  const snap = await getDoc(gRef);
  if (!snap.exists()){
    await setDoc(gRef, { state:"waiting", scores:{ oni:0, runner:0 }, mapSize:MAP_SIZE, createdAt: serverTimestamp() });
  }
}

/* Create 4 strawberries biased to center */
function randomCenterBiased() {
  // use gaussian-like distribution around center
  const cx = MAP_SIZE/2, cy = MAP_SIZE/2;
  function gaussRand(scale=250){
    // approximate normal by sum of uniforms
    let sum = 0;
    for (let i=0;i<6;i++) sum += (Math.random()-0.5);
    return sum * scale;
  }
  const x = clamp(Math.round(cx + gaussRand()), 50, MAP_SIZE-50);
  const y = clamp(Math.round(cy + gaussRand()), 50, MAP_SIZE-50);
  return { x, y };
}
async function ensureStrawberriesCount(){
  const snaps = await getDocs(collection(db, STRAWBERRIES_COL));
  if (snaps.size >= STRAW_COUNT) return;
  // add until count STRAW_COUNT, biasing to center
  const current = snaps.size;
  for (let i=current; i<STRAW_COUNT; i++){
    const p = randomCenterBiased();
    await addDoc(collection(db, STRAWBERRIES_COL), { x: p.x, y: p.y, available: true, carriedBy: null, deliveryId: null });
  }
}

/* JOIN flow with stabilization to avoid first-join bug */
async function joinAs(name, team){
  showLoading(true);
  await ensureGame();
  // remove same-name previous sessions
  try {
    const snaps = await getDocs(collection(db, PLAYERS_COL));
    for (const d of snaps.docs){
      const data = d.data();
      if (data && data.name === name){
        try { await deleteDoc(d.ref); pushLog(`å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼ˆ${name}ï¼‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, "info"); } catch(e){}
      }
    }
  } catch(e){}
  // ensure strawberries exist BEFORE join to avoid first-join race
  await ensureStrawberriesCount();
  // create player doc
  try {
    const pRef = await addDoc(collection(db, PLAYERS_COL), {
      name: name || "Player",
      team,
      x: Math.round(MAP_SIZE/2 + (Math.random()-0.5)*200),
      y: Math.round(MAP_SIZE/2 + (Math.random()-0.5)*200),
      possession: 0,
      carryingId: null,
      lastAction: serverTimestamp(),
      dashReadyAt: 0
    });
    sessionId = pRef.id;
    setupListeners();
    // wait for snapshot catch-up (avoid first-time race)
    const start = Date.now();
    let ok = false;
    while (Date.now() - start < 5000){
      if (allPlayers.find(p => p._id === sessionId)) { ok = true; break; }
      await new Promise(r => setTimeout(r, 150));
    }
    if (!ok) pushLog("å‚åŠ å‡¦ç†ãŒé…å»¶ã—ã¾ã—ãŸãŒç¶šè¡Œã—ã¾ã™ã€‚", "error");
    // set playing if waiting
    try {
      await runTransaction(db, async (t) => {
        const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
        const s = await t.get(gRef);
        if (!s.exists()) throw new Error("game missing");
        const g = s.data();
        if (g.state === "waiting") t.update(gRef, { state: "playing" });
      });
    } catch(e){}
    showLoading(false);
    showScreen("game");
    updateStatus("å‚åŠ ä¸­: " + name + " (" + team + ")");
    pushLog(`${name} ãŒå‚åŠ ã—ã¾ã—ãŸ (ãƒãƒ¼ãƒ : ${team})`, "event");
  } catch(e){
    showLoading(false);
    pushLog("å‚åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ: " + (e.message||e), "error");
    alert("å‚åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ");
  }
}

/* LEAVE */
async function leave(){
  if (!sessionId) return;
  try { await deleteDoc(doc(db, PLAYERS_COL, sessionId)); } catch(e){}
  sessionId = null; localPlayer = null;
  tearDownListeners();
  showScreen("waiting");
  updateStatus("é›¢è„±ã—ã¾ã—ãŸ");
}

/* LISTENERS */
function setupListeners(){
  // game doc
  if (unsubGame) unsubGame();
  unsubGame = onSnapshot(doc(db, GAME_COLLECTION, GAME_DOC_ID), (snap) => {
    if (!snap.exists()) return;
    gameDoc = snap.data();
    document.getElementById("topOni").textContent = gameDoc.scores?.oni || 0;
    document.getElementById("topRunner").textContent = gameDoc.scores?.runner || 0;
    if (gameDoc.state === "waiting"){
      pushLog("ãƒ©ã‚¦ãƒ³ãƒ‰ã¯å¾…æ©ŸçŠ¶æ…‹ã«ãªã‚Šã¾ã—ãŸã€‚", "info");
      showScreen("team");
    }
  });

  // players
  if (unsubPlayers) unsubPlayers();
  unsubPlayers = onSnapshot(collection(db, PLAYERS_COL), (snap) => {
    const arr = [];
    snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    allPlayers = arr;
    localPlayer = allPlayers.find(p => p._id === sessionId) || localPlayer;
    // update player panel
    document.getElementById("playerInfoName").textContent = localPlayer ? localPlayer.name : "æœªå‚åŠ ";
    document.getElementById("playerInfoTeam").textContent = localPlayer ? ("ãƒãƒ¼ãƒ : " + localPlayer.team) : "ãƒãƒ¼ãƒ : -";
    document.getElementById("oniCount").textContent = "äººæ•°: " + allPlayers.filter(p=>p.team==="oni").length;
    document.getElementById("runnerCount").textContent = "äººæ•°: " + allPlayers.filter(p=>p.team==="runner").length;
    document.getElementById("waitOniCount").textContent = allPlayers.filter(p=>p.team==="oni").length;
    document.getElementById("waitRunnerCount").textContent = allPlayers.filter(p=>p.team==="runner").length;
    renderPlayerList();
    // re-check for collection
    for (const s of strawberries) attemptCollectStraw(s);
  });

  // strawberries
  if (unsubStraw) unsubStraw();
  unsubStraw = onSnapshot(collection(db, STRAWBERRIES_COL), (snap) => {
    const arr = []; snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    strawberries = arr;
    // if count < STRAW_COUNT, replenish (server-lite)
    if (strawberries.length < STRAW_COUNT) {
      (async ()=>{ await ensureStrawberriesCount(); })();
    }
    for (const s of strawberries) attemptCollectStraw(s);
  });

  // deliveries
  if (unsubDeliveries) unsubDeliveries();
  unsubDeliveries = onSnapshot(collection(db, DELIVERIES_COL), (snap) => {
    const arr = []; snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    deliveries = arr;
  });
}

function tearDownListeners(){
  if (unsubGame) unsubGame(); unsubGame = null;
  if (unsubPlayers) unsubPlayers(); unsubPlayers = null;
  if (unsubStraw) unsubStraw(); unsubStraw = null;
  if (unsubDeliveries) unsubDeliveries(); unsubDeliveries = null;
  allPlayers = []; strawberries = []; deliveries = []; gameDoc = null;
  renderPlayerList();
}

/* finalize/reset */
async function finalizeAndResetRound(){
  try {
    async function delAll(col){
      const snaps = await getDocs(collection(db, col));
      const batch = writeBatch(db);
      let any=false;
      for (const d of snaps.docs){ batch.delete(d.ref); any=true; }
      if (any) await batch.commit();
    }
    await delAll(PLAYERS_COL);
    await delAll(STRAWBERRIES_COL);
    await delAll(DELIVERIES_COL);
    await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { state:"waiting", scores:{oni:0, runner:0}, mapSize:MAP_SIZE, createdAt: serverTimestamp() });
    pushLog("ã‚µãƒ¼ãƒ: ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’å®Œå…¨ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸï¼ˆå…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ï¼‰", "event");
  } catch(e){ console.error(e); }
}

/* Utility: check runner victory: all deliveries have a strawberry with deliveryId == delivery._id */
async function checkRunnerVictoryAfterPlacement(){
  try {
    const dSnap = await getDocs(collection(db, DELIVERIES_COL));
    const delivs = [];
    dSnap.forEach(d => delivs.push(d.id));
    if (delivs.length === 0) return false;
    const sSnap = await getDocs(collection(db, STRAWBERRIES_COL));
    const mapping = new Map(); // deliveryId -> count
    sSnap.forEach(s => {
      const data = s.data();
      if (data && data.deliveryId) mapping.set(data.deliveryId, (mapping.get(data.deliveryId)||0) + 1);
    });
    // require every delivery to have >=1 strawberry placed
    const allPlaced = delivs.every(id => (mapping.get(id) || 0) >= 1);
    if (allPlaced){
      // declare runner win
      const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
      const gSnap = await getDoc(gRef);
      const g = gSnap.exists() ? gSnap.data() : { scores: { oni:0, runner:0 } };
      await setDoc(gRef, { ...g, state: "ended" });
      pushLog("é€ƒã’ãƒãƒ¼ãƒ ãŒå…¨ç´å“æ‰€ã«ã‚¤ãƒã‚´ã‚’é…ç½®ã—ã¦å‹åˆ©ã—ã¾ã—ãŸï¼", "event");
      await finalizeAndResetRound();
      return true;
    }
    return false;
  } catch(e){ console.error(e); return false; }
}

/* attemptCollectStraw updated:
   - if runner presses SHIFT near strawberry, they "grab" it (transaction sets carriedBy)
   - while carried: strawberry follows player; player's carryingId set
   - if carrying and player is near a delivery and holding shift, place strawberry: set deliveryId and position to delivery coords
   - additionally: if two runners both have coop boost and near strawberry, they both can get +1 (handled earlier)
*/
async function attemptCollectStraw(straw){
  if (!straw) return;
  // if already carried -> do nothing (carried by someone)
  if (!straw.available && straw.carriedBy) return;
  // server-side batch: if >=2 runners near -> normal collect to all
  const nearby = allPlayers.filter(p => p.team === "runner" && Math.hypot(p.x - straw.x, p.y - straw.y) <= PICKUP_RADIUS);
  if (nearby.length >= 2){
    try {
      await runTransaction(db, async (t) => {
        const sRef = doc(db, STRAWBERRIES_COL, straw._id);
        const sSnap = await t.get(sRef);
        if (!sSnap.exists()) throw new Error("straw missing");
        const sData = sSnap.data();
        if (!sData.available) throw new Error("already collected");
        t.update(sRef, { available: false, carriedBy: null, deliveryId: null });
        for (const p of nearby){
          const pRef = doc(db, PLAYERS_COL, p._id);
          const pSnap = await t.get(pRef);
          if (!pSnap.exists()) continue;
          const cur = pSnap.data().possession || 0;
          t.update(pRef, { possession: cur + 1, lastAction: serverTimestamp() });
        }
      });
      pushLog(`ã‚¤ãƒã‚´å›å: ${nearby.map(n=>n.name).join(", ")}`, "event");
      // respawn elsewhere bias center
      const newPos = randomCenterBiased();
      try { await updateDoc(doc(db, STRAWBERRIES_COL, straw._id), { x: newPos.x, y: newPos.y, available: true, carriedBy: null, deliveryId: null }); } catch(e){}
    } catch(e){}
    return;
  }

  // No bulk collect; pickup is performed client-initiated when player holds SHIFT near strawberry.
  // We do not automatically pick up here.
}

/* Player actions: pickup / drop triggered from client when Shift pressed/released.
   We'll implement functions to tryPickupNearbyStraw() and dropOrPlaceStraw().
*/
async function tryPickupNearestStraw(playerId){
  // find nearest available strawberry within PICKUP_RADIUS
  const p = allPlayers.find(x=>x._id===playerId);
  if (!p || p.team !== "runner") return false;
  const near = strawberries
    .filter(s=>s.available && !s.carriedBy && Math.hypot(s.x - p.x, s.y - p.y) <= PICKUP_RADIUS)
    .sort((a,b)=> Math.hypot(a.x-p.x,a.y-p.y) - Math.hypot(b.x-p.x,b.y-p.y))[0];
  if (!near) return false;
  try {
    await runTransaction(db, async (t) => {
      const sRef = doc(db, STRAWBERRIES_COL, near._id);
      const sSnap = await t.get(sRef);
      if (!sSnap.exists()) throw new Error("straw missing");
      const sData = sSnap.data();
      if (!sData.available) throw new Error("already taken");
      const pRef = doc(db, PLAYERS_COL, playerId);
      t.update(sRef, { available: false, carriedBy: playerId, deliveryId: null });
      t.update(pRef, { carryingId: near._id, lastAction: serverTimestamp() });
    });
    pushLog(`ã‚¤ãƒã‚´ã‚’æ´ã¿ã¾ã—ãŸ (${near._id})`, "info");
    return true;
  } catch(e){
    // race lost or error
    return false;
  }
}

async function dropOrPlaceIfOnDelivery(playerId){
  const p = allPlayers.find(x=>x._id===playerId);
  if (!p || !p.carryingId) return;
  const carryId = p.carryingId;
  // check if near any delivery
  const nearDelivery = deliveries.find(d => Math.hypot(d.x - p.x, d.y - p.y) <= PICKUP_RADIUS);
  if (nearDelivery){
    // place on this delivery
    try {
      await runTransaction(db, async (t) => {
        const sRef = doc(db, STRAWBERRIES_COL, carryId);
        const sSnap = await t.get(sRef);
        if (!sSnap.exists()) throw new Error("straw missing");
        const pRef = doc(db, PLAYERS_COL, playerId);
        // set strawberry position to delivery coords and mark deliveryId
        t.update(sRef, { x: nearDelivery.x, y: nearDelivery.y, available: false, carriedBy: null, deliveryId: nearDelivery._id });
        t.update(pRef, { carryingId: null, lastAction: serverTimestamp() });
      });
      pushLog(`${p.name} ãŒç´å“æ‰€ã«ã‚¤ãƒã‚´ã‚’é…ç½®ã—ã¾ã—ãŸ`, "event");
      // check runner victory
      await checkRunnerVictoryAfterPlacement();
    } catch(e){
      console.error(e);
    }
  } else {
    // drop at current position
    try {
      await runTransaction(db, async (t) => {
        const sRef = doc(db, STRAWBERRIES_COL, carryId);
        const sSnap = await t.get(sRef);
        if (!sSnap.exists()) throw new Error("straw missing");
        const pRef = doc(db, PLAYERS_COL, playerId);
        t.update(sRef, { x: p.x, y: p.y, available: true, carriedBy: null, deliveryId: null });
        t.update(pRef, { carryingId: null, lastAction: serverTimestamp() });
      });
      pushLog(`${p.name} ãŒã‚¤ãƒã‚´ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¾ã—ãŸ`, "info");
    } catch(e){}
  }
}

/* capture & scoring: when oni captures runner -> +5 oni, respawn runner */
async function checkCapturesAndHandle(){
  const onis = allPlayers.filter(p => p.team === "oni");
  const runners = allPlayers.filter(p => p.team === "runner");
  if (onis.length === 0 || runners.length === 0) return;
  for (const r of runners){
    for (const o of onis){
      const d = Math.hypot(r.x - o.x, r.y - o.y);
      if (d <= CAPTURE_RADIUS){
        try {
          await updateDoc(doc(db, PLAYERS_COL, r._id), { carryingId: null, possession: 0, x: randPos().x, y: randPos().y, lastAction: serverTimestamp() });
          await runTransaction(db, async (t) => {
            const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
            const s = await t.get(gRef);
            if (!s.exists()) return;
            const g = s.data();
            const scores = g.scores || { oni:0, runner:0 };
            scores.oni = (scores.oni || 0) + 5;
            t.update(gRef, { scores, lastUpdated: serverTimestamp() });
          });
          pushLog(`${r.name} ãŒæ•ã¾ã£ãŸï¼ é¬¼ãƒãƒ¼ãƒ  +5`, "event");
          explosionAudio.currentTime = 0; explosionAudio.play().catch(()=>{});
          // check win
          const gSnap2 = await getDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID));
          if (gSnap2.exists()){
            const g2 = gSnap2.data();
            if ((g2.scores?.oni || 0) >= WIN_SCORE){
              pushLog("é¬¼ãƒãƒ¼ãƒ ãŒå‹åˆ©ï¼ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™ã€‚", "event");
              await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { ...g2, state: "ended" });
              await finalizeAndResetRound();
            }
          }
        } catch(e){ console.error(e); }
        break;
      }
    }
  }
}

/* position update throttled */
let lastPos = 0;
async function sendPositionIfNeeded(x,y){
  if (!sessionId) return;
  const now = nowMillis();
  if (now - lastPos < POSITION_THROTTLE_MS) return;
  lastPos = now;
  try { await updateDoc(doc(db, PLAYERS_COL, sessionId), { x, y, lastAction: serverTimestamp() }); } catch(e){}
}

/* Dash */
function canDash(p){ if (!p || p.team !== "oni") return false; const readyAt = p.dashReadyAt || 0; return Date.now() >= readyAt; }
async function startDash(){
  if (!localPlayer || localPlayer.team !== "oni") return;
  const now = Date.now();
  try {
    await updateDoc(doc(db, PLAYERS_COL, sessionId), { dashReadyAt: now + DASH_CT_MS });
    localPlayer._isDashingUntil = now + DASH_DUR_MS;
    setTimeout(()=>{ if (localPlayer) localPlayer._isDashingUntil = 0; }, DASH_DUR_MS);
  } catch(e){}
}

/* seed map and ensure 4 strawberries (center-biased) */
function randomCenterBiased() {
  const cx = MAP_SIZE/2, cy = MAP_SIZE/2;
  function gauss(scale=220){
    let sum=0; for (let i=0;i<6;i++) sum += (Math.random()-0.5);
    return sum*scale;
  }
  const x = clamp(Math.round(cx + gauss()), 50, MAP_SIZE-50);
  const y = clamp(Math.round(cy + gauss()), 50, MAP_SIZE-50);
  return { x,y };
}
async function ensureStrawberriesCount(){
  const snaps = await getDocs(collection(db, STRAWBERRIES_COL));
  if (snaps.size >= STRAW_COUNT) return;
  for (let i=snaps.size;i<STRAW_COUNT;i++){
    const p = randomCenterBiased();
    await addDoc(collection(db, STRAWBERRIES_COL), { x: p.x, y: p.y, available: true, carriedBy: null, deliveryId: null });
  }
}

/* Drawing helpers (use images if available) */
function drawImageOrShape(ctx, img, loaded, sx, sy, w, h, fallbackColor, shape="circle"){
  if (loaded && img) {
    try { ctx.drawImage(img, sx - w/2, sy - h/2, w, h); return; } catch(e){}
  }
  ctx.fillStyle = fallbackColor || "#fff";
  if (shape === "circle"){ ctx.beginPath(); ctx.arc(sx, sy, w/2, 0, Math.PI*2); ctx.fill(); }
  else { ctx.fillRect(sx - w/2, sy - h/2, w, h); }
}

/* draw world with camera lerp to avoid frozen view */
function drawWorld(ctx, width, height, centerPlayer, applyVisibility){
  ctx.clearRect(0,0,width,height);
  // target camera center & clamp
  let tx = centerPlayer ? centerPlayer.x : MAP_SIZE/2;
  let ty = centerPlayer ? centerPlayer.y : MAP_SIZE/2;
  const halfW = width/2, halfH = height/2;
  tx = clamp(tx, halfW, MAP_SIZE - halfW);
  ty = clamp(ty, halfH, MAP_SIZE - halfH);

  camera.x += (tx - camera.x) * camera.lerp;
  camera.y += (ty - camera.y) * camera.lerp;

  const toScreenX = (mx) => (mx - (camera.x - halfW));
  const toScreenY = (my) => (my - (camera.y - halfH));

  // map image
  if (imgMapLoaded) {
    const scaleX = width / MAP_SIZE;
    const scaleY = height / MAP_SIZE;
    ctx.drawImage(imgMap, (-(camera.x - halfW))*scaleX, (-(camera.y - halfH))*scaleY, MAP_SIZE*scaleX, MAP_SIZE*scaleY);
  } else {
    ctx.fillStyle = "#081018"; ctx.fillRect(0,0,width,height);
  }

  // deliveries
  for (const d of deliveries){
    const sx = toScreenX(d.x), sy = toScreenY(d.y);
    if (imgDeliveryLoaded) drawImageOrShape(ctx, imgDelivery, imgDeliveryLoaded, sx, sy, 28, 28, "#ffd39a", "rect");
    else { ctx.fillStyle="#ffd39a"; ctx.beginPath(); ctx.moveTo(sx, sy-12); ctx.lineTo(sx-12, sy+12); ctx.lineTo(sx+12, sy+12); ctx.closePath(); ctx.fill(); }
    drawTextBubble(ctx, "â–³ ç´å“æ‰€", sx, sy - 26, "#000");
  }

  // strawberries: if carried, draw on carrier; else draw at pos
  for (const s of strawberries){
    let sx = toScreenX(s.x), sy = toScreenY(s.y);
    const carried = s.carriedBy ? allPlayers.find(p => p._id === s.carriedBy) : null;
    if (carried) { sx = toScreenX(carried.x); sy = toScreenY(carried.y - 18); }
    if (s.available === false && !carried && s.deliveryId) {
      // placed on delivery: still draw
    }
    if (imgStrawLoaded) drawImageOrShape(gctx, imgStraw, imgStrawLoaded, sx, sy, 18, 18, "#ff6b8a", "circle");
    else { ctx.fillStyle="#ff6b8a"; ctx.beginPath(); ctx.arc(sx, sy, 8,0,Math.PI*2); ctx.fill(); }
    drawTextBubble(ctx, "ãƒ»", sx, sy - 22, "#000");
  }

  // players
  for (const p of allPlayers){
    let visible = true;
    if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
      if (p._id === centerPlayer._id) visible = true;
      else visible = (Math.hypot(centerPlayer.x - p.x, centerPlayer.y - p.y) <= VISIBILITY_RADIUS);
    }
    if (!visible) continue;
    const sx = toScreenX(p.x), sy = toScreenY(p.y);
    if (p.team === "runner"){
      drawImageOrShape(ctx, imgRunner, imgRunnerLoaded, sx, sy, 28, 28, "#4db8ff", "circle");
    } else {
      drawImageOrShape(ctx, imgOni, imgOniLoaded, sx, sy, 32, 32, "#ffcf4d", "rect");
    }
    // highlight self
    if (localPlayer && p._id === localPlayer._id){
      ctx.strokeStyle="#fff"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(sx, sy, 18,0,Math.PI*2); ctx.stroke(); ctx.lineWidth=1;
    }
    if (p.team === "runner"){
      drawTextBubble(ctx, (p.possession?`ğŸ“${p.possession}`:"ğŸ“0"), sx, sy - 34, "#083047");
    }
    drawTextBubble(ctx, p.name, sx, sy + 22, "#000", true);
  }

  // runner darkness overlay
  if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.beginPath();
    ctx.rect(0,0,width,height);
    ctx.arc(width/2, height/2, VISIBILITY_RADIUS, 0, Math.PI*2, true);
    try{ ctx.fill('evenodd'); }catch(e){ ctx.globalCompositeOperation='destination-out'; ctx.fill(); ctx.globalCompositeOperation='source-over'; }
    ctx.restore();
  }

  // nearest teammate hint for runner
  if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
    const others = allPlayers.filter(p => p.team === "runner" && p._id !== centerPlayer._id);
    if (others.length > 0){
      others.sort((a,b)=> Math.hypot(a.x-centerPlayer.x,a.y-centerPlayer.y) - Math.hypot(b.x-centerPlayer.x,b.y-centerPlayer.y));
      drawDirectionHint(ctx, others[0], centerPlayer, width, height);
    }
  }
}

/* drawTextBubble */
function drawTextBubble(ctx, text, x, y, bg="#000", small=false){
  ctx.save();
  ctx.font = (small ? "12px sans-serif" : "13px sans-serif");
  const metrics = ctx.measureText(text);
  const padX = 8; const h = 18;
  const w = metrics.width + padX*2; const bx = x - w/2; const by = y - h/2;
  ctx.fillStyle = bg;
  ctx.beginPath();
  ctx.roundRect ? ctx.roundRect(bx, by, w, h, 8) : (function(){ ctx.fillRect(bx,by,w,h); })();
  ctx.fill();
  ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
  ctx.fillText(text, x, y);
  ctx.restore();
}

/* fallback for roundRect if not available */
if (!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    if (typeof r === "undefined") r = 5;
    this.beginPath();
    this.moveTo(x+r,y);
    this.arcTo(x+w,y,x+w,y+h,r);
    this.arcTo(x+w,y+h,x,y+h,r);
    this.arcTo(x,y+h,x,y,r);
    this.arcTo(x,y,x+w,y,r);
    this.closePath();
  };
}

/* mini map sync */
function drawMiniMap(){
  miniCtx.clearRect(0,0,miniMap.width,miniMap.height);
  const w = miniMap.width, h = miniMap.height;
  miniCtx.fillStyle="#041218"; miniCtx.fillRect(0,0,w,h);
  if (imgMapLoaded) miniCtx.drawImage(imgMap,0,0,w,h);
  for (const d of deliveries){
    const sx = d.x / MAP_SIZE * w, sy = d.y / MAP_SIZE * h;
    miniCtx.fillStyle="#ffd39a"; miniCtx.beginPath(); miniCtx.moveTo(sx,sy-6); miniCtx.lineTo(sx-6,sy+6); miniCtx.lineTo(sx+6,sy+6); miniCtx.closePath(); miniCtx.fill();
  }
  for (const s of strawberries){
    const sx = s.x / MAP_SIZE * w, sy = s.y / MAP_SIZE * h;
    miniCtx.fillStyle = s.available ? "#ff6b8a" : "#5a2a2f"; miniCtx.beginPath(); miniCtx.arc(sx,sy,3,0,Math.PI*2); miniCtx.fill();
  }
  for (const p of allPlayers){
    const sx = p.x / MAP_SIZE * w, sy = p.y / MAP_SIZE * h;
    miniCtx.fillStyle = p.team === "oni" ? "#ffcf4d" : "#4db8ff";
    miniCtx.beginPath(); miniCtx.arc(sx,sy,3,0,Math.PI*2); miniCtx.fill();
  }
  miniCtx.strokeStyle = "rgba(255,255,255,0.06)"; miniCtx.strokeRect(0,0,w,h);
}

/* render loop */
function renderLoop(){
  requestAnimationFrame(renderLoop);
  drawWorld(gctx, gameCanvas.width, gameCanvas.height, localPlayer, true);
  drawMiniMap();
  updateDashStatusUI();
  updateBoostUI();
}
renderLoop();

/* Input handling: robust (fix long-press issue). We'll listen to keydown/keyup for SHIFT to pick/drop */
const keys = new Set();
let lastKeyEvent = Date.now();
window.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){
    e.preventDefault();
    keys.add(k);
    lastKeyEvent = Date.now();
  }
});
window.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){
    e.preventDefault();
    keys.delete(k);
    lastKeyEvent = Date.now();
  }
});
window.addEventListener('blur', ()=> keys.clear());
setInterval(()=>{ if (Date.now() - lastKeyEvent > 1500) keys.clear(); }, 1500);

/* Movement tick */
setInterval(async ()=>{
  if (!localPlayer || !sessionId) return;
  let sp = localPlayer.team === "oni" ? ONI_SPEED : RUNNER_SPEED;
  // dash
  if (localPlayer.team === "oni" && (keys.has("shift")) && canDash(localPlayer)){
    await startDash();
  }
  if (localPlayer._isDashingUntil && Date.now() < localPlayer._isDashingUntil) sp *= DASH_MULT;
  // coop boost
  if (localPlayer.team === "runner"){
    const nearby = allPlayers.filter(p => p._id !== localPlayer._id && p.team === "runner" && Math.hypot(p.x - localPlayer.x, p.y - localPlayer.y) <= COOP_BOOST_DIST);
    if (nearby.length >= 1) sp *= COOP_SPEED_MULT;
  }
  // carrying slows to 0.2x (if carryingId set)
  if (localPlayer.carryingId) sp *= 0.2;
  // movement vector
  let dx=0, dy=0;
  if (keys.has("a") || keys.has("arrowleft")) dx -= 1;
  if (keys.has("d") || keys.has("arrowright")) dx += 1;
  if (keys.has("w") || keys.has("arrowup")) dy -= 1;
  if (keys.has("s") || keys.has("arrowdown")) dy += 1;
  if (dx === 0 && dy === 0) {
    // if holding shift while near strawberry, attempt pickup (start carry)
    if (keys.has("shift") && localPlayer.team === "runner" && !localPlayer.carryingId){
      await tryPickupNearestStraw(sessionId);
    }
    // if not moving but releasing shift while carrying -> drop/place
    if (!keys.has("shift") && localPlayer.carryingId){
      await dropOrPlaceIfOnDelivery(sessionId);
    }
    return;
  }
  const mag = Math.hypot(dx,dy) || 1;
  dx = dx/mag * sp; dy = dy/mag * sp;
  const nx = clamp(localPlayer.x + dx, 0, MAP_SIZE);
  const ny = clamp(localPlayer.y + dy, 0, MAP_SIZE);
  localPlayer.x = nx; localPlayer.y = ny;
  await sendPositionIfNeeded(nx, ny);
  // if carrying and holding shift and near delivery, auto-place
  if (localPlayer.carryingId && keys.has("shift")){
    await dropOrPlaceIfOnDelivery(sessionId);
  }
  // attempt deliver (for possession-based delivery)
  await tryDeliver(localPlayer);
  // attempt collect for static multiple-near rule
  for (const s of strawberries) attemptCollectStraw(s);
  // capture checks
  await checkCapturesAndHandle();
}, 100);

/* Footstep sound: runners hear if any oni within FOOTSTEP_RANGE_MULT * VISIBILITY_RADIUS */
setInterval(()=>{
  if (!localPlayer) return;
  if (localPlayer.team === "runner"){
    const onis = allPlayers.filter(p => p.team === "oni");
    for (const o of onis){
      const d = Math.hypot(o.x - localPlayer.x, o.y - localPlayer.y);
      if (d <= VISIBILITY_RADIUS * FOOTSTEP_RANGE_MULT){
        asiotoAudio.currentTime = 0; asiotoAudio.play().catch(()=>{});
        break;
      }
    }
  }
}, 900);

/* Player list rendering (admin shows coords & kick) */
function renderPlayerList(){
  const el = document.getElementById("playerList");
  el.innerHTML = "";
  const sorted = allPlayers.slice().sort((a,b)=> a.team.localeCompare(b.team) || (a.name||"").localeCompare(b.name));
  for (const p of sorted){
    const row = document.createElement("div"); row.className="playerRow";
    row.innerHTML = `<div style="display:flex;gap:8px;align-items:center;"><div style="width:14px;height:14px;border-radius:50%;background:${p.team==="runner"?"#4db8ff":"#ffd54d"}"></div><div><div style="font-weight:700">${p.name}</div><div class="small">${p.team}</div></div></div>`;
    const right = document.createElement("div"); right.style.textAlign="right";
    const coords = adminMode ? `<div style="color:#9fb8c8;font-size:0.85rem">${Math.round(p.x)},${Math.round(p.y)}</div>` : "";
    right.innerHTML = `<div style="font-weight:700">${p.possession||0}ğŸ“</div>${coords}`;
    if (adminMode){
      const kick = document.createElement("button"); kick.textContent = "é€€å‡º"; kick.style.marginLeft="6px"; kick.onclick = async ()=>{
        if (!confirm(`${p.name} ã‚’é€€å‡ºã•ã›ã¾ã™ã‹ï¼Ÿ`)) return;
        try { await deleteDoc(doc(db, PLAYERS_COL, p._id)); pushLog(`${p.name} ã‚’ç®¡ç†è€…ãŒé€€å‡ºã•ã›ã¾ã—ãŸ`, "event"); } catch(e){ alert("å¤±æ•—"); }
      };
      right.appendChild(kick);
    }
    row.appendChild(right);
    el.appendChild(row);
  }
}

/* Dash UI update and boost UI */
function updateDashStatusUI(){
  if (!localPlayer){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: -"; return; }
  if (localPlayer.team !== "oni"){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: (é¬¼ã®ã¿)"; return; }
  const readyAt = localPlayer.dashReadyAt || 0;
  const now = Date.now();
  if (now >= readyAt) dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨å¯èƒ½";
  else dashStatusEl.textContent = `ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨ä¸å¯ æ®‹ã‚Š ${Math.ceil((readyAt-now)/1000)}s`;
}
function updateBoostUI(){
  if (!localPlayer){ boostStatusEl.textContent = ""; return; }
  if (localPlayer.team === "runner"){
    const nearby = allPlayers.filter(p => p._id !== localPlayer._id && p.team === "runner" && Math.hypot(p.x - localPlayer.x, p.y - localPlayer.y) <= COOP_BOOST_DIST);
    if (nearby.length >= 1){
      boostStatusEl.textContent = "ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ–ãƒ¼ã‚¹ãƒˆä¸­ï¼ˆè¿‘ãã«ä»²é–“ï¼‰";
      boostStatusEl.style.background = "linear-gradient(90deg,#7fffd4,#2ee6b6)";
    } else { boostStatusEl.textContent = ""; boostStatusEl.style.background = "linear-gradient(90deg,#072b20,#0a3d2b)"; }
  } else boostStatusEl.textContent = "";
}

/* UI hooks */
document.getElementById("toTeamBtn").addEventListener('click', ()=> showScreen("team"));
document.getElementById("chooseOni").addEventListener('click', ()=>{ joinedTeamChoice = "oni"; showScreen("join"); });
document.getElementById("chooseRunner").addEventListener('click', ()=>{ joinedTeamChoice = "runner"; showScreen("join"); });
document.getElementById("backFromTeam").addEventListener('click', ()=> showScreen("waiting"));
document.getElementById("backFromJoin").addEventListener('click', ()=> showScreen("team"));
document.getElementById("joinNow").addEventListener('click', async ()=>{
  const name = (document.getElementById("inputName").value || "").trim();
  if (!name){ alert("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; }
  if (!joinedTeamChoice){ alert("ãƒãƒ¼ãƒ ã‚’é¸ã‚“ã§ãã ã•ã„"); return; }
  await joinAs(name, joinedTeamChoice);
  joinedTeamChoice = null; document.getElementById("inputName").value = "";
});
document.getElementById("leaveBtn").addEventListener('click', ()=> leave());
document.getElementById("adminSmall").addEventListener('click', async ()=>{
  const pass = prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:");
  if (pass === ADMIN_PASS){ adminMode = true; document.getElementById("adminReset").classList.remove("hidden"); alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹"); renderPlayerList(); }
  else alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¸æ­£");
});
document.getElementById("adminReset").addEventListener('click', async ()=>{
  if (!adminMode) return alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™");
  if (!confirm("å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) return;
  await finalizeAndResetRound();
});
document.getElementById("homeResetBtn").addEventListener('click', async ()=>{
  const pass = prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ");
  if (pass === ADMIN_PASS) await finalizeAndResetRound(); else alert("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™");
});

/* boot sequence */
(async function boot(){
  await ensureGame();
  await seedDeliveriesIfEmpty();
  await ensureStrawberriesCount();
  showScreen("waiting");
  updateStatus("å¾…æ©Ÿä¸­");
})();

/* helper: seed deliveries (if none) */
async function seedDeliveriesIfEmpty(){
  const dSnap = await getDocs(collection(db, DELIVERIES_COL));
  if (dSnap.size === 0){
    const pts = [
      { x: 80, y: 80 }, { x: MAP_SIZE-80, y: 80 }, { x: 80, y: MAP_SIZE-80 }, { x: MAP_SIZE-80, y: MAP_SIZE-80 }
    ];
    for (const p of pts) await addDoc(collection(db, DELIVERIES_COL), p);
  }
}

/* periodic tasks: win-check (score-based) */
setInterval(async ()=>{
  try {
    const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
    const gSnap = await getDoc(gRef);
    if (!gSnap.exists()) return;
    const g = gSnap.data();
    const scores = g.scores || { oni:0, runner:0 };
    if (g.state === "playing" && (scores.oni >= WIN_SCORE || scores.runner >= WIN_SCORE)){
      pushLog("ã‚¹ã‚³ã‚¢åˆ°é”ã§ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™ã€‚", "event");
      await setDoc(gRef, { ...g, state: "ended" });
      await finalizeAndResetRound();
    }
  } catch(e){}
}, 3000);

/* frequent responsiveness checks */
setInterval(async ()=>{
  for (const s of strawberries) attemptCollectStraw(s);
  await checkCapturesAndHandle();
}, 1200);

/* Helper functions used above but declared after to keep code organized */
function showScreen(name){ for(const el of document.querySelectorAll("#left > .panel, #left > .panel.hidden")){} /* noop to satisfy linter */ 
  const screens = { waiting: document.getElementById("screen-waiting"), team: document.getElementById("screen-team"), join: document.getElementById("screen-join"), game: document.getElementById("screen-game") };
  for (const k in screens) screens[k].classList.add("hidden");
  if (screens[name]) screens[name].classList.remove("hidden");
}

/* reuse drawTextBubble and drawDirectionHint (already declared earlier) */
/* The rest of helper functions are already defined above. */

</script>
</body>
</html>
