<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>é¬¼ã”ã£ã“</title>
<style>
  :root{ --bg:#0d0f12; --panel:#111317; --muted:#9aa3ad; }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui, "Hiragino Kaku Gothic ProN","ãƒ¡ã‚¤ãƒªã‚ª",sans-serif;background:var(--bg);color:#e6eef6}
  #app{display:flex;gap:12px;padding:12px;height:100vh}
  #left{flex:1;display:flex;flex-direction:column;gap:12px;align-items:center}
  #right{width:380px;background:linear-gradient(180deg,#0b0d10,#0f1113);padding:14px;border-radius:10px;display:flex;flex-direction:column;gap:12px}
  canvas{border-radius:8px;background:#081018;display:block}
  .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:8px;width:100%}
  .center{text-align:center}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 12px;border-radius:8px;cursor:pointer}
  .big{font-size:1.05rem;padding:10px 14px}
  .small{font-size:0.85rem;color:var(--muted)}
  .scoreBox{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px}
  #log{flex:1;overflow:auto;padding:8px}
  .logItem{margin-bottom:6px;font-size:0.95rem;padding:6px 8px;border-radius:8px}
  .log-info{background:rgba(255,255,255,0.02);color:#dbe9ff}
  .log-event{background:rgba(255,215,170,0.06);color:#fff0df}
  .log-error{background:rgba(255,80,80,0.06);color:#ffd3d3}
  #adminSmall{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:6px;font-size:.85rem;cursor:pointer;z-index:999}
  .hidden{display:none}
  .nameInput{padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;width:220px}
  #playerList{max-height:220px;overflow:auto;padding:6px;display:flex;flex-direction:column;gap:6px}
  .playerRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:6px;background:rgba(255,255,255,0.02)}
  .minimap{width:100%;height:140px;border-radius:6px;background:#041218;display:block}
  #loadingOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:9999;color:#fff;font-size:1.1rem}
  #boostStatus{margin-top:8px;font-weight:700;color:#bfffbf;text-align:center;min-height:22px}
  #dashStatus{font-weight:700;color:#ffd;margin-left:10px}
</style>
</head>
<body>
<div id="adminSmall">ç®¡ç†</div>

<div id="app">
  <div id="left">
    <div id="screen-waiting" class="panel">
      <div class="center">
        <h2>å¾…æ©Ÿç”»é¢</h2>
        <p class="small">å‚åŠ ã™ã‚‹ã‚’æŠ¼ã™ã¨ãƒãƒ¼ãƒ é¸æŠã¸ã€‚BGMã¯å‚åŠ æ“ä½œã§é–‹å§‹ã—ã¾ã™ã€‚</p>
        <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
          <button id="toTeamBtn" class="big">å‚åŠ ã™ã‚‹</button>
          <button id="homeResetBtn" class="big">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
      </div>
      <div style="margin-top:12px">
        <div class="small">è¿·è·¯ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã‚’é…ç½®ã—ã¦é–‹å§‹ã—ã¾ã™ã€‚é€šè·¯å¹…ã¯ååˆ†åºƒãã€ã‚¢ã‚¤ãƒ†ãƒ ãƒ»ãƒªã‚¹ãƒãƒ¼ãƒ³ã¯å£ã¨é‡ãªã‚‰ãªã„ã‚ˆã†é…ç½®ã—ã¾ã™ã€‚</div>
      </div>
      <div style="margin-top:8px" class="small center">ãƒãƒ¼ãƒ äººæ•° â€” é¬¼: <span id="waitOniCount">0</span> / é€ƒã’: <span id="waitRunnerCount">0</span></div>
    </div>

    <div id="screen-team" class="panel hidden">
      <h2 class="center">ãƒãƒ¼ãƒ é¸æŠ</h2>
      <div style="display:flex;gap:12px;margin-top:12px">
        <button id="chooseOni" style="flex:1;background:linear-gradient(90deg,#ffecb3,#ffd54d);border-radius:10px">ğŸ‘¹ é¬¼<br><span id="oniCount" class="small">äººæ•°:0</span></button>
        <button id="chooseRunner" style="flex:1;background:linear-gradient(90deg,#bfe8ff,#4db8ff);border-radius:10px">ğŸƒ é€ƒã’<br><span id="runnerCount" class="small">äººæ•°:0</span></button>
      </div>
      <div style="margin-top:12px" class="center"><button id="backFromTeam">æˆ»ã‚‹</button></div>
    </div>

    <div id="screen-join" class="panel hidden">
      <h2 class="center">åå‰ã‚’å…¥åŠ›ã—ã¦å‚åŠ </h2>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:8px">
        <input id="inputName" class="nameInput" placeholder="åå‰ã‚’å…¥åŠ›" maxlength="16" />
        <button id="joinNow">å‚åŠ </button>
      </div>
      <div style="margin-top:8px;text-align:center"><button id="backFromJoin">æˆ»ã‚‹</button></div>
    </div>

    <div id="screen-game" class="panel hidden" style="width:100%">
      <div style="display:flex;align-items:center;gap:12px">
        <div class="scoreBox" style="background:linear-gradient(90deg,#ffefd5,#fff1cc);color:#1a1200">ğŸ‘¹ é¬¼: <span id="topOni">0</span></div>
        <div class="scoreBox" style="background:linear-gradient(90deg,#dff4ff,#d6f0ff);color:#022033">ğŸƒ é€ƒã’ æ®‹ã‚Š: <span id="topRunnerRem">4</span></div>
        <div style="margin-left:auto;display:flex;align-items:center;gap:8px">
          <div id="dashStatus">ãƒ€ãƒƒã‚·ãƒ¥: -</div>
          <button id="leaveBtn">é›¢è„±</button>
        </div>
      </div>

      <div style="margin-top:12px;width:100%">
        <canvas id="gameCanvas" width="1200" height="640"></canvas>
        <div id="boostStatus" class="panel" style="margin-top:8px;background:linear-gradient(180deg,#06281f,#0b3940)"></div>
      </div>
    </div>
  </div>

  <div id="right">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div id="playerInfoName" style="font-weight:700">æœªå‚åŠ </div>
          <div id="playerInfoTeam" class="small">ãƒãƒ¼ãƒ : -</div>
        </div>
        <div><div class="small">æ”¾ç½®: <span id="idleCount">0</span>s</div></div>
      </div>
    </div>

    <div class="panel" style="display:flex;flex-direction:column;gap:8px;height:40vh">
      <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700">ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</div><div class="small">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ </div></div>
      <div id="playerList"></div>
      <div class="small">ï¼ˆç®¡ç†è€…ã¯åº§æ¨™ãƒ»é€€å‡ºãƒœã‚¿ãƒ³ã‚’æ“ä½œå¯ï¼‰</div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°</div><div class="small">10ç§’ã§æ¶ˆãˆã¾ã™</div>
      </div>
      <div id="log" class="muted"></div>
      <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
        <button id="adminReset" class="hidden">å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ</button>
        <div class="small" id="statusSmall">çŠ¶æ…‹: åˆæœŸ</div>
      </div>
      <div style="margin-top:8px">
        <canvas id="miniMap" class="minimap"></canvas>
        <div class="small">map.png ã‚’ç½®ãã¨èƒŒæ™¯ã«åæ˜ ã•ã‚Œã¾ã™ã€‚</div>
      </div>
    </div>
  </div>
</div>

<div id="loadingOverlay">å‡¦ç†ä¸­... å°‘ã—ãŠå¾…ã¡ãã ã•ã„</div>

<!-- assets: place these in same folder -->
<audio id="bgm" src="bgm.mp3" preload="auto" loop></audio>
<audio id="asioto" src="asioto.mp3" preload="auto"></audio>
<audio id="explosion" src="explosion.mp3" preload="auto"></audio>

<script type="module">
/* å®Œå…¨ç‰ˆ single-file implementing:
   - maze walls (random at start) stored in Firestore 'walls' collection
   - walls are axis-aligned rectangles; movement collides with walls client-side
   - items and spawns placed only in open tiles
   - robust carry/pickup/release behavior: transaction-secured ownerId
   - auto-drop when oni close
   - footstep audible multiplier variable
   - BGM playback on participant action
   - fixes for movement freeze by respecting local optimistic moves when recent
*/

/* Firebase imports */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js";
import {
  getFirestore, collection, doc, addDoc, setDoc, updateDoc, deleteDoc, getDoc,
  onSnapshot, getDocs, runTransaction, writeBatch, serverTimestamp, Timestamp
} from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

/* ====== FIREBASE CONFIG - keep your config here (already provided earlier) ====== */
const firebaseConfig = {
  apiKey: "AIzaSyBmgtx4FW_3_0zy1MvAvZLPHmE_CE1txuE",
  authDomain: "zzke-ki1.firebaseapp.com",
  databaseURL: "https://zzke-ki1-default-rtdb.firebaseio.com",
  projectId: "zzke-ki1",
  storageBucket: "zzke-ki1.firebasestorage.app",
  messagingSenderId: "260981230516",
  appId: "1:260981230516:web:146a29f15b2716a9af80e1",
  measurementId: "G-GF5G1D4E10"
};
const app = initializeApp(firebaseConfig);
try { getAnalytics(app); } catch(e){}
const db = getFirestore(app);

/* ====== CONFIG ====== */
const GAME_COLLECTION = "games";
const GAME_DOC_ID = "current_round";
const PLAYERS_COL = "players";
const STRAWBERRIES_COL = "strawberries";
const DELIVERIES_COL = "deliveries";
const WALLS_COL = "walls";

const MAP_SIZE = 2000;
let VISIBILITY_RADIUS = 200;
const PICKUP_RADIUS = 80;
const CAPTURE_RADIUS = 36;
const POSITION_THROTTLE_MS = 180;
const WIN_SCORE = 50;

/* speed multipliers (global requested multipliers previously applied) */
const GLOBAL_SPEED_MULT = 1.6;
const BASE_RUNNER_SPEED = 2.6;
const BASE_ONI_SPEED = 2.4;
let RUNNER_SPEED = BASE_RUNNER_SPEED * GLOBAL_SPEED_MULT;
let ONI_SPEED = BASE_ONI_SPEED * GLOBAL_SPEED_MULT;

/* Dash: set large multiplier per user request, tunable */
let DASH_MULT = 9.0;
const DASH_DUR_MS = 3000;
const DASH_CT_MS = 10000;

/* Carry speed */
const CARRY_SPEED_MULT = 0.6;

/* Coop boost */
const COOP_BOOST_DIST = 120;
const COOP_SPEED_MULT = 1.3;

/* Footstep audible range multiplier - changeable here */
let FOOTSTEP_RANGE_MULT = 3;

/* Maze grid params (tile-based) */
const tileSize = 50; // tile pixel size
const cols = Math.floor(MAP_SIZE / tileSize); // ensure fits
const rows = Math.floor(MAP_SIZE / tileSize);
const pathWidthPx = 34; // width of path in pixels (must be <= tileSize)
const wallThickness = tileSize - pathWidthPx;

/* Admin */
const ADMIN_PASS = "1122";

/* Assets names (place PNGs in same dir) */
const ASSETS = {
  map: "map.png",
  runner: "runner.png",
  oni: "oni.png",
  delivery: "delivery.png",
  strawberry: "strawberry.png"
};

/* ====== STATE ====== */
let sessionId = null;
let localPlayer = null;
let allPlayers = [];
let strawberries = [];
let deliveries = [];
let walls = []; // array of {x,y,w,h} in pixels
let gameDoc = null;
let lastPosSend = 0;
let joinedTeamChoice = null;
let adminMode = false;

/* avoid overwriting local optimistic moves */
let lastLocalMoveTime = 0;

/* UI refs */
const screens = { waiting: document.getElementById("screen-waiting"), team: document.getElementById("screen-team"), join: document.getElementById("screen-join"), game: document.getElementById("screen-game") };
const loadingOverlay = document.getElementById("loadingOverlay");
const gameCanvas = document.getElementById("gameCanvas");
const gctx = gameCanvas.getContext("2d");
const miniMap = document.getElementById("miniMap");
const miniCtx = miniMap.getContext("2d");
const boostStatusEl = document.getElementById("boostStatus");
const bgmAudio = document.getElementById("bgm");

const toTeamBtn = document.getElementById("toTeamBtn");
const chooseOni = document.getElementById("chooseOni");
const chooseRunner = document.getElementById("chooseRunner");
const backFromTeam = document.getElementById("backFromTeam");
const backFromJoin = document.getElementById("backFromJoin");
const joinNow = document.getElementById("joinNow");
const inputName = document.getElementById("inputName");
const leaveBtn = document.getElementById("leaveBtn");
const playerInfoName = document.getElementById("playerInfoName");
const playerInfoTeam = document.getElementById("playerInfoTeam");
const topOni = document.getElementById("topOni");
const topRunnerRem = document.getElementById("topRunnerRem");
const oniCountEl = document.getElementById("oniCount");
const runnerCountEl = document.getElementById("runnerCount");
const logEl = document.getElementById("log");
const adminSmall = document.getElementById("adminSmall");
const adminResetBtn = document.getElementById("adminReset");
const statusSmall = document.getElementById("statusSmall");
const playerListEl = document.getElementById("playerList");
const homeResetBtn = document.getElementById("homeResetBtn");
const dashStatusEl = document.getElementById("dashStatus");
const waitOniCount = document.getElementById("waitOniCount");
const waitRunnerCount = document.getElementById("waitRunnerCount");

/* audio */
const asiotoAudio = document.getElementById("asioto");
const explosionAudio = document.getElementById("explosion");

/* unsub */
let unsubGame=null, unsubPlayers=null, unsubStraw=null, unsubDeliveries=null, unsubWalls=null;

/* load sprite images if available */
const mapImage = new Image(); let mapImageLoaded=false;
const sprRunner = new Image(); let sprRunnerLoaded=false;
const sprOni = new Image(); let sprOniLoaded=false;
const sprDelivery = new Image(); let sprDeliveryLoaded=false;
const sprStraw = new Image(); let sprStrawLoaded=false;

mapImage.src = ASSETS.map; mapImage.onload = ()=>mapImageLoaded=true;
sprRunner.src = ASSETS.runner; sprRunner.onload = ()=>sprRunnerLoaded=true;
sprOni.src = ASSETS.oni; sprOni.onload = ()=>sprOniLoaded=true;
sprDelivery.src = ASSETS.delivery; sprDelivery.onload = ()=>sprDeliveryLoaded=true;
sprStraw.src = ASSETS.strawberry; sprStraw.onload = ()=>sprStrawLoaded=true;

/* camera smoothing */
const camera = { x: MAP_SIZE/2, y: MAP_SIZE/2, lerp: 0.18 };

/* helpers */
function showScreen(name){ for(const k in screens) screens[k].classList.add("hidden"); screens[name].classList.remove("hidden"); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function nowMillis(){ return Date.now(); }
function showLoading(on){ loadingOverlay.style.display = on ? "flex" : "none"; }
function updateStatus(s){ statusSmall.textContent = "çŠ¶æ…‹: " + s; }

/* logging auto-clear 10s */
function pushLog(text, type="info"){
  const el = document.createElement("div");
  el.className = "logItem " + (type==="event"?"log-event":(type==="error"?"log-error":"log-info"));
  el.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
  logEl.prepend(el);
  setTimeout(()=>{ try{ el.remove(); }catch(e){} }, 10000);
  while(logEl.children.length>200) logEl.removeChild(logEl.lastChild);
}

/* FIRESTORE: ensure game doc exists */
async function ensureGame(){
  const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
  const snap = await getDoc(gRef);
  if (!snap.exists()){
    await setDoc(gRef, { state:"waiting", scores:{ oni:0, runner:0 }, mapSize:MAP_SIZE, runnerRemaining:4, createdAt: serverTimestamp() });
  }
}

/* MAZE GENERATION (randomized DFS on odd-sized grid), store as wall rectangles
   Grid: use cell grid where every cell is either wall or passage; ensure pathWidthPx wide passages by computing rectangle sizes.
*/
function generateMazeGrid(rows, cols){
  // create boolean grid: true = wall, false = passage
  // initialize all cells as walls
  const grid = Array.from({length:rows}, ()=>Array(cols).fill(true));
  // start at random odd cell
  const startR = Math.floor(Math.random() * Math.floor(rows/2)) * 2 + 1;
  const startC = Math.floor(Math.random() * Math.floor(cols/2)) * 2 + 1;
  const stack = [[startR, startC]];
  grid[startR][startC] = false;
  const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
  while(stack.length){
    const [r,c] = stack[stack.length-1];
    // shuffle dirs
    const shuffled = dirs.slice().sort(()=>Math.random()-0.5);
    let carved=false;
    for (const [dr,dc] of shuffled){
      const nr = r+dr, nc = c+dc;
      if (nr>0 && nr<rows-1 && nc>0 && nc<cols-1 && grid[nr][nc]){
        // carve intermediate
        grid[r+dr/2][c+dc/2] = false;
        grid[nr][nc] = false;
        stack.push([nr,nc]);
        carved=true; break;
      }
    }
    if (!carved) stack.pop();
  }
  return grid;
}

/* convert grid into wall rectangles (pixel coords)
   Each grid cell is tileSize px; if grid[r][c] is wall, rectangle covers that cell area
*/
function gridToWallRects(grid){
  const rects = [];
  for (let r=0;r<grid.length;r++){
    for (let c=0;c<grid[0].length;c++){
      if (grid[r][c]){
        rects.push({ x: c*tileSize, y: r*tileSize, w: tileSize, h: tileSize });
      }
    }
  }
  return rects;
}

/* create maze if walls collection empty (only one client should do this). We'll store a single doc per wall rect for simplicity. */
async function seedMazeIfEmpty(){
  const snaps = await getDocs(collection(db, WALLS_COL));
  if (snaps.size > 0) return; // already generated
  // ensure grid has odd dimensions for maze algorithm to work well
  const rowsGrid = Math.floor(rows);
  const colsGrid = Math.floor(cols);
  const grid = generateMazeGrid(rowsGrid, colsGrid);
  const rects = gridToWallRects(grid);
  // commit in batches
  const batchSize = 400; // avoid huge writes; commit in chunks
  for (let i=0;i<rects.length;i+=batchSize){
    const chunk = rects.slice(i, i+batchSize);
    const batch = writeBatch(db);
    for (const r of chunk){
      const wref = doc(collection(db, WALLS_COL));
      batch.set(wref, r);
    }
    await batch.commit();
  }
  // ensure deliveries and strawberries placed in passages (choose open cells)
  await seedMapOnce(); // ensures deliveries and strawberries exist
}

/* ensure deliveries (corners) and strawberries (4 central-biased) */
async function seedMapOnce(){
  const dSnap = await getDocs(collection(db, DELIVERIES_COL));
  if (dSnap.size === 0){
    const pts = [
      { x: 80, y: 80, occupied:false, strawberryId:null },
      { x: MAP_SIZE-80, y: 80, occupied:false, strawberryId:null },
      { x: 80, y: MAP_SIZE-80, occupied:false, strawberryId:null },
      { x: MAP_SIZE-80, y: MAP_SIZE-80, occupied:false, strawberryId:null }
    ];
    for (const p of pts) await addDoc(collection(db, DELIVERIES_COL), p);
  }
  const sSnap = await getDocs(collection(db, STRAWBERRIES_COL));
  if (sSnap.size === 0){
    // generate 4 strawberries near center (central-biased)
    for (let i=0;i<4;i++){
      const pos = randPosCentral();
      await addDoc(collection(db, STRAWBERRIES_COL), { x: pos.x, y: pos.y, available: true, ownerId: null, placedAtDelivery: null });
    }
  } else {
    if (sSnap.size < 4){
      for (let i=sSnap.size;i<4;i++){
        const pos = randPosCentral();
        await addDoc(collection(db, STRAWBERRIES_COL), { x: pos.x, y: pos.y, available: true, ownerId: null, placedAtDelivery: null });
      }
    }
  }
}

/* central-biased random pos */
function randNormalCentered(stdFrac=6){
  const mean = MAP_SIZE/2;
  const std = MAP_SIZE / stdFrac;
  let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
  const z = Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
  return Math.round(clamp(mean + z*std, 0, MAP_SIZE));
}
function randPosCentral(){ return { x: randNormalCentered(), y: randNormalCentered() }; }

/* JOIN flow with listener wait and BGM start */
async function joinAs(name, team){
  showLoading(true);
  await ensureGame();
  // seed maze if empty (first client)
  try { await seedMazeIfEmpty(); } catch(e){ console.warn("seed maze err", e); }
  // remove old same-name sessions
  try {
    const snaps = await getDocs(collection(db, PLAYERS_COL));
    for (const d of snaps.docs){
      const data = d.data();
      if (data && data.name === name){
        try { await deleteDoc(d.ref); pushLog(`å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³(${name})ã‚’å‰Šé™¤`, "info"); } catch(e){}
      }
    }
  } catch(e){}
  try {
    const pRef = await addDoc(collection(db, PLAYERS_COL), { name: name||"Player", team, x: randPosCentral().x, y: randPosCentral().y, possession:0, lastAction: serverTimestamp(), dashReadyAt:0, carryingStraw:null });
    sessionId = pRef.id;
    setupListeners();
    // wait for local snapshot to appear (avoid first-join race)
    const start = Date.now(); let ok=false;
    while(Date.now()-start < 5000){
      if (allPlayers.find(p => p._id===sessionId)){ ok=true; break; }
      await new Promise(r=>setTimeout(r,150));
    }
    if (!ok) pushLog("å‚åŠ åæ˜ é…å»¶ãŒã‚ã‚Šã¾ã™ãŒç¶šè¡Œã—ã¾ã™","error");
    // set game playing if waiting
    try {
      await runTransaction(db, async (t) => {
        const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
        const s = await t.get(gRef);
        if (!s.exists()) throw new Error("game missing");
        const g = s.data();
        if (g.state === "waiting") t.update(gRef, { state: "playing" });
      });
    } catch(e){}
    // try play bgm (user action triggered)
    try { bgmAudio.currentTime = 0; await bgmAudio.play().catch(()=>{}); } catch(e){}
    showLoading(false);
    showScreen("game");
    updateStatus("å‚åŠ ä¸­: "+name+" ("+team+")");
    pushLog(`${name} ãŒå‚åŠ ã—ã¾ã—ãŸ (ãƒãƒ¼ãƒ : ${team})`, "event");
  } catch(e){
    showLoading(false); pushLog("å‚åŠ å¤±æ•—: "+(e.message||e),"error"); alert("å‚åŠ å¤±æ•—");
  }
}

/* LEAVE */
async function leave(){
  if (!sessionId) return;
  try { await deleteDoc(doc(db, PLAYERS_COL, sessionId)); } catch(e){}
  sessionId = null; localPlayer = null;
  tearDownListeners();
  showScreen("waiting");
  updateStatus("é›¢è„±ã—ã¾ã—ãŸ");
  try { bgmAudio.pause(); bgmAudio.currentTime = 0; } catch(e){}
}

/* LISTENERS: walls, players, strawberries, deliveries */
function setupListeners(){
  if (unsubWalls) unsubWalls();
  unsubWalls = onSnapshot(collection(db, WALLS_COL), (snap) => {
    const rects = []; snap.forEach(d => { const data = d.data(); rects.push(data); });
    walls = rects;
  });

  if (unsubGame) unsubGame();
  unsubGame = onSnapshot(doc(db, GAME_COLLECTION, GAME_DOC_ID), (snap) => {
    if (!snap.exists()) return;
    gameDoc = snap.data();
    topOni.textContent = gameDoc.scores?.oni || 0;
    if (gameDoc.state === "waiting") { pushLog("ãƒ©ã‚¦ãƒ³ãƒ‰å¾…æ©Ÿã«æˆ»ã‚Šã¾ã—ãŸ","info"); showScreen("team"); }
  });

  if (unsubPlayers) unsubPlayers();
  unsubPlayers = onSnapshot(collection(db, PLAYERS_COL), (snap) => {
    // map snapshot to array but preserve local optimistic movement if recent
    const arr = []; snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    // update allPlayers but avoid overwriting localPlayer position if local moved recently
    if (sessionId){
      const serverLocal = arr.find(p => p._id === sessionId);
      if (serverLocal){
        if (lastLocalMoveTime && (Date.now() - lastLocalMoveTime) < 250){
          // ignore server position for local player to avoid stepping back
          arr.forEach((p,i)=>{ if (p._id === sessionId && localPlayer){ arr[i].x = localPlayer.x; arr[i].y = localPlayer.y; arr[i].carryingStraw = localPlayer.carryingStraw; } });
        }
      }
    }
    allPlayers = arr;
    localPlayer = allPlayers.find(p => p._id === sessionId) || localPlayer;
    const oniCount = allPlayers.filter(p => p.team === "oni").length;
    const runnerCount = allPlayers.filter(p => p.team === "runner").length;
    oniCountEl.textContent = "äººæ•°: "+oniCount; runnerCountEl.textContent = "äººæ•°: "+runnerCount;
    waitOniCount.textContent = oniCount; waitRunnerCount.textContent = runnerCount;
    if (localPlayer){ playerInfoName.textContent = localPlayer.name; playerInfoTeam.textContent = "ãƒãƒ¼ãƒ : "+localPlayer.team; } else { playerInfoName.textContent = "æœªå‚åŠ "; playerInfoTeam.textContent = "ãƒãƒ¼ãƒ : -"; }
    renderPlayerList();
    // attempt collect / update logic
    for (const s of strawberries) attemptCollectStraw(s);
  });

  if (unsubStraw) unsubStraw();
  unsubStraw = onSnapshot(collection(db, STRAWBERRIES_COL), (snap) => {
    const arr = []; snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    strawberries = arr;
    // ensure strawberries never end up inside walls: if they do, teleport to nearest open spot
    for (const s of strawberries) ensureStrawInOpenSpace(s);
    for (const s of strawberries) attemptCollectStraw(s);
  });

  if (unsubDeliveries) unsubDeliveries();
  unsubDeliveries = onSnapshot(collection(db, DELIVERIES_COL), (snap) => {
    const arr = []; snap.forEach(d => { const data = d.data(); data._id = d.id; arr.push(data); });
    deliveries = arr;
    const occupied = deliveries.filter(d=>d.occupied).length;
    topRunnerRem.textContent = Math.max(0, 4 - occupied);
    if (deliveries.length >= 4 && occupied >= 4){
      pushLog("é€ƒã’ãƒãƒ¼ãƒ ãŒå…¨ç´å“æ‰€ã‚’åŸ‹ã‚ã¾ã—ãŸï¼šé€ƒã’å‹åˆ©ï¼","event");
      (async ()=>{ const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID); const gSnap = await getDoc(gRef); const g = gSnap.exists()?gSnap.data():{scores:{oni:0,runner:0}}; await setDoc(gRef, {...g, state:"ended"}); await finalizeAndResetRound(); })();
    }
  });
}

/* tear down */
function tearDownListeners(){
  if (unsubWalls) unsubWalls(); unsubWalls=null;
  if (unsubGame) unsubGame(); unsubGame=null;
  if (unsubPlayers) unsubPlayers(); unsubPlayers=null;
  if (unsubStraw) unsubStraw(); unsubStraw=null;
  if (unsubDeliveries) unsubDeliveries(); unsubDeliveries=null;
  allPlayers=[]; strawberries=[]; deliveries=[]; walls=[]; gameDoc=null;
  renderPlayerList();
}

/* ensure strawberry not inside wall; if inside, teleport to nearest open tile */
async function ensureStrawInOpenSpace(straw){
  // check collision with any wall; if intersects, find random open cell and move there
  function strawIntersectsWall(s){
    for (const w of walls){
      if (s.x >= w.x && s.x <= w.x + w.w && s.y >= w.y && s.y <= w.y + w.h) return true;
    }
    return false;
  }
  if (strawIntersectsWall(straw)){
    // find open cell by random attempts
    for (let i=0;i<30;i++){
      const cand = randPosCentral();
      const fakeS = {x:cand.x,y:cand.y};
      if (!strawIntersectsWall(fakeS)){
        try { await updateDoc(doc(db, STRAWBERRIES_COL, straw._id), { x: cand.x, y: cand.y, available:true, ownerId:null }); } catch(e){}
        pushLog("å£ã¨é‡ãªã£ã¦ã„ãŸã‚¤ãƒã‚´ã‚’å®‰å…¨ãªä½ç½®ã¸ç§»å‹•", "info");
        break;
      }
    }
  }
}

/* finalize & reset */
async function finalizeAndResetRound(){
  try {
    async function delAll(col){
      const snaps = await getDocs(collection(db, col));
      const batch = writeBatch(db);
      for (const d of snaps.docs) batch.delete(d.ref);
      if (snaps.size) await batch.commit();
    }
    await delAll(PLAYERS_COL);
    await delAll(STRAWBERRIES_COL);
    await delAll(DELIVERIES_COL);
    // keep walls intact to avoid regenerating often; if want new maze each round, delete walls too
    await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { state:"waiting", scores:{oni:0, runner:0}, mapSize:MAP_SIZE, runnerRemaining:4, createdAt: serverTimestamp() });
    pushLog("ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’å®Œå…¨ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼/ã‚¢ã‚¤ãƒ†ãƒ å‰Šé™¤ï¼‰", "event");
    await seedMapOnce();
    try { bgmAudio.pause(); bgmAudio.currentTime = 0; } catch(e){}
  } catch(e){ console.error("finalize err", e); }
}

/* Robust carry/pickup implementation:
   - When player wants to pick up (keydown shift or explicit action), client calls runTransaction:
       if strawberry.ownerId == null then set ownerId = sessionId, available=false
     Transaction returns success if acquired.
   - While carrying, client updates strawberry position to player's pos (throttled).
   - On release (keyup shift or explicit), releaseCarryById sets ownerId=null/available=true at current pos.
   - If carrier moves into delivery, checkPlacedOnDelivery marks delivery occupied and strawberry placed.
   - If any oni near carrier (within CAPTURE_RADIUS*1.2), auto-drop (release).
*/
async function tryStartCarryIfNear(){
  if (!localPlayer || !sessionId) return;
  if (localPlayer.team !== "runner") return;
  if (localPlayer.carryingStraw) return;
  // find nearest strawberry within PICKUP_RADIUS
  let nearest = null; let nearestD = Infinity;
  for (const s of strawberries){
    if (!s.available && !s.ownerId) continue; // ownerId null expected for available true; still ignore if unavailable
    const d = Math.hypot(localPlayer.x - s.x, localPlayer.y - s.y);
    if (d <= PICKUP_RADIUS && d < nearestD){ nearest = s; nearestD = d; }
  }
  if (!nearest) return;
  // Attempt transaction to acquire ownership robustly
  try {
    await runTransaction(db, async (t) => {
      const sRef = doc(db, STRAWBERRIES_COL, nearest._id);
      const sSnap = await t.get(sRef);
      if (!sSnap.exists()) throw new Error("straw missing");
      const sData = sSnap.data();
      if (sData.ownerId) throw new Error("already owned");
      // set owner
      t.update(sRef, { ownerId: sessionId, available: false });
      // set player's carryingStraw
      const pRef = doc(db, PLAYERS_COL, sessionId);
      t.update(pRef, { carryingStraw: nearest._id, lastAction: serverTimestamp() });
    });
    pushLog(`ã‚¤ãƒã‚´ã‚’æ´ã¿ã¾ã—ãŸ`, "event");
  } catch(e){
    // failed to acquire (race lost) - ignore
    // but still try to set if ownerId null (defensive)
    try {
      const sDoc = await getDoc(doc(db, STRAWBERRIES_COL, nearest._id));
      if (sDoc.exists()){
        const sData = sDoc.data();
        if (!sData.ownerId){
          await updateDoc(doc(db, STRAWBERRIES_COL, nearest._id), { ownerId: sessionId, available: false });
          await updateDoc(doc(db, PLAYERS_COL, sessionId), { carryingStraw: nearest._id, lastAction: serverTimestamp() });
          pushLog("ç«¶åˆã§å¤±æ•—ã—ã¾ã—ãŸãŒè£œæ­£ã§æ´ã¿ã¾ã—ãŸ", "info");
        }
      }
    } catch(e){}
  }
}

async function releaseCarryById(strawId){
  if (!strawId) return;
  try {
    const sRef = doc(db, STRAWBERRIES_COL, strawId);
    await updateDoc(sRef, { ownerId: null, available: true });
    try { await updateDoc(doc(db, PLAYERS_COL, sessionId), { carryingStraw: null, lastAction: serverTimestamp() }); } catch(e){}
    pushLog("ã‚¤ãƒã‚´ã‚’è¨­ç½®ã—ã¾ã—ãŸ", "event");
  } catch(e){ console.error(e); }
}

/* checkPlacedOnDelivery */
async function checkPlacedOnDelivery(straw){
  if (!straw) return;
  if (!straw.ownerId) return; // only carried ones can be placed here via carrier
  for (const d of deliveries){
    if (d.occupied) continue;
    const dist = Math.hypot(straw.x - d.x, straw.y - d.y);
    if (dist <= PICKUP_RADIUS){
      try {
        await runTransaction(db, async (t) => {
          const dRef = doc(db, DELIVERIES_COL, d._id);
          const dSnap = await t.get(dRef);
          if (!dSnap.exists()) return;
          const dData = dSnap.data();
          if (dData.occupied) return;
          t.update(dRef, { occupied: true, strawberryId: straw._id });
          const sRef = doc(db, STRAWBERRIES_COL, straw._id);
          t.update(sRef, { ownerId: null, available: false, placedAtDelivery: d._id });
          const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
          const gSnap = await t.get(gRef);
          if (gSnap.exists()){
            const g = gSnap.data();
            const remaining = Math.max(0, (g.runnerRemaining || 4) - 1);
            t.update(gRef, { runnerRemaining: remaining });
          }
        });
        pushLog("ã‚¤ãƒã‚´ãŒç´å“æ‰€ã«è¨­ç½®ã•ã‚Œã¾ã—ãŸ", "event");
      } catch(e){}
      return;
    }
  }
}

/* attemptCollectStraw - legacy auto-pickup for >=2 runners near a strawberry */
async function attemptCollectStraw(straw){
  if (!straw || !straw.available || straw.ownerId) return;
  const nearby = allPlayers.filter(p => p.team === "runner" && Math.hypot(p.x - straw.x, p.y - straw.y) <= PICKUP_RADIUS);
  if (nearby.length >= 2){
    try {
      await runTransaction(db, async (t) => {
        const sRef = doc(db, STRAWBERRIES_COL, straw._id);
        const sSnap = await t.get(sRef);
        if (!sSnap.exists()) throw new Error("straw missing");
        const sData = sSnap.data();
        if (!sData.available || sData.ownerId) throw new Error("already taken");
        t.update(sRef, { available: false });
        for (const p of nearby){
          const pRef = doc(db, PLAYERS_COL, p._id);
          const pSnap = await t.get(pRef);
          if (!pSnap.exists()) continue;
          const cur = pSnap.data().possession || 0;
          t.update(pRef, { possession: cur + 1, lastAction: serverTimestamp() });
        }
      });
      pushLog(`ã‚¤ãƒã‚´å›å: ${nearby.map(n=>n.name).join(", ")}`, "event");
      if (STRAW_RESPAWN_IMMEDIATE){
        try { const newPos = randPosCentral(); await updateDoc(doc(db, STRAWBERRIES_COL, straw._id), { x: newPos.x, y: newPos.y, available: true, ownerId: null, placedAtDelivery: null }); } catch(e){}
      }
    } catch(e){}
  }
}

/* capture handling */
async function checkCapturesAndHandle(){
  const onis = allPlayers.filter(p => p.team === "oni");
  const runners = allPlayers.filter(p => p.team === "runner");
  if (!onis.length || !runners.length) return;
  for (const r of runners){
    for (const o of onis){
      const d = Math.hypot(r.x - o.x, r.y - o.y);
      if (d <= CAPTURE_RADIUS){
        try {
          await updateDoc(doc(db, PLAYERS_COL, r._id), { possession:0, x: randPos().x, y: randPos().y, lastAction: serverTimestamp(), carryingStraw: null });
          await runTransaction(db, async (t) => {
            const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
            const s = await t.get(gRef);
            if (!s.exists()) return;
            const g = s.data();
            const scores = g.scores || { oni:0, runner:0 };
            scores.oni = (scores.oni || 0) + 5;
            t.update(gRef, { scores, lastUpdated: serverTimestamp() });
          });
          pushLog(`${r.name} ãŒæ•ã¾ã£ãŸï¼ é¬¼ãƒãƒ¼ãƒ  +5`, "event");
          explosionAudio.currentTime = 0; explosionAudio.play().catch(()=>{});
          const gSnap2 = await getDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID));
          if (gSnap2.exists()){
            const g2 = gSnap2.data();
            if ((g2.scores?.oni || 0) >= WIN_SCORE){
              pushLog("é¬¼ãƒãƒ¼ãƒ ãŒå‹åˆ©ï¼ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†ã—ã¾ã™", "event");
              await setDoc(doc(db, GAME_COLLECTION, GAME_DOC_ID), { ...g2, state: "ended" });
              await finalizeAndResetRound();
            }
          }
        } catch(e){ console.error(e); }
        break;
      }
    }
  }
}

/* position update throttled */
async function sendPositionIfNeeded(x,y){
  if (!sessionId) return;
  const now = nowMillis();
  if (now - lastPosSend < POSITION_THROTTLE_MS) return;
  lastPosSend = now;
  try { await updateDoc(doc(db, PLAYERS_COL, sessionId), { x, y, lastAction: serverTimestamp() }); } catch(e){}
  lastLocalMoveTime = Date.now(); // mark optimistic local move
}

/* dash handling */
function canDash(p){ if (!p || p.team !== "oni") return false; const readyAt = p.dashReadyAt || 0; return Date.now() >= readyAt; }
async function startDash(){ if (!localPlayer || localPlayer.team !== "oni") return; const now = Date.now(); try { await updateDoc(doc(db, PLAYERS_COL, sessionId), { dashReadyAt: now + DASH_CT_MS }); localPlayer._isDashingUntil = now + DASH_DUR_MS; setTimeout(()=>{ if (localPlayer) localPlayer._isDashingUntil = 0; }, DASH_DUR_MS); } catch(e){} }

/* CHECK WALL COLLISION - rectangle-based collision
   If candidate position collides with wall rect, attempt to slide along axis or block movement.
*/
function collidesWithWalls(x,y, radius=12){
  // simple point-in-rect check with buffer radius
  for (const w of walls){
    if (x + radius > w.x && x - radius < w.x + w.w && y + radius > w.y && y - radius < w.y + w.h) return true;
  }
  return false;
}

/* Ensure strawberry placed locations are not inside wall; if so teleport to nearest open spot */
async function ensureStrawInOpenSpace(straw){
  if (!straw) return;
  for (const w of walls){
    if (straw.x >= w.x && straw.x <= w.x + w.w && straw.y >= w.y && straw.y <= w.y + w.h){
      // find random open cell up to attempts
      for (let i=0;i<50;i++){
        const cand = randPosCentral();
        if (!collidesWithWalls(cand.x, cand.y, 10)){
          try { await updateDoc(doc(db, STRAWBERRIES_COL, straw._id), { x: cand.x, y: cand.y, available: true, ownerId: null, placedAtDelivery: null }); } catch(e){}
          break;
        }
      }
      break;
    }
  }
}

/* RENDERING - drawing world with walls as filled rectangles and sprites if available */
function drawTextBubble(ctx, text, x, y, bg="#000", small=false){
  ctx.save();
  ctx.font = (small ? "12px sans-serif" : "13px sans-serif");
  const metrics = ctx.measureText(text);
  const padX = 8;
  const w = metrics.width + padX*2;
  const h = 18;
  const bx = x - w/2, by = y - h/2;
  ctx.fillStyle = bg;
  const r = 8;
  ctx.beginPath();
  ctx.moveTo(bx+r, by);
  ctx.arcTo(bx+w, by, bx+w, by+h, r);
  ctx.arcTo(bx+w, by+h, bx, by+h, r);
  ctx.arcTo(bx, by+h, bx, by, r);
  ctx.arcTo(bx, by, bx+w, by, r);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, x, y);
  ctx.restore();
}
function drawDirectionHint(ctx, target, self, width, height){
  const dx = target.x - self.x, dy = target.y - self.y;
  const angle = Math.atan2(dy, dx);
  const cx = width/2, cy = height/2;
  const edgeX = cx + Math.cos(angle) * (Math.min(width,height)/2 - 30);
  const edgeY = cy + Math.sin(angle) * (Math.min(width,height)/2 - 30);
  ctx.save(); ctx.translate(edgeX, edgeY); ctx.rotate(angle);
  ctx.fillStyle = "#ff8"; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-10,-6); ctx.lineTo(-10,6); ctx.closePath(); ctx.fill();
  const dist = Math.round(Math.hypot(dx,dy));
  drawTextBubble(ctx, `${target.name} (${dist}m)`, edgeX + 18, edgeY, "#222", true);
  ctx.restore();
}

function drawWorld(ctx, width, height, centerPlayer, applyVisibility){
  ctx.clearRect(0,0,width,height);
  // camera target and lerp
  let tx = centerPlayer ? centerPlayer.x : MAP_SIZE/2;
  let ty = centerPlayer ? centerPlayer.y : MAP_SIZE/2;
  const halfW = width/2, halfH = height/2;
  tx = clamp(tx, halfW, MAP_SIZE - halfW);
  ty = clamp(ty, halfH, MAP_SIZE - halfH);
  camera.x += (tx - camera.x) * camera.lerp;
  camera.y += (ty - camera.y) * camera.lerp;
  const toScreenX = mx => mx - (camera.x - halfW);
  const toScreenY = my => my - (camera.y - halfH);

  // background map
  if (mapImageLoaded){
    const scaleX = width / MAP_SIZE, scaleY = height / MAP_SIZE;
    ctx.drawImage(mapImage, (-(camera.x - halfW))*scaleX, (-(camera.y - halfH))*scaleY, MAP_SIZE*scaleX, MAP_SIZE*scaleY);
  } else { ctx.fillStyle="#081018"; ctx.fillRect(0,0,width,height); }

  // walls
  ctx.fillStyle = "#222";
  for (const w of walls){
    const sx = toScreenX(w.x), sy = toScreenY(w.y);
    ctx.fillRect(sx, sy, w.w, w.h);
  }

  // deliveries
  for (const d of deliveries){
    const sx = toScreenX(d.x), sy = toScreenY(d.y);
    const color = d.occupied ? "#8be08b" : "#ffd39a";
    drawTextBubble(ctx, d.occupied ? "â–³ (è¨­ç½®æ¸ˆ)" : "â–³ ç´å“æ‰€", sx, sy - 26, color);
    if (sprDeliveryLoaded) ctx.drawImage(sprDelivery, sx-16, sy-16, 32, 32);
    else { ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(sx, sy-10); ctx.lineTo(sx-10, sy+10); ctx.lineTo(sx+10, sy+10); ctx.closePath(); ctx.fill(); }
  }

  // strawberries
  for (const s of strawberries){
    const sx = toScreenX(s.x), sy = toScreenY(s.y);
    let visible = true;
    if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
      visible = Math.hypot(centerPlayer.x - s.x, centerPlayer.y - s.y) <= VISIBILITY_RADIUS;
    }
    if (!visible) continue;
    drawTextBubble(ctx, "ãƒ» ã‚¤ãƒã‚´", sx, sy - 26, "#ff6b8a");
    if (sprStrawLoaded) ctx.drawImage(sprStraw, sx-10, sy-10, 20, 20);
    else { ctx.fillStyle = s.available ? "#ff6b8a" : "#5a2a2f"; ctx.beginPath(); ctx.arc(sx, sy, 8, 0, Math.PI*2); ctx.fill(); }
    const runnersNear = allPlayers.filter(p => p.team === "runner" && Math.hypot(p.x - s.x, p.y - s.y) <= PICKUP_RADIUS);
    if (runnersNear.length === 1){ ctx.strokeStyle="rgba(255,255,128,0.9)"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(sx, sy, 12, 0, Math.PI*2); ctx.stroke(); ctx.lineWidth=1; }
  }

  // players
  for (const p of allPlayers){
    let visible = true;
    if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
      if (p._id === centerPlayer._id) visible = true; else visible = (Math.hypot(centerPlayer.x - p.x, centerPlayer.y - p.y) <= VISIBILITY_RADIUS);
    }
    if (!visible) continue;
    const sx = toScreenX(p.x), sy = toScreenY(p.y);
    if (p.team === "runner"){ if (sprRunnerLoaded) ctx.drawImage(sprRunner, sx-14, sy-14, 28,28); else { ctx.fillStyle="#4db8ff"; ctx.beginPath(); ctx.arc(sx,sy,12,0,Math.PI*2); ctx.fill(); } }
    else { if (sprOniLoaded) ctx.drawImage(sprOni, sx-14, sy-14, 28,28); else { ctx.fillStyle="#ffcf4d"; ctx.fillRect(sx-12,sy-12,24,24); } }
    if (localPlayer && p._id === localPlayer._id){ ctx.strokeStyle="#fff"; ctx.lineWidth=2; if (p.team==="runner"){ctx.beginPath();ctx.arc(sx,sy,15,0,Math.PI*2);ctx.stroke();}else ctx.strokeRect(sx-14,sy-14,28,28); ctx.lineWidth=1; }
    if (p.team === "runner"){ if (p.carryingStraw) drawTextBubble(ctx, "é‹æ¬ä¸­", sx, sy - 36, "#2b6b2b"); }
    drawTextBubble(ctx, p.name, sx, sy + 20, "#000", true);
  }

  // darkness for runner
  if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
    ctx.save(); ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.beginPath(); ctx.rect(0,0,width,height); ctx.arc(width/2, height/2, VISIBILITY_RADIUS, 0, Math.PI*2, true);
    try{ ctx.fill('evenodd'); }catch(e){ ctx.globalCompositeOperation='destination-out'; ctx.fill(); ctx.globalCompositeOperation='source-over'; } ctx.restore();
  }

  // nearest teammate hint
  if (applyVisibility && centerPlayer && centerPlayer.team === "runner"){
    const others = allPlayers.filter(p => p.team === "runner" && p._id !== centerPlayer._id);
    if (others.length>0){ others.sort((a,b)=> Math.hypot(a.x-centerPlayer.x,a.y-centerPlayer.y) - Math.hypot(b.x-centerPlayer.x,b.y-centerPlayer.y)); drawDirectionHint(gctx, others[0], centerPlayer, width, height); }
  }
}

/* draw mini map */
function drawMiniMap(){
  miniCtx.clearRect(0,0,miniMap.width,miniMap.height);
  const w = miniMap.width, h = miniMap.height;
  miniCtx.fillStyle="#041218"; miniCtx.fillRect(0,0,w,h);
  if (mapImageLoaded) miniCtx.drawImage(mapImage,0,0,w,h);
  for (const wd of walls){ const sx = wd.x/MAP_SIZE*w, sy = wd.y/MAP_SIZE*h, sw = wd.w/MAP_SIZE*w, sh = wd.h/MAP_SIZE*h; miniCtx.fillStyle="#222"; miniCtx.fillRect(sx,sy,sw,sh); }
  for (const d of deliveries){ const sx=d.x/MAP_SIZE*w, sy=d.y/MAP_SIZE*h; const color = d.occupied? "#8be08b":"#ffd39a"; miniCtx.fillStyle=color; miniCtx.beginPath(); miniCtx.moveTo(sx,sy-6); miniCtx.lineTo(sx-6,sy+6); miniCtx.lineTo(sx+6,sy+6); miniCtx.closePath(); miniCtx.fill(); }
  for (const s of strawberries){ const sx=s.x/MAP_SIZE*w, sy=s.y/MAP_SIZE*h; miniCtx.fillStyle = s.available ? "#ff6b8a" : "#5a2a2f"; miniCtx.beginPath(); miniCtx.arc(sx,sy,3,0,Math.PI*2); miniCtx.fill(); }
  for (const p of allPlayers){ const sx=p.x/MAP_SIZE*w, sy=p.y/MAP_SIZE*h; miniCtx.fillStyle = p.team==="oni" ? "#ffcf4d":"#4db8ff"; miniCtx.beginPath(); miniCtx.arc(sx,sy,3,0,Math.PI*2); miniCtx.fill(); }
  miniCtx.strokeStyle="rgba(255,255,255,0.06)"; miniCtx.strokeRect(0,0,w,h);
}

/* render loop */
function renderLoop(){ requestAnimationFrame(renderLoop); drawWorld(gctx, gameCanvas.width, gameCanvas.height, localPlayer, true); drawMiniMap(); updateDashStatusUI(); updateBoostUI(); }
renderLoop();

/* input handling robust */
const pressed = new Set(); let lastKeyEventTime = Date.now();
window.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){ e.preventDefault(); lastKeyEventTime = Date.now(); if (!pressed.has(k)) pressed.add(k); // handle shift pick/place toggle on keydown
    if (k === "shift" && localPlayer && localPlayer.team === "runner"){
      // if not carrying => try pick; if carrying => place (toggle)
      if (!localPlayer.carryingStraw) tryStartCarryIfNear();
      else if (localPlayer.carryingStraw) releaseCarryById(localPlayer.carryingStraw);
    }
  }
});
window.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  if (["arrowleft","arrowright","arrowup","arrowdown","a","s","d","w","shift"].includes(k)){ e.preventDefault(); lastKeyEventTime = Date.now(); pressed.delete(k);
    // on shift release, if still carrying, place (so both press-to-toggle and hold-to-carry work)
    if (k === "shift" && localPlayer && localPlayer.team === "runner"){
      if (localPlayer.carryingStraw) releaseCarryById(localPlayer.carryingStraw);
    }
  }
});
window.addEventListener('blur', ()=>{ pressed.clear(); });
setInterval(()=>{ if (Date.now() - lastKeyEventTime > 1000) pressed.clear(); }, 1200);

/* movement tick: calculate desired pos, check wall collisions; update strawberry if carrying; auto drop if oni near */
setInterval(async ()=>{
  if (!localPlayer || !sessionId) return;
  let sp = localPlayer.team === "oni" ? ONI_SPEED : RUNNER_SPEED;
  if (localPlayer.team === "oni" && (pressed.has("shift")) && canDash(localPlayer)) await startDash();
  if (localPlayer._isDashingUntil && Date.now() < localPlayer._isDashingUntil) sp *= DASH_MULT;
  if (localPlayer.carryingStraw) sp *= CARRY_SPEED_MULT;
  if (localPlayer.team === "runner"){
    const nearby = allPlayers.filter(p => p._id !== localPlayer._id && p.team === "runner" && Math.hypot(p.x - localPlayer.x, p.y - localPlayer.y) <= COOP_BOOST_DIST);
    if (nearby.length >= 1) sp *= COOP_SPEED_MULT;
  }
  let dx=0, dy=0;
  if (pressed.has("a") || pressed.has("arrowleft")) dx -= 1;
  if (pressed.has("d") || pressed.has("arrowright")) dx += 1;
  if (pressed.has("w") || pressed.has("arrowup")) dy -= 1;
  if (pressed.has("s") || pressed.has("arrowdown")) dy += 1;
  if (dx===0 && dy===0){
    // update carried strawberry position even if not moving
    if (localPlayer.carryingStraw) {
      try { await updateDoc(doc(db, STRAWBERRIES_COL, localPlayer.carryingStraw), { x: localPlayer.x, y: localPlayer.y, ownerId: sessionId }); } catch(e){}
    }
    return;
  }
  const mag = Math.hypot(dx,dy) || 1; dx = dx/mag * sp; dy = dy/mag * sp;
  let nx = clamp(localPlayer.x + dx, 0, MAP_SIZE), ny = clamp(localPlayer.y + dy, 0, MAP_SIZE);
  // wall collision: if new pos collides, attempt axis-aligned sliding
  if (collidesWithWalls(nx, ny, 12)){
    // try X move only
    if (!collidesWithWalls(nx, localPlayer.y, 12)) ny = localPlayer.y;
    // try Y move only
    else if (!collidesWithWalls(localPlayer.x, ny, 12)) nx = localPlayer.x;
    else { nx = localPlayer.x; ny = localPlayer.y; } // blocked
  }
  // apply
  localPlayer.x = nx; localPlayer.y = ny;
  await sendPositionIfNeeded(nx, ny);
  // update carried strawberry pos
  if (localPlayer.carryingStraw){
    try { await updateDoc(doc(db, STRAWBERRIES_COL, localPlayer.carryingStraw), { x: nx, y: ny, ownerId: sessionId }); } catch(e){}
    const straw = strawberries.find(s => s._id === localPlayer.carryingStraw);
    if (straw) await checkPlacedOnDelivery(straw);
    // auto-drop if oni close
    const onis = allPlayers.filter(p => p.team === "oni");
    for (const o of onis){
      const d = Math.hypot(o.x - localPlayer.x, o.y - localPlayer.y);
      if (d <= CAPTURE_RADIUS * 1.2){
        const strawId = localPlayer.carryingStraw;
        if (strawId){ await releaseCarryById(strawId); pushLog("é¬¼ãŒè¿‘ã„ãŸã‚ã‚¤ãƒã‚´ã‚’å¼·åˆ¶è¨­ç½®ã—ã¾ã—ãŸ", "event"); }
        break;
      }
    }
  } else {
    if (pressed.has("shift")) await tryStartCarryIfNear(); // fallback
  }
  await tryDeliver(localPlayer);
  for (const s of strawberries) attemptCollectStraw(s);
  await checkCapturesAndHandle();
}, 100);

/* footstep audible for runners if oni within range (configurable) */
setInterval(()=>{
  if (!localPlayer) return;
  if (localPlayer.team === "runner"){
    const onis = allPlayers.filter(p => p.team === "oni");
    for (const o of onis){
      const d = Math.hypot(o.x - localPlayer.x, o.y - localPlayer.y);
      if (d <= VISIBILITY_RADIUS * FOOTSTEP_RANGE_MULT){ asiotoAudio.currentTime = 0; asiotoAudio.play().catch(()=>{}); break; }
    }
  }
}, 900);

/* player list: hide numeric ğŸ“, show only 'é‹æ¬ä¸­' */
function renderPlayerList(){
  playerListEl.innerHTML = "";
  const sorted = allPlayers.slice().sort((a,b)=> a.team.localeCompare(b.team) || (a.name||"").localeCompare(b.name));
  for (const p of sorted){
    const row = document.createElement("div"); row.className="playerRow";
    const left = document.createElement("div"); left.style.display="flex"; left.style.gap="8px"; left.style.alignItems="center";
    const shape = document.createElement("div");
    shape.style.width="14px"; shape.style.height="14px"; shape.style.borderRadius = p.team==="runner" ? "50%" : "3px";
    shape.style.background = p.team==="runner" ? "#4db8ff" : "#ffd54d";
    left.appendChild(shape);
    const info = document.createElement("div"); info.innerHTML = `<div style="font-weight:700">${p.name}</div><div class="small">${p.team}</div>`;
    left.appendChild(info);
    row.appendChild(left);
    const right = document.createElement("div"); right.style.textAlign="right";
    const coords = adminMode ? `<div class="small">${Math.round(p.x)},${Math.round(p.y)}</div>` : "";
    const carryText = p.carryingStraw ? `<div style="font-weight:700">é‹æ¬ä¸­</div>` : "";
    right.innerHTML = `${carryText}${coords}`;
    if (adminMode){
      const kick = document.createElement("button"); kick.textContent="é€€å‡º"; kick.style.background="#ff6b6b"; kick.style.border="none"; kick.style.padding="6px"; kick.style.borderRadius="6px";
      kick.onclick = async ()=>{ if (!confirm(`${p.name} ã‚’å¼·åˆ¶é€€å‡ºã—ã¾ã™ã‹ï¼Ÿ`)) return; try { await deleteDoc(doc(db, PLAYERS_COL, p._id)); pushLog(`${p.name} ã‚’ç®¡ç†è€…ãŒé€€å‡ºã•ã›ã¾ã—ãŸ`, "event"); } catch(e){ alert("é€€å‡ºå¤±æ•—"); } };
      right.appendChild(kick);
    }
    row.appendChild(right);
    playerListEl.appendChild(row);
  }
}

/* dash UI */
function updateDashStatusUI(){
  if (!localPlayer){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: -"; return; }
  if (localPlayer.team !== "oni"){ dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: (é¬¼ã®ã¿)"; return; }
  const readyAt = localPlayer.dashReadyAt || 0; const now = Date.now();
  if (now >= readyAt) dashStatusEl.textContent = "ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨å¯èƒ½"; else dashStatusEl.textContent = `ãƒ€ãƒƒã‚·ãƒ¥: ä½¿ç”¨ä¸å¯ æ®‹ã‚Š ${Math.ceil((readyAt-now)/1000)}s`;
}
function updateBoostUI(){
  if (!localPlayer){ boostStatusEl.textContent = ""; return; }
  if (localPlayer.team === "runner"){
    const nearby = allPlayers.filter(p => p._id !== localPlayer._id && p.team === "runner" && Math.hypot(p.x - localPlayer.x, p.y - localPlayer.y) <= COOP_BOOST_DIST);
    if (nearby.length >= 1){ boostStatusEl.textContent = "ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ–ãƒ¼ã‚¹ãƒˆä¸­ï¼ˆè¿‘ãã«ä»²é–“ï¼‰"; boostStatusEl.style.background = "linear-gradient(90deg,#7fffd4,#2ee6b6)"; }
    else { boostStatusEl.textContent = ""; boostStatusEl.style.background = "linear-gradient(180deg,#06281f,#0b3940)"; }
  } else boostStatusEl.textContent = "";
}

/* UI hooks */
toTeamBtn.addEventListener('click', ()=> showScreen("team"));
chooseOni.addEventListener('click', ()=>{ joinedTeamChoice="oni"; showScreen("join"); });
chooseRunner.addEventListener('click', ()=>{ joinedTeamChoice="runner"; showScreen("join"); });
backFromTeam.addEventListener('click', ()=> showScreen("waiting"));
backFromJoin.addEventListener('click', ()=> showScreen("team"));
joinNow.addEventListener('click', async ()=>{ const name = (inputName.value||"").trim(); if (!name){ alert("åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; } if (!joinedTeamChoice){ alert("ãƒãƒ¼ãƒ é¸æŠã—ã¦ãã ã•ã„"); return; } await joinAs(name, joinedTeamChoice); joinedTeamChoice=null; inputName.value=""; });
leaveBtn.addEventListener('click', ()=> leave());
adminSmall.addEventListener('click', async ()=>{ const pass = prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:"); if (pass === ADMIN_PASS){ adminMode=true; adminResetBtn.classList.remove("hidden"); alert("ç®¡ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹"); renderPlayerList(); } else alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¸æ­£"); });
adminResetBtn.addEventListener('click', async ()=>{ if (!adminMode) return alert("ç®¡ç†ãŒå¿…è¦"); if (!confirm("å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return; await finalizeAndResetRound(); });
homeResetBtn.addEventListener('click', async ()=>{ const pass = prompt("ç®¡ç†ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰:"); if (pass === ADMIN_PASS) await finalizeAndResetRound(); else alert("é•ã„ã¾ã™"); });

/* periodic win-check & housekeeping */
setInterval(async ()=>{
  try {
    const gRef = doc(db, GAME_COLLECTION, GAME_DOC_ID);
    const gSnap = await getDoc(gRef);
    if (!gSnap.exists()) return;
    const g = gSnap.data(); const scores = g.scores || { oni:0, runner:0 };
    if (g.state === "playing" && (scores.oni >= WIN_SCORE || scores.runner >= WIN_SCORE)){
      pushLog("ã‚¹ã‚³ã‚¢åˆ°é”ã§ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’çµ‚äº†ã—ã¾ã™", "event");
      await setDoc(gRef, { ...g, state: "ended" });
      await finalizeAndResetRound();
    }
  } catch(e){}
}, 3000);

/* frequent responsiveness checks */
setInterval(async ()=>{ for (const s of strawberries) attemptCollectStraw(s); await checkCapturesAndHandle(); }, 1200);

/* utility: place object in open cell (not colliding with walls) */
async function placeInOpenArea(docRef, data){
  for (let i=0;i<60;i++){
    const p = randPosCentral();
    if (!collidesWithWalls(p.x, p.y, 12)){
      try { await updateDoc(docRef, { ...data, x: p.x, y: p.y }); return true; } catch(e){}
    }
  }
  // fallback: put at center
  try { await updateDoc(docRef, { ...data, x: MAP_SIZE/2, y: MAP_SIZE/2 }); } catch(e){}
  return false;
}

/* EOF of code */
</script>
</body>
</html>
